// openFrameworks - completions
//
// syntax:
//
// {
//  "trigger": "namespace::method \t(variation)",
//  "contents": "namespace::method()"
// }
//
// example:
// { "trigger": "ofBackground \t(ofColor)"                                           ,"contents": "ofBackground(${1:const ofColor &c})"},
//
{
    "scope": "source.c++",

    "completions":
    [
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////        

        /////////// Application ///////////////
        ///////////////////////////////////////
        // ofAppBaseWindow
        { "trigger": "ofAppBaseWindow::disableSetupScreen"                              ,"contents": "${1:ofAppBaseWindow}.disableSetupScreen()"},
        { "trigger": "ofAppBaseWindow::doesHWOrientation"                               ,"contents": "${1:ofAppBaseWindow}.doesHWOrientation()"},
        { "trigger": "ofAppBaseWindow::enableSetupScreen"                               ,"contents": "${1:ofAppBaseWindow}.enableSetupScreen()"},
        { "trigger": "ofAppBaseWindow::getFrameNum"                                     ,"contents": "${1:ofAppBaseWindow}.getFrameNum()"},
        { "trigger": "ofAppBaseWindow::getFrameRate"                                    ,"contents": "${1:ofAppBaseWindow}.getFrameRate()"},
        { "trigger": "ofAppBaseWindow::getHeight"                                       ,"contents": "${1:ofAppBaseWindow}.getHeight()"},
        { "trigger": "ofAppBaseWindow::getLastFrameTime"                                ,"contents": "${1:ofAppBaseWindow}.getLastFrameTime()"},
        { "trigger": "ofAppBaseWindow::getOrientation"                                  ,"contents": "${1:ofAppBaseWindow}.getOrientation()"},
        { "trigger": "ofAppBaseWindow::getScreenSize"                                   ,"contents": "${1:ofAppBaseWindow}.getScreenSize()"},
        { "trigger": "ofAppBaseWindow::getWidth"                                        ,"contents": "${1:ofAppBaseWindow}.getWidth()"},
        { "trigger": "ofAppBaseWindow::getWindowMode"                                   ,"contents": "${1:ofAppBaseWindow}.getWindowMode()"},
        { "trigger": "ofAppBaseWindow::getWindowPosition"                               ,"contents": "${1:ofAppBaseWindow}.getWindowPosition()"},
        { "trigger": "ofAppBaseWindow::getWindowSize"                                   ,"contents": "${1:ofAppBaseWindow}.getWindowSize()"},
        { "trigger": "ofAppBaseWindow::hideCursor"                                      ,"contents": "${1:ofAppBaseWindow}.hideCursor()"},
        { "trigger": "ofAppBaseWindow::initializeWindow"                                ,"contents": "${1:ofAppBaseWindow}.initializeWindow()"},
        { "trigger": "ofAppBaseWindow::runAppViaInfiniteLoop \t(ofBaseApp)"             ,"contents": "${1:ofAppBaseWindow}.runAppViaInfiniteLoop(${2:ofBaseApp *appPtr})"},
        { "trigger": "ofAppBaseWindow::setFrameRate \t(float)"                          ,"contents": "${1:ofAppBaseWindow}.setFrameRate(${2:float targetRate})"},
        { "trigger": "ofAppBaseWindow::setFullscreen \t(bool)"                          ,"contents": "${1:ofAppBaseWindow}.setFullscreen(${2:bool fullscreen})"},
        { "trigger": "ofAppBaseWindow::setOrientation \t(ofOrientation)"                ,"contents": "${1:ofAppBaseWindow}.setOrientation(${2:ofOrientation orientation})"},
        { "trigger": "ofAppBaseWindow::setWindowPosition \t(int, int)"                  ,"contents": "${1:ofAppBaseWindow}.setWindowPosition(${2:int x}, ${3:int y})"},
        { "trigger": "ofAppBaseWindow::setWindowShape \t(int, int)"                     ,"contents": "${1:ofAppBaseWindow}.setWindowShape(${2:int w}, ${3:int h})"},
        { "trigger": "ofAppBaseWindow::setWindowTitle \t(string)"                       ,"contents": "${1:ofAppBaseWindow}.setWindowTitle(${2:string title})"},
        { "trigger": "ofAppBaseWindow::setupOpenGL \t(int, int, int)"                   ,"contents": "${1:ofAppBaseWindow}.setupOpenGL(${2:int w}, ${3:int h}, ${4:int screenMode})"},
        { "trigger": "ofAppBaseWindow::showCursor"                                      ,"contents": "${1:ofAppBaseWindow}.showCursor()"},
        { "trigger": "ofAppBaseWindow::toggleFullscreen"                                ,"contents": "${1:ofAppBaseWindow}.toggleFullscreen()"},
        ////////////////////////////////////
        // ofAppRunner
        { "trigger": "ofDoesHWOrientation"                                             ,"contents": "ofDoesHWOrientation()"},
        { "trigger": "ofExit(int)"                                                     ,"contents": "ofExit(${1:int status=0})"},
        { "trigger": "ofGetAppPtr"                                                     ,"contents": "ofGetAppPtr()"},
        { "trigger": "ofGetFrameNum"                                                   ,"contents": "ofGetFrameNum()"},
        { "trigger": "ofGetFrameRate"                                                  ,"contents": "ofGetFrameRate()"},
        { "trigger": "ofGetHeight"                                                     ,"contents": "ofGetHeight()"},
        { "trigger": "ofGetLastFrameTime"                                              ,"contents": "ofGetLastFrameTime()"},
        { "trigger": "ofGetOrientation"                                                ,"contents": "ofGetOrientation()"},
        { "trigger": "ofGetScreenHeight"                                               ,"contents": "ofGetScreenHeight()"},
        { "trigger": "ofGetScreenWidth"                                                ,"contents": "ofGetScreenWidth()"},
        { "trigger": "ofGetWidth"                                                      ,"contents": "ofGetWidth()"},
        { "trigger": "ofGetWindowHeight"                                               ,"contents": "ofGetWindowHeight()"},
        { "trigger": "ofGetWindowMode"                                                 ,"contents": "ofGetWindowMode()"},
        { "trigger": "ofGetWindowPositionX"                                            ,"contents": "ofGetWindowPositionX()"},
        { "trigger": "ofGetWindowPositionY"                                            ,"contents": "ofGetWindowPositionY()"},
        { "trigger": "ofGetWindowRect"                                                 ,"contents": "ofGetWindowRect()"},
        { "trigger": "ofGetWindowSize"                                                 ,"contents": "ofGetWindowSize()"},
        { "trigger": "ofGetWindowWidth"                                                ,"contents": "ofGetWindowWidth()"},
        { "trigger": "ofHideCursor"                                                    ,"contents": "ofHideCursor()"},
        { "trigger": "ofRunApp \t(ofBaseApp)"                                          ,"contents": "ofRunApp(${1:ofBaseApp * app})"},
        { "trigger": "ofRunApp \t(ofPtr< ofBaseApp >)"                                 ,"contents": "ofRunApp(${1:ofPtr< ofBaseApp > OFSA})"},
        { "trigger": "ofRunApp \t(ofBaseApp)"                                          ,"contents": "ofRunApp(${1:ofBaseApp *OFSA=NULL})"},
        { "trigger": "ofSetAppPtr \t(ofPtr< ofBaseApp >)"                              ,"contents": "ofSetAppPtr(${1:ofPtr< ofBaseApp > appPtr})"},
        { "trigger": "ofSetFrameRate \t(int)"                                          ,"contents": "ofSetFrameRate(${1:int targetRate})"},
        { "trigger": "ofSetFrameRate \t(int)"                                          ,"contents": "ofSetFrameRate(${1:int targetRate})"},
        { "trigger": "ofSetFullscreen \t(bool fullscreen)"                             ,"contents": "ofSetFullscreen(${1:bool fullscreen})"},
        { "trigger": "ofSetOrientation \t(ofOrientation)"                              ,"contents": "ofSetOrientation(${1:ofOrientation orientation})"},
        { "trigger": "ofSetVerticalSync \t(bool)"                                      ,"contents": "ofSetVerticalSync(${1:bool bSync})"},
        { "trigger": "ofSetWindowPosition \t(int)"                                     ,"contents": "ofSetWindowPosition(${1:int x})"},
        { "trigger": "ofSetWindowPosition \t(int, int)"                                ,"contents": "ofSetWindowPosition(${1:int x}, ${2:int y})"},
        { "trigger": "ofSetWindowShape \t(int)"                                        ,"contents": "ofSetWindowShape(${1:int width})"},
        { "trigger": "ofSetWindowShape \t(int, int)"                                   ,"contents": "ofSetWindowShape(${1:int width}, ${2:int height})"},
        { "trigger": "ofSetWindowTitle"                                                ,"contents": "ofSetWindowTitle()"},
        { "trigger": "ofSetWindowTitle \t(string)"                                     ,"contents": "ofSetWindowTitle(${1:string title})"},
        { "trigger": "ofSetupOpenGL \t(ofAppBaseWindow, int, int, int)"                ,"contents": "ofSetupOpenGL(${1:ofAppBaseWindow * windowPtr}, ${2:int w}, ${3:int h}, ${4:int screenMode})"},
        { "trigger": "ofSetupOpenGL \t(int w, int h, int screenMode)"                  ,"contents": "ofSetupOpenGL(${1:int w}, ${2:int h}, ${3:int screenMode})"},
        { "trigger": "ofSetupOpenGL \t(ofAppBaseWindow, int, int, int)"                ,"contents": "ofSetupOpenGL(${1:ofAppBaseWindow *windowPtr}, ${2:int w}, ${3:int h}, ${4:int screenMode})"},
        { "trigger": "ofShowCursor"                                                    ,"contents": "ofShowCursor()"},
        { "trigger": "ofSleepMillis \t(int)"                                           ,"contents": "ofSleepMillis(${1:int millis})"},
        { "trigger": "ofToggleFullscreen"                                              ,"contents": "ofToggleFullscreen()"},
        ////////////////////////////
        // screenMode
        { "trigger": "OF_WINDOW \tscreenMode"                ,"contents": "OF_WINDOW"},
        { "trigger": "OF_FULLSCREEN \tscreenMode"            ,"contents": "OF_FULLSCREEN"},
        { "trigger": "OF_GAME_MODE \tscreenMode"             ,"contents": "OF_GAME_MODE"},

        ///////////////////////////
        // ofBaseApp
        { "trigger": "ofBaseApp::audioReceived \t(float, int, int)"                 ,"contents": "audioReceived(${2:float * input}, ${3:int bufferSize}, ${4:int nChannels})"},
        { "trigger": "ofBaseApp::audioRequested \t(float, int, int)"                ,"contents": "audioRequested(${2:float * output}, ${3:int bufferSize}, ${4:int nChannels})"},
        { "trigger": "ofBaseApp::dragEvent \t(ofDragInfo)"                          ,"contents": "dragEvent(${2:ofDragInfo dragInfo})"},
        { "trigger": "ofBaseApp::draw"                                              ,"contents": "draw()"},
        { "trigger": "ofBaseApp::exit"                                              ,"contents": "exit()"},
        { "trigger": "ofBaseApp::gotMessage \t(ofMessage)"                          ,"contents": "gotMessage(${2:ofMessage msg})"},
        { "trigger": "ofBaseApp::keyPressed \t(int)"                                ,"contents": "keyPressed(${2:int key})"},
        { "trigger": "ofBaseApp::keyReleased \t(int)"                               ,"contents": "keyReleased(${2:int key})"},
        { "trigger": "ofBaseApp::mouseDragged \t(int, int, int)"                    ,"contents": "mouseDragged(${2:int x}, ${3:int y}, ${4:int button})"},
        { "trigger": "ofBaseApp::mouseMoved \t(int, int)"                           ,"contents": "mouseMoved(${2:int x}, ${3:int y})"},
        { "trigger": "ofBaseApp::mousePressed \t(int, int, int)"                    ,"contents": "mousePressed(${2:int x}, ${3:int y}, ${4:int button})"},
        { "trigger": "ofBaseApp::mouseReleased"                                     ,"contents": "mouseReleased()"},
        { "trigger": "ofBaseApp::mouseReleased \t(int, int, int)"                   ,"contents": "mouseReleased(${2:int x}, ${3:int y}, ${4:int button})"},
        { "trigger": "ofBaseApp::setup"                                             ,"contents": "setup()"},
        { "trigger": "ofBaseApp::update"                                            ,"contents": "update()"},
        { "trigger": "ofBaseApp::windowEntry \t(int)"                               ,"contents": "windowEntry(${2:int state})"},
        { "trigger": "ofBaseApp::windowResized \t(int, int)"                        ,"contents": "windowResized(${2:int w}, ${3:int h})"},
        { "trigger": "ofBaseApp::mouseX \t variable"                                ,"contents": "mouseX"},
        { "trigger": "ofBaseApp::mouseY \t variable"                                ,"contents": "mouseY"},
        ///////////////////////////
        // keyCodes
        { "trigger": "OF_KEY_BACKSPACE \tkeyCode"                   ,"contents": "OF_KEY_BACKSPACE"},
        { "trigger": "OF_KEY_RETURN \tkeyCode"                      ,"contents": "OF_KEY_RETURN"},
        { "trigger": "OF_KEY_PRINTSCR \tkeyCode"                    ,"contents": "OF_KEY_PRINTSCR"},
        { "trigger": "OF_KEY_F1 \tkeyCode"                          ,"contents": "OF_KEY_F1"},
        { "trigger": "OF_KEY_F2 \tkeyCode"                          ,"contents": "OF_KEY_F2"},
        { "trigger": "OF_KEY_F3 \tkeyCode"                          ,"contents": "OF_KEY_F3"},
        { "trigger": "OF_KEY_F4 \tkeyCode"                          ,"contents": "OF_KEY_F4"},
        { "trigger": "OF_KEY_F5 \tkeyCode"                          ,"contents": "OF_KEY_F5"},
        { "trigger": "OF_KEY_F6 \tkeyCode"                          ,"contents": "OF_KEY_F6"},
        { "trigger": "OF_KEY_F7 \tkeyCode"                          ,"contents": "OF_KEY_F7"},
        { "trigger": "OF_KEY_F8 \tkeyCode"                          ,"contents": "OF_KEY_F8"},
        { "trigger": "OF_KEY_F9 \tkeyCode"                          ,"contents": "OF_KEY_F9"},
        { "trigger": "OF_KEY_F10 \tkeyCode"                         ,"contents": "OF_KEY_F10"},
        { "trigger": "OF_KEY_F11 \tkeyCode"                         ,"contents": "OF_KEY_F11"},
        { "trigger": "OF_KEY_F12 \tkeyCode"                         ,"contents": "OF_KEY_F12"},
        { "trigger": "OF_KEY_LEFT \tkeyCode"                        ,"contents": "OF_KEY_LEFT"},
        { "trigger": "OF_KEY_UP \tkeyCode"                          ,"contents": "OF_KEY_UP"},
        { "trigger": "OF_KEY_RIGHT \tkeyCode"                       ,"contents": "OF_KEY_RIGHT"},
        { "trigger": "OF_KEY_DOWN \tkeyCode"                        ,"contents": "OF_KEY_DOWN"},
        { "trigger": "OF_KEY_PAGE_UP \tkeyCode"                     ,"contents": "OF_KEY_PAGE_UP"},
        { "trigger": "OF_KEY_PAGE_DOWN \tkeyCode"                   ,"contents": "OF_KEY_PAGE_DOWN"},
        { "trigger": "OF_KEY_HOME \tkeyCode"                        ,"contents": "OF_KEY_HOME"},
        { "trigger": "OF_KEY_END \tkeyCode"                         ,"contents": "OF_KEY_END"},
        { "trigger": "OF_KEY_INSERT \tkeyCode"                      ,"contents": "OF_KEY_INSERT"},

        // ofDraginfo
        { "trigger": "ofDragInfo::files"                            ,"contents": "${1:ofDragInfo}.files()"},
        { "trigger": "ofDragInfo::files"                            ,"contents": "${1:ofDragInfo}.files"},
        { "trigger": "ofDragInfo::position"                         ,"contents": "${1:ofDragInfo}.position"},

        ///////////////// TYPES  ///////////////
        ////////////////////////////////////////
        // ofColor
        { "trigger": "ofColor \tinstance"                       ,"contents": "ofColor ${1:myColor}"},
        { "trigger": "ofFloatColor \tinstance"                  ,"contents": "ofFloatColor ${1:myColor}"},
        { "trigger": "ofShortColor \tinstance"                  ,"contents": "ofShortColor ${1:myColor}"},

        { "trigger": "ofColor_::clamp"                                                              ,"contents": "${1:ofColor_}.clamp()"},
        { "trigger": "ofColor_::fromHex \t(int, float)"                                             ,"contents": "${1:ofColor_}.fromHex(${2:int hexColor}, ${3:float alpha=limit()})"},
        { "trigger": "ofColor_::fromHsb \t(float, float, float, float)"                             ,"contents": "${1:ofColor_}.fromHsb(${2:float hue}, ${3:float saturation}, ${4:float brightness}, ${5:float alpha=limit()})"},
        { "trigger": "ofColor_::getBrightness"                                                      ,"contents": "${1:ofColor_}.getBrightness()"},
        { "trigger": "ofColor_::getClamped"                                                         ,"contents": "${1:ofColor_}.getClamped()"},
        { "trigger": "ofColor_::getHex"                                                             ,"contents": "${1:ofColor_}.getHex()"},
        { "trigger": "ofColor_::getHsb \t(float, float, float)"                                     ,"contents": "${1:ofColor_}.getHsb(${2:float &hue}, ${3:float &saturation}, ${4:float &brightness})"},
        { "trigger": "ofColor_::getHue"                                                             ,"contents": "${1:ofColor_}.getHue()"},
        { "trigger": "ofColor_::getInverted"                                                        ,"contents": "${1:ofColor_}.getInverted()"},
        { "trigger": "ofColor_::getLerped(const ofColor_< PixelType >, float)"                      ,"contents": "${1:ofColor_}.getLerped(${2:const ofColor_< PixelType > &target}, ${3:float amount})"},
        { "trigger": "ofColor_::getLightness"                                                       ,"contents": "${1:ofColor_}.getLightness()"},
        { "trigger": "ofColor_::getSaturation"                                                      ,"contents": "${1:ofColor_}.getSaturation()"},
        { "trigger": "ofColor_::invert"                                                             ,"contents": "${1:ofColor_}.invert()"},
        { "trigger": "ofColor_::lerp \t(const ofColor_< PixelType >, float)"                        ,"contents": "${1:ofColor_}.lerp(${2:const ofColor_< PixelType > &target}, ${3:float amount})"},
        { "trigger": "ofColor_::limit"                                                              ,"contents": "${1:ofColor_}.limit()"},
        { "trigger": "ofColor_::set \t(float, float, float, float)"                                 ,"contents": "${1:ofColor_}.set(${2:float _r}, ${3:float _g}, ${4:float _b}, ${5:float _a=limit()})"},
        { "trigger": "ofColor_::set \t(float, float)"                                               ,"contents": "${1:ofColor_}.set(${2:float _gray}, ${3:float _a=limit()})"},
        { "trigger": "ofColor_::set \t(ofColor_< PixelType > const)"                                ,"contents": "${1:ofColor_}.set(${2:ofColor_< PixelType > const &color})"},
        { "trigger": "ofColor_::setBrightness \t(float)"                                            ,"contents": "${1:ofColor_}.setBrightness(${2:float brightness})"},
        { "trigger": "ofColor_::setHex \t(int, float)"                                              ,"contents": "${1:ofColor_}.setHex(${2:int hexColor}, ${3:float alpha=limit()})"},
        { "trigger": "ofColor_::setHsb \t(float, float, float, float)"                              ,"contents": "${1:ofColor_}.setHsb(${2:float hue}, ${3:float saturation}, ${4:float brightness}, ${5:float alpha=limit()})"},
        { "trigger": "ofColor_::setHsb \t(float, float, float)"                                     ,"contents": "${1:ofColor_}.setHsb(${2:float hue}, ${3:float saturation}, ${4:float brightness})"},
        { "trigger": "ofColor_::setHue \t(float)"                                                   ,"contents": "${1:ofColor_}.setHue(${2:float hue})"},
        { "trigger": "ofColor_::setSaturation \t(float)"                                            ,"contents": "${1:ofColor_}.setSaturation(${2:float saturation})"},
        { "trigger": "ofColor_::a \talpha"                                                          ,"contents": "${1:ofColor_}.a"},
        { "trigger": "ofColor_::b"                                                                  ,"contents": "${1:ofColor_}.b"},
        { "trigger": "ofColor_::black"                                                              ,"contents": "${1:ofColor_}.black "},
        { "trigger": "ofColor_::blue"                                                               ,"contents": "${1:ofColor_}.blue"},
        { "trigger": "ofColor_::cyan"                                                               ,"contents": "${1:ofColor_}.cyan"},
        { "trigger": "ofColor_::g"                                                                  ,"contents": "${1:ofColor_}.g"},
        { "trigger": "ofColor_::gray"                                                               ,"contents": "${1:ofColor_}.gray"},
        { "trigger": "ofColor_::green"                                                              ,"contents": "${1:ofColor_}.green"},
        { "trigger": "ofColor_::magenta"                                                            ,"contents": "${1:ofColor_}.magenta"},
        { "trigger": "ofColor_::r"                                                                  ,"contents": "${1:ofColor_}.r"},
        { "trigger": "ofColor_::red"                                                                ,"contents": "${1:ofColor_}.red"},
        { "trigger": "ofColor_::white"                                                              ,"contents": "${1:ofColor_}.white"},
        { "trigger": "ofColor_::yellow"                                                             ,"contents": "${1:ofColor_}.yellow"},

        //////////////////////////////////////
        // ofPoint
        { "trigger": "ofPoint"                                                      ,"contents": "ofPoint ${1:point}"},
        { "trigger": "ofPoint::set \t(float, float, float)"                         ,"contents": "set(${1:float _x}, ${2:float _y}, ${3:float _z})"},
        { "trigger": "ofPoint::v \tvariable"                ,"contents": "${1:ofPoint}.v"},
        { "trigger": "ofPoint::x \tvariable"                ,"contents": "${1:ofPoint}.x"},
        { "trigger": "ofPoint::y \tvariable"                ,"contents": "${1:ofPoint}.y"},
        { "trigger": "ofPoint::z \tvariable"                ,"contents": "${1:ofPoint}.z"},

        //////////////////////////////////////
        // ofPtr
        { "trigger": "ofPtr"                                                        ,"contents": "ofPtr< ${1:instance} > ptr(new ${1:instance}());"},
        // DONE

        //////////////////////////////////////
        // ofRectangle
        { "trigger": "ofRectangle"                                                      ,"contents": "ofRectangle ${1:rectangle}"},
        { "trigger": "ofRectangle::set \t(float px, float py, float w, float h)"        ,"contents": "${1:ofRectangle}.set(${2:float px}, ${3:float py}, ${4:float w}, ${5:float h})"},
        { "trigger": "ofRectangle::set \t(const ofPoint &p, float w, float h)"          ,"contents": "${1:ofRectangle}.set(${2:const ofPoint &p}, ${3:float w}, ${4:float h})"},
        { "trigger": "ofRectangle::set \t(const ofRectangle &rect)"                     ,"contents": "${1:ofRectangle}.set(${2:const ofRectangle &rect})"},
        { "trigger": "ofRectangle::set \t(const ofPoint &p0, const ofPoint &p1)"        ,"contents": "${1:ofRectangle}.set(${2:const ofPoint &p0}, ${3:const ofPoint &p1})"},
        { "trigger": "ofRectangle \tinstance"                                                     ,"contents": "ofRectangle ${1:myRectangle}"},
        { "trigger": "ofRectangle::height \tvariable"                                             ,"contents": "${1:ofRectangle}.height"},
        { "trigger": "ofRectangle::position \tvariable"                                           ,"contents": "${1:ofRectangle}.position"},
        { "trigger": "ofRectangle::width \tvariable"                                              ,"contents": "${1:ofRectangle}.width"},
        { "trigger": "ofRectangle::x \tvariable"                                                  ,"contents": "${1:ofRectangle}.x"},
        { "trigger": "ofRectangle::y \tvariable"                                                  ,"contents": "${1:ofRectangle}.y"},

        { "trigger": "ofRectangle::alignTo \t(const ofPoint, ofAlignHorz, ofAlignVert)"                                                         ,"contents": "${1:ofRectangle}.alignTo(${2:const ofPoint &targetPoint}, ${3:ofAlignHorz thisHorzAnchor=OF_ALIGN_HORZ_CENTER}, ${4:ofAlignVert thisVertAnchor=OF_ALIGN_VERT_CENTER})"},
        { "trigger": "ofRectangle::alignTo \t(const ofRectangle, ofAlignHorz, ofAlignVert)"                                                     ,"contents": "${1:ofRectangle}.alignTo(${2:const ofRectangle &targetRect}, ${3:ofAlignHorz sharedHorzAnchor=OF_ALIGN_HORZ_CENTER}, ${4:ofAlignVert sharedVertAnchor=OF_ALIGN_VERT_CENTER})"},
        { "trigger": "ofRectangle::alignTo \t(const ofRectangle, ofAlignHorz, ofAlignVert, ofAlignHorz, ofAlignVert)"                           ,"contents": "${1:ofRectangle}.alignTo(${2:const ofRectangle &targetRect}, ${3:ofAlignHorz targetHorzAnchor}, ${4:ofAlignVert targetVertAnchor}, ${5:ofAlignHorz thisHorzAnchor}, ${6:ofAlignVert thisVertAnchor})"},
        { "trigger": "ofRectangle::alignToHorz \t(const float, ofAlignHorz)"                                                                    ,"contents": "${1:ofRectangle}.alignToHorz(${2:const float &targetX}, ${3:ofAlignHorz thisHorzAnchor=OF_ALIGN_HORZ_CENTER})"},
        { "trigger": "ofRectangle::alignToHorz \t(const ofRectangle, ofAlignHorz)"                                                              ,"contents": "${1:ofRectangle}.alignToHorz(${2:const ofRectangle &targetRect}, ${3:ofAlignHorz sharedAnchor=OF_ALIGN_HORZ_CENTER})"},
        { "trigger": "ofRectangle::alignToHorz \t(const ofRectangle, ofAlignHorz, ofAlignHorz)"                                                 ,"contents": "${1:ofRectangle}.alignToHorz(${2:const ofRectangle &targetRect}, ${3:ofAlignHorz targetHorzAnchor}, ${4:ofAlignHorz thisHorzAnchor})"},
        { "trigger": "ofRectangle::alignToVert \t(const float &targetY, ofAlignVert)"                                                           ,"contents": "${1:ofRectangle}.alignToVert(${2:const float &targetY}, ${3:ofAlignVert sharedAnchor=OF_ALIGN_VERT_CENTER})"},
        { "trigger": "ofRectangle::alignToVert \t(const ofRectangle, ofAlignVert)"                                                              ,"contents": "${1:ofRectangle}.alignToVert(${2:const ofRectangle &targetRect}, ${3:ofAlignVert sharedAnchor=OF_ALIGN_VERT_CENTER})"},
        { "trigger": "ofRectangle::alignToVert \t(const ofRectangle, ofAlignVert, ofAlignVert)"                                                 ,"contents": "${1:ofRectangle}.alignToVert(${2:const ofRectangle &targetRect}, ${3:ofAlignVert targetVertAnchor}, ${4:ofAlignVert thisVertAnchor})"},
        { "trigger": "ofRectangle::getArea"                                                                                                     ,"contents": "${1:ofRectangle}.getArea()"},
        { "trigger": "ofRectangle::getAspectRatio"                                                                                              ,"contents": "${1:ofRectangle}.getAspectRatio()"},
        { "trigger": "ofRectangle::getBottom"                                                                                                   ,"contents": "${1:ofRectangle}.getBottom()"},
        { "trigger": "ofRectangle::getBottomLeft"                                                                                               ,"contents": "${1:ofRectangle}.getBottomLeft()"},
        { "trigger": "ofRectangle::getBottomRight"                                                                                              ,"contents": "${1:ofRectangle}.getBottomRight()"},
        { "trigger": "ofRectangle::getCenter"                                                                                                   ,"contents": "${1:ofRectangle}.getCenter()"},
        { "trigger": "ofRectangle::getHeight"                                                                                                   ,"contents": "${1:ofRectangle}.getHeight()"},
        { "trigger": "ofRectangle::getHorzAnchor \t(ofAlignHorz)"                                                                               ,"contents": "${1:ofRectangle}.getHorzAnchor(${2:ofAlignHorz anchor})"},
        { "trigger": "ofRectangle::getIntersection \t(const ofRectangle)"                                                                       ,"contents": "${1:ofRectangle}.getIntersection(${2:const ofRectangle &rect})"},
        { "trigger": "ofRectangle::getLeft"                                                                                                     ,"contents": "${1:ofRectangle}.getLeft()"},
        { "trigger": "ofRectangle::getMax"                                                                                                      ,"contents": "${1:ofRectangle}.getMax()"},
        { "trigger": "ofRectangle::getMaxX"                                                                                                     ,"contents": "${1:ofRectangle}.getMaxX()"},
        { "trigger": "ofRectangle::getMaxY"                                                                                                     ,"contents": "${1:ofRectangle}.getMaxY()"},
        { "trigger": "ofRectangle::getMin"                                                                                                      ,"contents": "${1:ofRectangle}.getMin()"},
        { "trigger": "ofRectangle::getMinX"                                                                                                     ,"contents": "${1:ofRectangle}.getMinX()"},
        { "trigger": "ofRectangle::getMinY"                                                                                                     ,"contents": "${1:ofRectangle}.getMinY()"},
        { "trigger": "ofRectangle::getPerimeter"                                                                                                ,"contents": "${1:ofRectangle}.getPerimeter()"},
        { "trigger": "ofRectangle::getPosition"                                                                                                 ,"contents": "${1:ofRectangle}.getPosition()"},
        { "trigger": "ofRectangle::getPositionRef"                                                                                              ,"contents": "${1:ofRectangle}.getPositionRef()"},
        { "trigger": "ofRectangle::getRight"                                                                                                    ,"contents": "${1:ofRectangle}.getRight()"},
        { "trigger": "ofRectangle::getStandardized"                                                                                             ,"contents": "${1:ofRectangle}.getStandardized()"},
        { "trigger": "ofRectangle::getTop"                                                                                                      ,"contents": "${1:ofRectangle}.getTop()"},
        { "trigger": "ofRectangle::getTopLeft"                                                                                                  ,"contents": "${1:ofRectangle}.getTopLeft()"},
        { "trigger": "ofRectangle::getTopRight"                                                                                                 ,"contents": "${1:ofRectangle}.getTopRight()"},
        { "trigger": "ofRectangle::getUnion \t(const ofRectangle)"                                                                              ,"contents": "${1:ofRectangle}.getUnion(${2:const ofRectangle &rect})"},
        { "trigger": "ofRectangle::getVertAnchor \t(ofAlignVert)"                                                                               ,"contents": "${1:ofRectangle}.getVertAnchor(${2:ofAlignVert anchor})"},
        { "trigger": "ofRectangle::getWidth"                                                                                                    ,"contents": "${1:ofRectangle}.getWidth()"},
        { "trigger": "ofRectangle::getX"                                                                                                        ,"contents": "${1:ofRectangle}.getX()"},
        { "trigger": "ofRectangle::getY"                                                                                                        ,"contents": "${1:ofRectangle}.getY()"},
        { "trigger": "ofRectangle::growToInclude \t(float, float)"                                                                              ,"contents": "${1:ofRectangle}.growToInclude(${2:float px}, ${3:float py})"},
        { "trigger": "ofRectangle::growToInclude \t(const ofPoint)"                                                                             ,"contents": "${1:ofRectangle}.growToInclude(${2:const ofPoint &p})"},
        { "trigger": "ofRectangle::growToInclude \t(const ofRectangle)"                                                                         ,"contents": "${1:ofRectangle}.growToInclude(${2:const ofRectangle &rect})"},
        { "trigger": "ofRectangle::growToInclude \t(const ofPoint, const ofPoint)"                                                              ,"contents": "${1:ofRectangle}.growToInclude(${2:const ofPoint &p0}, ${3:const ofPoint &p1})"},
        { "trigger": "ofRectangle::inside \t(const ofPoint)"                                                                                    ,"contents": "${1:ofRectangle}.inside(${2:const ofPoint &p})"},
        { "trigger": "ofRectangle::inside \t(float, float)"                                                                                     ,"contents": "${1:ofRectangle}.inside(${2:float px}, ${3:float py})"},
        { "trigger": "ofRectangle::inside \t(const ofRectangle)"                                                                                ,"contents": "${1:ofRectangle}.inside(${2:const ofRectangle &rect})"},
        { "trigger": "ofRectangle::inside \t(const ofPoint, const ofPoint)"                                                                     ,"contents": "${1:ofRectangle}.inside(${2:const ofPoint &p0}, ${3:const ofPoint &p1})"},
        { "trigger": "ofRectangle::intersects \t(const ofRectangle)"                                                                            ,"contents": "${1:ofRectangle}.intersects(${2:const ofRectangle &rect})"},
        { "trigger": "ofRectangle::intersects \t(const ofPoint, const ofPoint)"                                                                 ,"contents": "${1:ofRectangle}.intersects(${2:const ofPoint &p0}, ${3:const ofPoint &p1})"},
        { "trigger": "ofRectangle::isEmpty"                                                                                                     ,"contents": "${1:ofRectangle}.isEmpty()"},
        { "trigger": "ofRectangle::isStandardized"                                                                                              ,"contents": "${1:ofRectangle}.isStandardized()"},
        { "trigger": "ofRectangle::scale \t(float)"                                                                                             ,"contents": "${1:ofRectangle}.scale({$2:float s})"},
        { "trigger": "ofRectangle::scale \t(float, float)"                                                                                      ,"contents": "${1:ofRectangle}.scale(${2:float sX}, ${2:float sY})"},
        { "trigger": "ofRectangle::scale \t(const ofPoint)"                                                                                     ,"contents": "${1:ofRectangle}.scale(${2:const ofPoint &s})"},
        { "trigger": "ofRectangle::scaleFromCenter \t(float)"                                                                                   ,"contents": "${1:ofRectangle}.scaleFromCenter(${2:float s})"},
        { "trigger": "ofRectangle::scaleFromCenter \t(float, float)"                                                                            ,"contents": "${1:ofRectangle}.scaleFromCenter(${2:float sX}, ${3:float sY})"},
        { "trigger": "ofRectangle::scaleFromCenter \t(const ofPoint)"                                                                           ,"contents": "${1:ofRectangle}.scaleFromCenter(${2:const ofPoint &s})"},
        { "trigger": "ofRectangle::scaleHeight \t(float)"                                                                                       ,"contents": "${1:ofRectangle}.scaleHeight(${2:float sY})"},
        { "trigger": "ofRectangle::scaleTo \t(const ofRectangle, ofScaleMode)"                                                                  ,"contents": "${1:ofRectangle}.scaleTo(${2:const ofRectangle &targetRect}, ${3:ofScaleMode scaleMode=OF_SCALEMODE_FIT})"},
        { "trigger": "ofRectangle::scaleTo \t(const ofRectangle, ofAspectRatioMode, ofAlignHorz, ofAlignVert)"                                  ,"contents": "${1:ofRectangle}.scaleTo(${2:const ofRectangle &targetRect}, ${3:ofAspectRatioMode subjectAspectRatioMode}, ${4:ofAlignHorz sharedHorzAnchor=OF_ALIGN_HORZ_CENTER}, ${5:ofAlignVert sharedVertAnchor=OF_ALIGN_VERT_CENTER})"},
        { "trigger": "ofRectangle::scaleTo \t(const ofRectangle, ofAspectRatioMode, ofAlignHorz, ofAlignVert, ofAlignHorz, ofAlignVert)"        ,"contents": "${1:ofRectangle}.scaleTo(${2:const ofRectangle &targetRect}, ${3:ofAspectRatioMode subjectAspectRatioMode}, ${4:ofAlignHorz modelHorzAnchor}, ${5:ofAlignVert modelVertAnchor}, ${6:ofAlignHorz subjectHorzAnchor}, ${7:ofAlignVert subjectVertAnchor})"},
        { "trigger": "ofRectangle::scaleWidth \t(float)"                                                                                        ,"contents": "${1:ofRectangle}.scaleWidth(${2:float sX})"},
        { "trigger": "ofRectangle::set \t(float, float, float, float)"                                                                          ,"contents": "${1:ofRectangle}.set(${2:float px}, ${3:float py}, ${4:float w}, ${5:float h})"},
        { "trigger": "ofRectangle::set \t(const ofPoint, float, float)"                                                                         ,"contents": "${1:ofRectangle}.set(${2:const ofPoint &p}, ${3:float w}, ${4:float h})"},
        { "trigger": "ofRectangle::set \t(const ofRectangle)"                                                                                   ,"contents": "${1:ofRectangle}.set(${2:const ofRectangle &rect})"},
        { "trigger": "ofRectangle::set \t(const ofPoint, const ofPoint)"                                                                        ,"contents": "${1:ofRectangle}.set(${2:const ofPoint &p0}, ${3:const ofPoint &p1})"},
        { "trigger": "ofRectangle::setFromCenter \t(float, float, float, float)"                                                                ,"contents": "${1:ofRectangle}.setFromCenter(${2:float px}, ${3:float py}, ${4:float w}, ${5:float h})"},
        { "trigger": "ofRectangle::setFromCenter \t(const ofPoint, float, float)"                                                               ,"contents": "${1:ofRectangle}.setFromCenter(${2:const ofPoint &p}, ${3:float w}, ${4:float h})"},
        { "trigger": "ofRectangle::setHeight \t(float)"                                                                                         ,"contents": "${1:ofRectangle}.setHeight(${2:float h})"},
        { "trigger": "ofRectangle::setPosition \t(float, float)"                                                                                ,"contents": "${1:ofRectangle}.setPosition(${2:float px}, ${3:float py})"},
        { "trigger": "ofRectangle::setPosition \t(const ofPoint)"                                                                               ,"contents": "${1:ofRectangle}.setPosition(${2:const ofPoint &p})"},
        { "trigger": "ofRectangle::setWidth \t(float)"                                                                                          ,"contents": "${1:ofRectangle}.setWidth(${2:float w})"},
        { "trigger": "ofRectangle::setX \t(float)"                                                                                              ,"contents": "${1:ofRectangle}.setX(${2:float px})"},
        { "trigger": "ofRectangle::setY \t(float)"                                                                                              ,"contents": "${1:ofRectangle}.setY(${2:float py})"},
        { "trigger": "ofRectangle::standardize"                                                                                                 ,"contents": "${1:ofRectangle}.standardize()"},
        { "trigger": "ofRectangle::translate \t(float, float)"                                                                                  ,"contents": "${1:ofRectangle}.translate(${2:float dx}, ${3:float dy})"},
        { "trigger": "ofRectangle::translate \t(const ofPoint)"                                                                                 ,"contents": "${1:ofRectangle}.translate(${2:const ofPoint &dp})"},
        { "trigger": "ofRectangle::translateX \t(float)"                                                                                        ,"contents": "${1:ofRectangle}.translateX(${2:float dx})"},
        { "trigger": "ofRectangle::translateY \t(float)"                                                                                        ,"contents": "${1:ofRectangle}.translateY(${2:float dy})"},
        // scaleMode
        { "trigger": "OF_SCALEMODE_FIT \tscaleMode"             ,"contents": "OF_SCALEMODE_FIT"},
        { "trigger": "OF_ALIGN_HORZ_CENTER"                     ,"contents": "OF_ALIGN_HORZ_CENTER"},


        //////////////////////////////////////
        // ofStyle
        { "trigger": "ofStyle::bFill"                                               ,"contents": "${1:ofStyle}.bFill"},
        { "trigger": "ofStyle::bgColor"                                             ,"contents": "${1:ofStyle}.bgColor"},
        { "trigger": "ofStyle::blending"                                            ,"contents": "${1:ofStyle}.blending"},
        { "trigger": "ofStyle::blendingMode"                                        ,"contents": "${1:ofStyle}.blendingMode"},
        { "trigger": "ofStyle::circleResolution"                                    ,"contents": "${1:ofStyle}.circleResolution"},
        { "trigger": "ofStyle::color"                                               ,"contents": "${1:ofStyle}.color"},
        { "trigger": "ofStyle::curveResolution"                                     ,"contents": "${1:ofStyle}.curveResolution"},
        { "trigger": "ofStyle::drawBitmapMode"                                      ,"contents": "${1:ofStyle}.drawBitmapMode"},
        { "trigger": "ofStyle::lineWidth"                                           ,"contents": "${1:ofStyle}.lineWidth"},
        { "trigger": "ofStyle::polyMode"                                            ,"contents": "${1:ofStyle}.polyMode"},
        { "trigger": "ofStyle::rectMode"                                            ,"contents": "${1:ofStyle}.rectMode"},
        { "trigger": "ofStyle::smoothing"                                           ,"contents": "${1:ofStyle}.smoothing"},
        { "trigger": "ofStyle::sphereResolution"                                    ,"contents": "${1:ofStyle}.sphereResolution"},


        ///////////// Events //////////////
        //////////////////////////////////
        // ofAudioEventArgs
        { "trigger": "ofAudioEventArgs::buffer"                         ,"contents": "${1:ofAudioEventArgs}.buffer()"},
        { "trigger": "ofAudioEventArgs::bufferSize"                     ,"contents": "${1:ofAudioEventArgs}.bufferSize()"},
        //////////////////////////////////
        // ofCoreEvents
        //
        // I don't thin they should be in auto-complete, it's oF internals [martin]
        //////////////////////////////////
        // ofEvent
        { "trigger": "ofEvent"                                                      ,"contents": "ofEvent<${2:float}> ${1:onVolumeChange}"},
        { "trigger": "ofNotifyEvent"                                                ,"contents": "ofNotifyEvent(${1:onVolumeChange}, ${2:10.0})"},
        { "trigger": "ofAddListener \t(ofEvent,this, &testApp:onVolumeChange)"      ,"contents": "ofAddListener(${1:mySoundObject.onVolumeChange},${2:this}, ${3:&testApp:onVolumeChange})"},
        //////////////////////////////////
        // ofEvents functions
        { "trigger": "ofGetKeyPressed \t(int)"                              ,"contents": "ofGetKeyPressed(${1:int key=-1})"},
        { "trigger": "ofGetMousePressed \t(int)"                            ,"contents": "ofGetMousePressed(${1:int button=-1})"},
        { "trigger": "ofGetMouseX"                                          ,"contents": "ofGetMouseX()"},
        { "trigger": "ofGetMouseY"                                          ,"contents": "ofGetMouseY()"},
        { "trigger": "ofGetPreviousMouseX"                                  ,"contents": "ofGetPreviousMouseX()"},
        { "trigger": "ofGetPreviousMouseY"                                  ,"contents": "ofGetPreviousMouseY()"},
        { "trigger": "ofSetEscapeQuitsApp \t(bool)"                         ,"contents": "ofSetEscapeQuitsApp(${1:bool bQuitOnEsc})"},

        /////////////////// GRAPHICS /////////////////
        //////////////////////////////////////////////
        // ofGraphics
        { "trigger": "ofBackground \t(RGB)"                                          ,"contents": "ofBackground(${1:int r}, ${2:int g}, ${3:int b})"},
        { "trigger": "ofBackground \t(RGBa)"                                         ,"contents": "ofBackground(${1:int r}, ${2:int g}, ${3:int b}, ${4:int a})" },
        { "trigger": "ofBackground \t(brightness, alpha)"                            ,"contents": "ofBackground(${1:int brightness}, ${2:int alpha=255})" },
        { "trigger": "ofBackground \t(ofColor)"                                      ,"contents": "ofBackground(${1:const ofColor &c})" },
        { "trigger": "ofBackgroundGradient"                                          ,"contents": "ofBackgroundGradient(${1:const ofColor &start}, ${2:const ofColor &end}, ${3:ofGradientMode mode=OF_GRADIENT_CIRCULAR})" },
        { "trigger": "ofBackgroundHex"                                               ,"contents": "ofBackgroundHex(${1:int hexColor}, ${2:int alpha=255})" },
        { "trigger": "ofBeginSaveScreenAsPDF"                                        ,"contents": "ofBeginSaveScreenAsPDF(${1:string filename}, ${2:bool bMultipage=false}, ${3:bool b3D=false}, ${4:ofRectangle viewport=ofRectangle(0, 0, 0, 0)})" },
        { "trigger": "ofBeginShape"                                                  ,"contents": "ofBeginShape()" },
        { "trigger": "ofBezier \t(xy)"                                               ,"contents": "ofBezier(${1:float x0}, ${2:float y0}, ${3:float x1}, ${4:float y1}, ${5:float x2}, ${6:float y2}, ${7:float x3}, ${8:float y3})" },
        { "trigger": "ofBezier \t(xyz)"                                               ,"contents": "ofBezier(${1:float x0}, ${2:float y0}, ${3:float z0}, ${4:float x1}, ${5:float y1}, ${6:float z1}, ${7:float x2}, ${8:float y2}, ${9:float z2}, ${10:float x3}, ${11:float y3}, ${12:float z3})" },
        { "trigger": "ofBezierVertex \t(xy)"                                         ,"contents": "ofBezierVertex(${1:float x1}, ${2:float y1}, ${3:float x2}, ${4:float y2}, ${5:float x3}, ${6:float y3})" },
        { "trigger": "ofBezierVertex \t(xyz)"                                         ,"contents": "ofBezierVertex(${1:float x1}, ${2:float y1}, ${3:float z1}, ${4:float x2}, ${5:float y2}, ${6:float z2}, ${7:float x3}, ${8:float y3}, ${9:float z3})" },
        { "trigger": "ofBezierVertex \t(ofPoint)"                                    ,"contents": "ofBezierVertex(${1:const ofPoint &p1}, ${2:const ofPoint &p2}, ${3:const ofPoint &p3})" },
        { "trigger": "ofBgColorPtr"                                                  ,"contents": "ofBgColorPtr()" },
        { "trigger": "ofBox"                                                         ,"contents": "ofBox(${1:float size})" },
        { "trigger": "ofBox \t(xy)"                                                  ,"contents": "ofBox(${1:float x}, ${2:float y}, ${3:float size})" },
        { "trigger": "ofBox \t(xyz)"                                                 ,"contents": "ofBox(${1:float x}, ${2:float y}, ${3:float z}, ${4:float size})" },
        { "trigger": "ofBox \t(ofPoint)"                                             ,"contents": "ofBox(${1:const ofPoint &position}, ${2:float size})" },
        { "trigger": "ofCircle \t(xy)"                                               ,"contents": "ofCircle(${1:float x}, ${2:float y}, ${3:float radius})" },
        { "trigger": "ofCircle \t(xyz)"                                              ,"contents": "ofCircle(${1:float x}, ${2:float y}, ${3:float z}, ${4:float radius})" },
        { "trigger": "ofCircle \t(ofPoint)"                                          ,"contents": "ofCircle(${1:const ofPoint &p}, ${2:float radius})" },
        { "trigger": "ofClear \t(RGBa)"                                              ,"contents": "ofClear(${1:float r}, ${2:float g}, ${3:float b}, ${4:float a=0})" },
        { "trigger": "ofClear \t(brightness, alpha)"                                 ,"contents": "ofClear(${1:float brightness}, ${2:float a=0})" },
        { "trigger": "ofClear \t(ofColor)"                                           ,"contents": "ofClear(${1:const ofColor &c})" },
        { "trigger": "ofClearAlpha"                                                  ,"contents": "ofClearAlpha()" },
        { "trigger": "ofCone \t(size)"                                               ,"contents": "ofCone(${1:float size})" },
        { "trigger": "ofCone \t(radius size)"                                        ,"contents": "ofCone(${1:float radius}, ${2:float height})" },
        { "trigger": "ofCone \t(xy)"                                                 ,"contents": "ofCone(${1:float x}, ${2:float y}, ${3:float radius}, ${4:float height})" },
        { "trigger": "ofCone \t(xyz)"                                                ,"contents": "ofCone(${1:float x}, ${2:float y}, ${3:float z}, ${4:float radius}, ${5:float height})" },
        { "trigger": "ofCone \t(ofPoint)"                                            ,"contents": "ofCone(${1:const ofPoint &position}, ${2:float radius}, ${3:float height})" },
        { "trigger": "ofCurve \t(xy)"                                                ,"contents": "ofCurve(${1:float x0}, ${2:float y0}, ${3:float x1}, ${4:float y1}, ${5:float x2}, ${6:float y2}, ${7:float x3}, ${8:float y3})" },
        { "trigger": "ofCurve \t(xyz)"                                               ,"contents": "ofCurve(${1:float x0}, ${2:float y0}, ${3:float z0}, ${4:float x1}, ${5:float y1}, ${6:float z1}, ${7:float x2}, ${8:float y2}, ${9:float z2}, ${10:float x3}, ${11:float y3}, ${12:float z3})" },
        { "trigger": "ofCurveVertex \t(xy)"                                          ,"contents": "ofCurveVertex(${1:float x}, ${2:float y})" },
        { "trigger": "ofCurveVertex \t(ofPoint)"                                     ,"contents": "ofCurveVertex(${1:ofPoint &p})" },
        { "trigger": "ofCurveVertices"                                               ,"contents": "ofCurveVertices(${1:const vector< ofPoint > &curvePoints})" },
        { "trigger": "ofDisableAlphaBlending"                                        ,"contents": "ofDisableAlphaBlending()" },
        { "trigger": "ofDisableBlendMode"                                            ,"contents": "ofDisableBlendMode()" },
        { "trigger": "ofDisablePointSprites"                                         ,"contents": "ofDisablePointSprites()" },
        { "trigger": "ofDisableSmoothing"                                            ,"contents": "ofDisableSmoothing()" },
        { "trigger": "ofDrawBitmapString \t(xy)"                                     ,"contents": "ofDrawBitmapString(${1:string textString}, ${2:float x}, ${3:float y}})" },
        { "trigger": "ofDrawBitmapString \t(xyz)"                                    ,"contents": "ofDrawBitmapString(${1:string textString}, ${2:float x}, ${3:float y}, ${4:float z})" },
        { "trigger": "ofDrawBitmapString \t(ofPoint)"                                ,"contents": "ofDrawBitmapString(${1:string textString}, ${2:const ofPoint &p})" },
        { "trigger": "ofDrawBitmapStringHighlight \t(xy)"                            ,"contents": "ofDrawBitmapStringHighlight(${1:string text}, ${2:int x}, ${3:int x}, ${4:const ofColor &background=ofColor::black}, ${5:const ofColor &foreground=ofColor::white})" },
        { "trigger": "ofDrawBitmapStringHighlight \t(ofPoint)"                       ,"contents": "ofDrawBitmapStringHighlight(${1:string text}, ${2:const ofPoint &position}, ${3:const ofColor &background=ofColor::black}, ${4:const ofColor &foreground=ofColor::white})" },
        { "trigger": "ofEllipse \t(xy)"                                              ,"contents": "ofEllipse(${1:float x}, ${2:float y}, ${3:float width}, ${4:float height})" },
        { "trigger": "ofEllipse \t(xyz)"                                             ,"contents": "ofEllipse(${1:float x}, ${2:float y}, ${3:float z}, ${4:float width}, ${5:float height})" },
        { "trigger": "ofEllipse \t(ofPoint)"                                         ,"contents": "ofEllipse(${1:const ofPoint &p}, ${2:float width}, ${3:float height})" },
        { "trigger": "ofEnableAlphaBlending"                                         ,"contents": "ofEnableAlphaBlending()" },
        { "trigger": "ofEnableBlendMode"                                             ,"contents": "ofEnableBlendMode(${1:ofBlendMode blendMode})" },
        { "trigger": "ofEnablePointSprites"                                          ,"contents": "ofEnablePointSprites()" },
        { "trigger": "ofEnableSmoothing"                                             ,"contents": "ofEnableSmoothing()" },
        { "trigger": "ofEndSaveScreenAsPDF"                                          ,"contents": "ofEndSaveScreenAsPDF()" },
        { "trigger": "ofEndShape"                                                    ,"contents": "ofEndShape(${1:bool bClose=false)}" },
        { "trigger": "ofFill"                                                        ,"contents": "ofFill()" },
        { "trigger": "ofGetCoordHandedness"                                          ,"contents": "ofGetCoordHandedness()" },
        { "trigger": "ofGetCurrentRenderer"                                          ,"contents": "ofGetCurrentRenderer()" },
        { "trigger": "ofGetCurrentViewport"                                          ,"contents": "ofGetCurrentViewport()" },
        { "trigger": "ofGetFill"                                                     ,"contents": "ofGetFill()" },
        { "trigger": "ofGetGLRenderer"                                               ,"contents": "ofGetGLRenderer()" },
        { "trigger": "ofGetRectMode"                                                 ,"contents": "ofGetRectMode()" },
        { "trigger": "ofGetStyle"                                                    ,"contents": "ofGetStyle()" },
        { "trigger": "ofGetViewportHeight"                                           ,"contents": "ofGetViewportHeight()" },
        { "trigger": "ofGetViewportWidth"                                            ,"contents": "ofGetViewportWidth()" },
        { "trigger": "ofLine \t(xy)"                                                 ,"contents": "ofLine(${1:float x1}, ${2:float y1}, ${3:float x2}, ${4:float y2})" },
        { "trigger": "ofLine \t(xyz)"                                                ,"contents": "ofLine(${1:float x1}, ${2:float y1}, ${3:float z1}, ${4:float x2}, ${5:float y2}, ${6:float z2})" },
        { "trigger": "ofLine \t(ofPoint)"                                            ,"contents": "ofLine(${1:const ofPoint &p1}, ${2:const ofPoint &p2})" },
        { "trigger": "ofLoadIdentityMatrix"                                          ,"contents": "ofLoadIdentityMatrix()" },
        { "trigger": "ofLoadMatrix \t(ofMatrix4x4)"                                  ,"contents": "ofLoadMatrix(${1:const ofMatrix4x4 &m})" },
        { "trigger": "ofLoadMatrix \t(float)"                                        ,"contents": "ofLoadMatrix(${1:const float *m})" },
        { "trigger": "ofMultMatrix \t(ofMatrix4x4)"                                  ,"contents": "ofMultMatrix(${1:const ofMatrix4x4 &m})" },
        { "trigger": "ofMultMatrix \t(float)"                                        ,"contents": "ofMultMatrix(${1:const float *m})" },
        { "trigger": "ofNextContour"                                                 ,"contents": "ofNextContour(${1:bool bClose=false})" },
        { "trigger": "ofNoFill"                                                      ,"contents": "ofNoFill()" },
        { "trigger": "ofOrientationToDegrees"                                        ,"contents": "ofOrientationToDegrees(${1:ofOrientation orientation})" },
        { "trigger": "ofPopMatrix"                                                   ,"contents": "ofPopMatrix()" },
        { "trigger": "ofPopStyle"                                                    ,"contents": "ofPopStyle()" },
        { "trigger": "ofPopView"                                                     ,"contents": "ofPopView()" },
        { "trigger": "ofPushMatrix"                                                  ,"contents": "ofPushMatrix()" },
        { "trigger": "ofPushStyle"                                                   ,"contents": "ofPushStyle()" },
        { "trigger": "ofPushView"                                                    ,"contents": "ofPushView()" },
        { "trigger": "ofRect \t(xywh)"                                               ,"contents": "ofRect(${1:float x}, ${2:float y}, ${3:float w}, ${4:float h})" },
        { "trigger": "ofRect \t(xyzwh)"                                              ,"contents": "ofRect(${1:float x}, ${2:float y}, ${3:float z}, ${4:float w}, ${5:float h})" },
        { "trigger": "ofRect \t(ofPoint)"                                            ,"contents": "ofRect(${1:const ofPoint &p}, ${2:float w}, ${3:float h})" },
        { "trigger": "ofRect \t(ofRectangle)"                                        ,"contents": "ofRect(${1:const ofRectangle &r})" },
        { "trigger": "ofRectRounded \t(xy)"                                          ,"contents": "ofRectRounded(${1:float x}, ${2:float y}, ${3:float w}, ${4:float h}, ${5:float r})" },
        { "trigger": "ofRectRounded \t(xyz)"                                         ,"contents": "ofRectRounded(${1:float x}, ${2:float y}, ${3:float z}, ${4:float w}, ${5:float h}, ${6:float r})" },
        { "trigger": "ofRectRounded \t(ofPoint)"                                     ,"contents": "ofRectRounded(${1:const ofPoint &p}, ${2:float w}, ${3:float h}, ${4:float r})" },
        { "trigger": "ofRectRounded \t(ofRectangle)"                                 ,"contents": "ofRectRounded(${1:const ofRectangle &b}, ${2:float r})" },
        { "trigger": "ofRotate"                                                      ,"contents": "ofRotate(${1:float degrees})" },
        { "trigger": "ofRotate \t(xyz)"                                              ,"contents": "ofRotate(${1:float degrees}, ${2:float vecX}, ${3:float vecY}, ${4:float vecZ})" },
        { "trigger": "ofRotateX"                                                     ,"contents": "ofRotateX(${1:float degrees})" },
        { "trigger": "ofRotateY"                                                     ,"contents": "ofRotateY(${1:float degrees})" },
        { "trigger": "ofRotateZ"                                                     ,"contents": "ofRotateZ(${1:float degrees})" },
        { "trigger": "ofScale"                                                       ,"contents": "ofScale(${1:float xAmnt}, ${2:float yAmnt}, ${3:float zAmnt=1})" },
        { "trigger": "ofSetBackgroundAuto"                                           ,"contents": "ofSetBackgroundAuto(${1:bool bManual})" },
        { "trigger": "ofSetBackgroundColor \t(rgba)"                                 ,"contents": "ofSetBackgroundColor(${1:int r}, ${2:int g}, ${3:int b)}, ${4:int a=255})" },
        { "trigger": "ofSetBackgroundColor \t(brightness, alpha)"                    ,"contents": "ofSetBackgroundColor(${1:int brightness}, ${2:int alpha=255})" },
        { "trigger": "ofSetBackgroundColor \t(ofColor)"                              ,"contents": "ofSetBackgroundColor(${1:const ofColor &c})" },
        { "trigger": "ofSetBackgroundColorHex"                                       ,"contents": "ofSetBackgroundColorHex(${1:int hexColor}, ${2:int alpha=255})" },
        { "trigger": "ofSetCircleResolution"                                         ,"contents": "ofSetCircleResolution(${1:int res})" },
        { "trigger": "ofSetColor \t(RGB)"                                            ,"contents": "ofSetColor(${1:int r}, ${2:int g}, ${3:int b})" },
        { "trigger": "ofSetColor \t(RGBa)"                                           ,"contents": "ofSetColor(${1:int r}, ${2:int g}, ${3:int b}, ${4:int a})" },
        { "trigger": "ofSetColor \t(gray)"                                           ,"contents": "ofSetColor(${1:int gray})" },
        { "trigger": "ofSetColor \t(ofColor)"                                        ,"contents": "ofSetColor(${1:const ofColor &color})" },
        { "trigger": "ofSetColor \t(ofColor, alpha)"                                 ,"contents": "ofSetColor(${1:const ofColor &color}, ${2:int _a})" },
        { "trigger": "ofSetCoordHandedness"                                          ,"contents": "ofSetCoordHandedness(${1:ofHandednessType handedness})" },
        { "trigger": "ofSetCurrentRenderer"                                          ,"contents": "ofSetCurrentRenderer(${1:ofPtr< ofBaseRenderer > renderer})" },
        { "trigger": "ofSetCurveResolution"                                          ,"contents": "ofSetCurveResolution(${1:int res})" },
        { "trigger": "ofSetDrawBitmapMode"                                           ,"contents": "ofSetDrawBitmapMode(${1:ofDrawBitmapMode mode})" },
        { "trigger": "ofSetHexColor"                                                 ,"contents": "ofSetHexColor(${1:int hexColor})" },
        { "trigger": "ofSetLineWidth"                                                ,"contents": "ofSetLineWidth(${1:float lineWidth})" },
        { "trigger": "ofSetPolyMode"                                                 ,"contents": "ofSetPolyMode(${1:int mode})" },
        { "trigger": "ofSetPolyMode \t(ofPolyWindingMode)"                           ,"contents": "ofSetPolyMode(${1:ofPolyWindingMode mode})" },
        { "trigger": "ofSetRectMode"                                                 ,"contents": "ofSetRectMode(${1:int mode})" },
        { "trigger": "ofSetRectMode \t(ofRectMode)"                                  ,"contents": "ofSetRectMode(${1:ofRectMode mode})" },
        { "trigger": "ofSetSphereResolution"                                         ,"contents": "ofSetSphereResolution(${1:int res})" },
        { "trigger": "ofSetStyle"                                                    ,"contents": "ofSetStyle(${1:ofStyle style})" },
        { "trigger": "ofSetupScreen"                                                 ,"contents": "ofSetupScreen()" },
        { "trigger": "ofSetupScreenOrtho"                                            ,"contents": "ofSetupScreenOrtho(${1:float width=0}, ${2:float height=0}, ${3:ofOrientation orientation=OF_ORIENTATION_UNKNOWN}, ${4:bool vFlip=true}, ${5:float nearDist=-1}, ${6:float farDist=-1})" },
        { "trigger": "ofSetupScreenPerspective"                                      ,"contents": "ofSetupScreenPerspective(${1:float width=0}, ${2:float height=0}, ${3:ofOrientation orientation=OF_ORIENTATION_UNKNOWN}, ${4:bool vFlip=true}, ${5:float fov=60}, ${6:float nearDist=0}, ${7:float farDist=0})" },
        { "trigger": "ofSphere"                                                      ,"contents": "ofSphere(${1:float radius})" },
        { "trigger": "ofSphere \t(xy)"                                               ,"contents": "ofSphere(${1:float x}, ${2:float y}, ${3:float radius})" },
        { "trigger": "ofSphere \t(xyz)"                                              ,"contents": "ofSphere(${1:float x}, ${2:float y}, ${3:float z}, ${4:float radius})" },
        { "trigger": "ofSphere \t(ofPoint)"                                          ,"contents": "ofSphere(${1:const ofPoint &position}, ${2:float radius})" },
        { "trigger": "ofTranslate \t(xyz)"                                           ,"contents": "ofTranslate(${1:float x}, ${2:float y}, ${3:float z=0})" },
        { "trigger": "ofTranslate \t(ofPoint)"                                       ,"contents": "ofTranslate(${1:const ofPoint &p})" },
        { "trigger": "ofTriangle \t(xy)"                                             ,"contents": "ofTriangle(${1:float x1}, ${2:float y1}, ${3:float x2}, ${4:float y2}, ${5:float x3}, ${6:float y3})" },
        { "trigger": "ofTriangle \t(xyz)"                                            ,"contents": "ofTriangle(${1:float x1}, ${2:float y1}, ${3:float z1}, ${4:float x2}, ${5:float y2}, ${6:float z2}, ${7:float x3}, ${8:float y3}, ${9:float z3})" },
        { "trigger": "ofTriangle \t(ofPoint, ofPoint, ofPoint)"                      ,"contents": "ofTriangle(${1:const ofPoint &p1}, ${2:const ofPoint &p2}, ${3:const ofPoint &p3})" },
        { "trigger": "ofVertex \t(xy)"                                               ,"contents": "ofVertex(${1:float x}, ${2:float y})" },
        { "trigger": "ofVertex \t(xyz)"                                              ,"contents": "ofVertex(${1:float x}, ${2:float y}, ${3:float z})" },
        { "trigger": "ofVertex \t(ofPoint)"                                          ,"contents": "ofVertex(${1:ofPoint &p})" },
        { "trigger": "ofVertices"                                                    ,"contents": "ofVertices(${1:const vector< ofPoint > &polyPoints})" },
        { "trigger": "ofViewport"                                                    ,"contents": "ofViewport(${1:float x=0}, ${2:float y=0}, ${3:float width=0}, ${4:float height=0}, ${5:bool invertY=true})" },
        { "trigger": "ofViewport \t(ofRectangle)"                                    ,"contents": "ofViewport(${1:ofRectangle viewport})" },
        { "trigger": "ofbClearBg"                                                    ,"contents": "ofbClearBg()" },
        ////////////////////////////////////
        // ofGradientModes
        { "trigger": "OF_GRADIENT_CIRCULAR \tofGradientMode"                         ,"contents": "OF_GRADIENT_CIRCULAR"},
        /////////////////////////////////////////////
        // ofImage
        { "trigger": "ofImage \tinstance"                                            ,"contents": "ofImage ${1:myImage}"},
        { "trigger": "ofImage::allocate"                                             ,"contents": "${1:ofImage}.allocate(${2:int w}, ${3:int h}, ${4:ofImageType type})"},
        { "trigger": "ofImage::bAllocated"                                           ,"contents": "${1:ofImage}.bAllocated()"},
        { "trigger": "ofImage::bind"                                                 ,"contents": "${1:ofImage}.bind()"},
        { "trigger": "ofImage::clear"                                                ,"contents": "${1:ofImage}.clear()"},
        { "trigger": "ofImage::clone"                                                ,"contents": "${1:ofImage}.clone(${2:const ofImage_< SrcType > &mom})"},
        { "trigger": "ofImage::crop"                                                 ,"contents": "${1:ofImage}.crop(${2:int x}, ${3:int y}, ${4:int w}, ${5:int h})"},
        { "trigger": "ofImage::cropFrom"                                             ,"contents": "${1:ofImage}.cropFrom(${2:ofImage_< PixelType > &otherImage}, ${3:int x}, ${4:int y}, ${5:int w}, ${6:int h})"},
        { "trigger": "ofImage::draw \t(ofRectangle)"                                 ,"contents": "${1:ofImage}.draw(${2:const ofRectangle &r})"},
        { "trigger": "ofImage::draw \t(ofPoint)"                                     ,"contents": "${1:ofImage}.draw(${2:const ofPoint &p}, ${3:float w}, ${4:float h})"},
        { "trigger": "ofImage::draw \t(xy)"                                          ,"contents": "${1:ofImage}.draw(${2:float x}, ${3:float y})"},
        { "trigger": "ofImage::draw \t(xyz)"                                         ,"contents": "${1:ofImage}.draw(${2:float x}, ${3:float y}, ${4:float z})"},
        { "trigger": "ofImage::draw \t(xywh)"                                        ,"contents": "${1:ofImage}.draw(${2:float x}, ${3:float y}, ${4:float w}, ${5:float h})"},
        { "trigger": "ofImage::draw \t(xyzwh)"                                       ,"contents": "${1:ofImage}.draw(${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h})"},
        { "trigger": "ofImage::draw \t(ofPoint)"                                     ,"contents": "${1:ofImage}.draw(${2:const ofPoint &p})"},
        { "trigger": "ofImage::drawSubsection \t(xywhsxsy)"                          ,"contents": "${1:ofImage}.drawSubsection(${2:float x}, ${3:float y}, ${4:float w}, ${5:float h}, ${6:float sx}, ${7:float sy})"},
        { "trigger": "ofImage::drawSubsection \t(xyzwhsxsy)"                         ,"contents": "${1:ofImage}.drawSubsection(${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h}, ${7:float sx}, ${8:float sy})"},
        { "trigger": "ofImage::drawSubsection \t(xywhsxsyswsh)"                      ,"contents": "${1:ofImage}.drawSubsection(${2:float x}, ${3:float y}, ${4:float w}, ${5:float h}, ${6:float sx}, ${7:float sy}, ${8:float sw}, ${9:float sh})"},
        { "trigger": "ofImage::drawSubsection \t(xyzwhsxsyswsh)"                     ,"contents": "${1:ofImage}.drawSubsection(${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h}, ${7:float sx}, ${8:float sy}, ${9:float sw}, ${10:float sh})"},
        { "trigger": "ofImage::getColor"                                             ,"contents": "${1:ofImage}.getColor(${2:int x}, ${3:int y})"},
        { "trigger": "ofImage::getHeight"                                            ,"contents": "${1:ofImage}.getHeight()"},
        { "trigger": "ofImage::getPixels"                                            ,"contents": "${1:ofImage}.getPixels()"},
        { "trigger": "ofImage::getPixelsRef"                                         ,"contents": "${1:ofImage}.getPixelsRef()"},
        { "trigger": "ofImage::getTextureReference"                                  ,"contents": "${1:ofImage}.getTextureReference()"},
        { "trigger": "ofImage::getWidth"                                             ,"contents": "${1:ofImage}.getWidth()"},
        { "trigger": "ofImage::grabScreen"                                           ,"contents": "${1:ofImage}.grabScreen(${2:int x}, ${3:int y}, ${4:int w}, ${5:int h})"},
        { "trigger": "ofImage::isAllocated"                                          ,"contents": "${1:ofImage}.isAllocated()"},
        { "trigger": "ofImage::isUsingTexture"                                       ,"contents": "${1:ofImage}.isUsingTexture()"},
        { "trigger": "ofImage::loadImage \t(string)"                                 ,"contents": "${1:ofImage}.loadImage(${2:string fileName})"},
        { "trigger": "ofImage::loadImage \t(ofBuffer)"                               ,"contents": "${1:ofImage}.loadImage(${2:const ofBuffer &buffer})"},
        { "trigger": "ofImage::loadImage \t(ofFile)"                                 ,"contents": "${1:ofImage}.loadImage(${2:const ofFile &file})"},
        { "trigger": "ofImage::mirror"                                               ,"contents": "${1:ofImage}.mirror(${2:bool vertical}, ${3:bool horizontal})"},
        { "trigger": "ofImage::reloadTexture"                                        ,"contents": "${1:ofImage}.reloadTexture()"},
        { "trigger": "ofImage::resetAnchor"                                          ,"contents": "${1:ofImage}.resetAnchor()"},
        { "trigger": "ofImage::resize"                                               ,"contents": "${1:ofImage}.resize(${2:int newWidth}, ${3:int newHeight})"},
        { "trigger": "ofImage::rotate90"                                             ,"contents": "${1:ofImage}.rotate90(${2:int rotation})"},
        { "trigger": "ofImage::saveImage \t(string)"                                 ,"contents": "${1:ofImage}.saveImage(${2:string fileName}, ${3:ofImageQualityType compressionLevel=OF_IMAGE_QUALITY_BEST})"},
        { "trigger": "ofImage::saveImage \t(ofBuffer)"                               ,"contents": "${1:ofImage}.saveImage(${2:ofBuffer &buffer}, ${3:ofImageQualityType compressionLevel=OF_IMAGE_QUALITY_BEST})"},
        { "trigger": "ofImage::saveImage \t(ofFile)"                                 ,"contents": "${1:ofImage}.saveImage(${2:const ofFile &file}, ${3:ofImageQualityType compressionLevel=OF_IMAGE_QUALITY_BEST})"},
        { "trigger": "ofImage::setAnchorPercent"                                     ,"contents": "${1:ofImage}.setAnchorPercent(${2:float xPct}, ${3:float yPct})"},
        { "trigger": "ofImage::setAnchorPoint"                                       ,"contents": "${1:ofImage}.setAnchorPoint(${2:float x}, ${3:float y})"},
        { "trigger": "ofImage::setColor"                                             ,"contents": "${1:ofImage}.setColor(${2:int x}, ${3:int y}, ${4:ofColor_< PixelType > color})"},
        { "trigger": "ofImage::setCompression"                                       ,"contents": "${1:ofImage}.setCompression(${2:ofTexCompression compression})"},
        { "trigger": "ofImage::setFromPixels \t(pixels, wh)"                         ,"contents": "${1:ofImage}.setFromPixels(${2:const PixelType *pixels}, ${3:int w}, ${4:int h}, ${5:ofImageType type}, ${6:bool bOrderIsRGB=true})"},
        { "trigger": "ofImage::setFromPixels \t(PixelsType)"                         ,"contents": "${1:ofImage}.setFromPixels(${2:const ofPixels_< PixelType > &pixels})"},
        { "trigger": "ofImage::setImageType"                                         ,"contents": "${1:ofImage}.setImageType(${2:ofImageType type})"},
        { "trigger": "ofImage::setUseTexture"                                        ,"contents": "${1:ofImage}.setUseTexture(${2:bool bUse})"},
        { "trigger": "ofImage::unbind"                                               ,"contents": "${1:ofImage}.unbind()"},
        { "trigger": "ofImage::update"                                               ,"contents": "${1:ofImage}.update()"},
        { "trigger": "ofImage::bpp"                                                  ,"contents": "${1:ofImage}.bpp"},
        { "trigger": "ofImage::height"                                               ,"contents": "${1:ofImage}.height"},
        { "trigger": "ofImage::type"                                                 ,"contents": "${1:ofImage}.type"},
        { "trigger": "ofImage::width"                                                ,"contents": "${1:ofImage}.width"},
        { "trigger": "ofImage::width"                                                ,"contents": "${1:ofImage}.width"},
        { "trigger": "ofLoadImage \t(ofPixels, string)"                              ,"contents": "ofLoadImage(${1:ofPixels &pix}, ${2:string path})"},
        { "trigger": "ofLoadImage \t(ofPixels, ofBuffer)"                            ,"contents": "ofLoadImage(${1:ofPixels &pix}, ${2:const ofBuffer &buffer})"},
        { "trigger": "ofLoadImage \t(ofTexture, string)"                             ,"contents": "ofLoadImage(${1:ofTexture &tex}, ${2:string path})"},
        { "trigger": "ofLoadImage \t(ofTexture, ofBuffer)"                           ,"contents": "ofLoadImage(${1:ofTexture &tex}, ${2:const ofBuffer &buffer})"},
        { "trigger": "ofSaveImage \t(ofPixels, string)"                              ,"contents": "ofSaveImage(${1:ofPixels &pix}, ${2:string path}, ${3:ofImageQualityType qualityLevel=OF_IMAGE_QUALITY_BEST})"},
        { "trigger": "ofSaveImage \t(ofPixels, ofBuffer)"                            ,"contents": "ofSaveImage(${1:ofPixels &pix}, ${2:ofBuffer &buffer}, ${3:ofImageFormat format=OF_IMAGE_FORMAT_PNG}, ${4:ofImageQualityType qualityLevel=OF_IMAGE_QUALITY_BEST})"},

        { "trigger": "OF_IMAGE_COLOR"                                                ,"contents": "OF_IMAGE_COLOR"},
        { "trigger": "OF_IMAGE_COLOR_ALPHA"                                          ,"contents": "OF_IMAGE_COLOR_ALPHA"},
        { "trigger": "OF_IMAGE_GRAYSCALE"                                            ,"contents": "OF_IMAGE_GRAYSCALE"},
        { "trigger": "OF_COLOR_IMAGE"                                                ,"contents": "OF_COLOR_IMAGE"},
        { "trigger": "OF_COMPRESS_NONE"                                              ,"contents": "OF_COMPRESS_NONE"},
        { "trigger": "OF_COMPRESS_SRGB"                                              ,"contents": "OF_COMPRESS_SRGB"},
        { "trigger": "OF_COMPRESS_ARB"                                               ,"contents": "OF_COMPRESS_ARB"},
        { "trigger": "OF_IMAGE_QUALITY_BEST"                                         ,"contents": "OF_IMAGE_QUALITY_BEST"},
        { "trigger": "OF_IMAGE_QUALITY_HIGH"                                         ,"contents": "OF_IMAGE_QUALITY_HIGH"},
        { "trigger": "OF_IMAGE_QUALITY_MEDIUM"                                       ,"contents": "OF_IMAGE_QUALITY_MEDIUM"},
        { "trigger": "OF_IMAGE_QUALITY_LOW"                                          ,"contents": "OF_IMAGE_QUALITY_LOW"},
        { "trigger": "OF_IMAGE_QUALITY_WORST"                                        ,"contents": "OF_IMAGE_QUALITY_WORST"},

        /////////////////////////////////////////////
        // ofPath
        { "trigger": "ofPath::arc \t(ofPoint)"                                       ,"contents": "${1:ofPath}.arc(${2:const ofPoint &centre}, float radiusX}, float radiusY}, float angleBegin}, float angleEnd})"},
        { "trigger": "ofPath::arc \t(xy)"                                            ,"contents": "${1:ofPath}.arc(${2:float x}, float y}, ${3:float radiusX}, ${4:float radiusY}, ${5:float angleBegin}, ${6:float angleEnd})"},
        { "trigger": "ofPath::arc \t(xyz)"                                           ,"contents": "${1:ofPath}.arc(${2:float x}, float y}, ${3:float z}, ${4:float radiusX}, ${5:float radiusY}, ${6:float angleBegin}, ${7:float angleEnd})"},
        { "trigger": "ofPath::arc \t(ofPoint clockwise)"                             ,"contents": "${1:ofPath}.arc(${2:const ofPoint &centre}, ${3:float radiusX}, ${4:float radiusY}, ${5:float angleBegin}, ${6:float angleEnd}, ${7:bool clockwise})"},
        { "trigger": "ofPath::arcNegative \t(ofPoint)"                               ,"contents": "${1:ofPath}.arcNegative(${2:const ofPoint &centre}, ${3:float radiusX}, ${4:float radiusY}, ${5:float angleBegin}, ${6:float angleEnd})"},
        { "trigger": "ofPath::arcNegative \t(xy)"                                    ,"contents": "${1:ofPath}.arcNegative(${2:float x}, ${3:float y}, ${4:float radiusX}, ${5:float radiusY}, ${6:float angleBegin}, ${7:float angleEnd})"},
        { "trigger": "ofPath::arcNegative \t(xyz)"                                   ,"contents": "${1:ofPath}.arcNegative(${2:float x}, ${3:float y}, ${4:float z}, ${5:float radiusX}, ${6:float radiusY}, ${7:float angleBegin}, ${8:float angleEnd})"},
        { "trigger": "ofPath::bezierTo \t(ofPoint)"                                  ,"contents": "${1:ofPath}.bezierTo(${2:const ofPoint &cp1}, ${3:const ofPoint &cp2}, ${4:const ofPoint &p})"},
        { "trigger": "ofPath::bezierTo \t(xy)"                                       ,"contents": "${1:ofPath}.bezierTo(${2:float cx1}, ${3:float cy1}, ${4:float cx2}, ${5:float cy2}, ${6:float x}, ${7:float y})"},
        { "trigger": "ofPath::bezierTo \t(xyz)"                                      ,"contents": "${1:ofPath}.bezierTo(${2:float cx1}, ${3:float cy1}, ${4:float cz1}, ${5:float cx2}, ${6:float cy2}, ${7:float cz2}, ${8:float x}, ${9:float y}, ${10:float z})"},
        { "trigger": "ofPath::clear"                                                 ,"contents": "${1:ofPath}.clear()"},
        { "trigger": "ofPath::close"                                                 ,"contents": "${1:ofPath}.close()"},
        { "trigger": "ofPath::curveTo \t(ofPoint)"                                   ,"contents": "${1:ofPath}.curveTo(${2:const ofPoint &p})"},
        { "trigger": "ofPath::curveTo \t(xy)"                                        ,"contents": "${1:ofPath}.curveTo(${2:float x}, ${3:float y})"},
        { "trigger": "ofPath::curveTo \t(xyz)"                                       ,"contents": "${1:ofPath}.curveTo(${2:float x}, ${3:float y}, ${4:float z})"},
        { "trigger": "ofPath::draw \t(xy)"                                           ,"contents": "${1:ofPath}.draw(${2:float x}, ${3:float y})"},
        { "trigger": "ofPath::draw"                                                  ,"contents": "${1:ofPath}.draw()"},
        { "trigger": "ofPath::flagShapeChanged"                                      ,"contents": "${1:ofPath}.flagShapeChanged()"},
        { "trigger": "ofPath::generatePolylinesFromPaths"                            ,"contents": "${1:ofPath}.generatePolylinesFromPaths()"},
        { "trigger": "ofPath::getArcResolution"                                      ,"contents": "${1:ofPath}.getArcResolution()"},
        { "trigger": "ofPath::getCurveResolution"                                    ,"contents": "${1:ofPath}.getCurveResolution()"},
        { "trigger": "ofPath::getFillColor"                                          ,"contents": "${1:ofPath}.getFillColor()"},
        { "trigger": "ofPath::getOutline"                                            ,"contents": "${1:ofPath}.getOutline()"},
        { "trigger": "ofPath::getStrokeColor"                                        ,"contents": "${1:ofPath}.getStrokeColor()"},
        { "trigger": "ofPath::getStrokeWidth"                                        ,"contents": "${1:ofPath}.getStrokeWidth()"},
        { "trigger": "ofPath::getSubPaths"                                           ,"contents": "${1:ofPath}.getSubPaths()"},
        { "trigger": "ofPath::getTessellation"                                       ,"contents": "${1:ofPath}.getTessellation()"},
        { "trigger": "ofPath::getUseShapeColor"                                      ,"contents": "${1:ofPath}.getUseShapeColor()"},
        { "trigger": "ofPath::getWindingMode"                                        ,"contents": "${1:ofPath}.getWindingMode()"},
        { "trigger": "ofPath::hasOutline"                                            ,"contents": "${1:ofPath}.hasOutline()"},
        { "trigger": "ofPath::isFilled"                                              ,"contents": "${1:ofPath}.isFilled()"},
        { "trigger": "ofPath::lastPath"                                              ,"contents": "${1:ofPath}.lastPath()"},
        { "trigger": "ofPath::lastPolyline"                                          ,"contents": "${1:ofPath}.lastPolyline()"},
        { "trigger": "ofPath::lineTo \t(ofPoint)"                                    ,"contents": "${1:ofPath}.lineTo(${2:const ofPoint &p})"},
        { "trigger": "ofPath::lineTo \t(xy)"                                         ,"contents": "${1:ofPath}.lineTo(${2:float x, ${3:float y})"},
        { "trigger": "ofPath::lineTo \t(xyz)"                                        ,"contents": "${1:ofPath}.lineTo(${2:float x, ${3:float y}, ${4:float z})"},
        { "trigger": "ofPath::moveTo \t(ofPoint)"                                    ,"contents": "${1:ofPath}.moveTo(${2:const ofPoint &p})"},
        { "trigger": "ofPath::moveTo \t(xy[z])"                                      ,"contents": "${1:ofPath}.moveTo(${2:float x, ${3:float y}, ${4:float z=0})"},
        { "trigger": "ofPath::newSubPath"                                            ,"contents": "${1:ofPath}.newSubPath()"},
        { "trigger": "ofPath::ofPath"                                                ,"contents": "${1:ofPath}.ofPath()"},
        { "trigger": "ofPath::quadBezierTo \t(ofPoint)"                              ,"contents": "${1:ofPath}.quadBezierTo(${2:const ofPoint &cp1}, ${3:const ofPoint &cp2}, ${4:const ofPoint &p})"},
        { "trigger": "ofPath::quadBezierTo \t(xy)"                                   ,"contents": "${1:ofPath}.quadBezierTo(${2:float cx1}, ${3:float cy1}, ${4:float cx2}, ${5:float cy2}, ${6:float x}, ${7:float y})"},
        { "trigger": "ofPath::quadBezierTo \t(xyz)"                                  ,"contents": "${1:ofPath}.quadBezierTo(${2:float cx1}, ${3:float cy1}, ${4:float cz1}, ${5:float cx2}, ${6:float cy2}, ${7:float cz2}, ${8:float x}, ${9:float y}, ${10:float z})"},
        { "trigger": "ofPath::rotate"                                                ,"contents": "${1:ofPath}.rotate(${2:float az}, ${3:const ofVec3f &axis})"},
        { "trigger": "ofPath::scale"                                                 ,"contents": "${1:ofPath}.scale(${2:float x}, ${3:float y})"},
        { "trigger": "ofPath::setArcResolution"                                      ,"contents": "${1:ofPath}.setArcResolution(${2:int res})"},
        { "trigger": "ofPath::setColor"                                              ,"contents": "${1:ofPath}.setColor(${2:const ofColor &color})"},
        { "trigger": "ofPath::setCurveResolution"                                    ,"contents": "${1:ofPath}.setCurveResolution(${2:int curveResolution})"},
        { "trigger": "ofPath::setFillColor"                                          ,"contents": "${1:ofPath}.setFillColor(${2:const ofColor &color})"},
        { "trigger": "ofPath::setFillHexColor"                                       ,"contents": "${1:ofPath}.setFillHexColor(${2:int hex})"},
        { "trigger": "ofPath::setFilled"                                             ,"contents": "${1:ofPath}.setFilled(${2:bool hasFill})"},
        { "trigger": "ofPath::setHexColor"                                           ,"contents": "${1:ofPath}.setHexColor(${2:int hex})"},
        { "trigger": "ofPath::setMode"                                               ,"contents": "${1:ofPath}.setMode(${2:Mode mode})"},
        { "trigger": "ofPath::setPolyWindingMode"                                    ,"contents": "${1:ofPath}.setPolyWindingMode(${2:ofPolyWindingMode mode})"},
        { "trigger": "ofPath::setStrokeColor"                                        ,"contents": "${1:ofPath}.setStrokeColor(${2:const ofColor &color})"},
        { "trigger": "ofPath::setStrokeHexColor"                                     ,"contents": "${1:ofPath}.setStrokeHexColor(${2:int hex})"},
        { "trigger": "ofPath::setStrokeWidth"                                        ,"contents": "${1:ofPath}.setStrokeWidth(${2:float width})"},
        { "trigger": "ofPath::setUseShapeColor"                                      ,"contents": "${1:ofPath}.setUseShapeColor(${2:bool useColor})"},
        { "trigger": "ofPath::simplify"                                              ,"contents": "${1:ofPath}.simplify(${2:float tolerance=0.3})"},
        { "trigger": "ofPath::tessellate"                                            ,"contents": "${1:ofPath}.tessellate()"},
        { "trigger": "ofPath::translate"                                             ,"contents": "${1:ofPath}.translate(${2:const ofPoint &p})"},
        ///////////////////////////
        // int polyMode
        { "trigger": "OF_POLY_WINDING_ODD \tpolyMode"               ,"contents": "OF_POLY_WINDING_ODD"},
        { "trigger": "OF_POLY_WINDING_NONZERO \tpolyMode"           ,"contents": "OF_POLY_WINDING_NONZERO"},
        { "trigger": "OF_POLY_WINDING_POSITIVE \tpolyMode"          ,"contents": "OF_POLY_WINDING_POSITIVE"},
        { "trigger": "OF_POLY_WINDING_NEGATIVE \tpolyMode"          ,"contents": "OF_POLY_WINDING_NEGATIVE"},
        { "trigger": "OF_POLY_WINDING_ABS_GEQ_TWO \tpolyMode"       ,"contents": "OF_POLY_WINDING_ABS_GEQ_TWO"},
        ///////////////////////////
        // ofPolyline
        { "trigger:": "ofPolyline::addVertex \t(const ofPoint)"                                                             ,"contents": "${1:ofPolyline}.addVertex(${2:const ofPoint &p})"},
        { "trigger:": "ofPolyline::addVertex \t(float, float, float)"                                                       ,"contents": "${1:ofPolyline}.addVertex(${2:float x}, ${3:float y}, ${4:float z=0})"},
        { "trigger:": "ofPolyline::addVertexes \t(const vector< ofPoint >)"                                                 ,"contents": "${1:ofPolyline}.addVertexes(${2:const vector< ofPoint > &verts})"},
        { "trigger:": "ofPolyline::addVertexes \t(const ofPoint, int)"                                                      ,"contents": "${1:ofPolyline}.addVertexes(${2:const ofPoint *verts}, ${3:int numverts})"},
        { "trigger:": "ofPolyline::addVertices \t(const vector< ofPoint >)"                                                 ,"contents": "${1:ofPolyline}.addVertices(${2:const vector< ofPoint > &verts})"},
        { "trigger:": "ofPolyline::addVertices \t(const ofPoint, int)"                                                      ,"contents": "${1:ofPolyline}.addVertices(${2:const ofPoint *verts}, ${3:int numverts})"},
        { "trigger:": "ofPolyline::arc \t(const ofPoint, float, float, float, float, int)"                                  ,"contents": "${1:ofPolyline}.arc(${2:const ofPoint &center}, ${3:float radiusX}, ${4:float radiusY}, ${5:float angleBegin}, ${6:float angleEnd}, ${7:int curveResolution=20})"},
        { "trigger:": "ofPolyline::arc \t(float, float, float, float, float, float, int)"                                   ,"contents": "${1:ofPolyline}.arc(${2:float x}, ${3:float y}, ${4:float radiusX}, ${5:float radiusY}, ${6:float angleBegin}, ${7:float angleEnd}, ${8:int curveResolution=20})"},
        { "trigger:": "ofPolyline::arc \t(float, float, float, float, float, float, float, int)"                            ,"contents": "${1:ofPolyline}.arc(${2:float x}, ${3:float y}, ${4:float z}, ${5:float radiusX}, ${6:float radiusY}, ${7:float angleBegin}, ${8:float angleEnd}, ${9:int curveResolution=20})"},
        { "trigger:": "ofPolyline::arc \t(const ofPoint, float, float, float, float, bool, int)"                            ,"contents": "${1:ofPolyline}.arc(${2:const ofPoint &center}, ${3:float radiusX}, ${4:float radiusY}, ${5:float angleBegin}, ${6:float angleEnd}, ${7:bool clockwise}, $:{8int curveResolution=20})"},
        { "trigger:": "ofPolyline::arcNegative \t(const ofPoint, float, float, float, float, int)"                          ,"contents": "${1:ofPolyline}.arcNegative(${2:const ofPoint &center}, ${3:float radiusX}, ${4:float radiusY}, ${5:float angleBegin}, ${6:float angleEnd}, ${7:int curveResolution=20})"},
        { "trigger:": "ofPolyline::arcNegative \t(float, float, float, float, float, float, int)"                           ,"contents": "${1:ofPolyline}.arcNegative(${2:float x}, ${3:float y}, ${4:float radiusX}, ${5:float radiusY}, ${6:float angleBegin}, ${7:float angleEnd}, ${8:int curveResolution=20})"},
        { "trigger:": "ofPolyline::arcNegative \t(float, float, float, float, float, float, float, int)"                    ,"contents": "${1:ofPolyline}.arcNegative(${2:float x}, ${3:float y}, ${4:float z}, ${5:float radiusX}, ${6:float radiusY}, ${7:float angleBegin}, ${8:float angleEnd}, ${9:int curveResolution=20})"},
        { "trigger:": "ofPolyline::bezierTo \t(const ofPoint, const ofPoint, const ofPoint, int)"                           ,"contents": "${1:ofPolyline}.bezierTo(${2:const ofPoint &cp1}, ${3:const ofPoint &cp2}, ${4:const ofPoint &to}, ${5:int curveResolution=16})"},
        { "trigger:": "ofPolyline::bezierTo \t(float, float, float, float, float, float, int)"                              ,"contents": "${1:ofPolyline}.bezierTo(${2:float cx1}, ${3:float cy1}, ${4:float cx2}, ${5:float cy2}, ${6:float x}, ${7:float y}, ${8:int curveResolution=16})"},
        { "trigger:": "ofPolyline::bezierTo \t(float, float, float, float, float, float, float, float, float, int)"         ,"contents": "${1:ofPolyline}.bezierTo(${2:float cx1}, ${3:float cy1}, ${4:float cz1}, ${5:float cx2}, ${6:float cy2}, ${7:float cz2}, ${8:float x}, ${9:float y}, ${:10float z}, ${:11int curveResolution=16})"},
        { "trigger:": "ofPolyline::clear"                                                                                   ,"contents": "${1:ofPolyline}.clear()"},
        { "trigger:": "ofPolyline::close"                                                                                   ,"contents": "${1:ofPolyline}.close()"},
        { "trigger:": "ofPolyline::curveTo \t(const ofPoint, int)"                                                          ,"contents": "${1:ofPolyline}.curveTo(${2:const ofPoint &to}, ${3:int curveResolution=16})"},
        { "trigger:": "ofPolyline::curveTo \t(float, float, float, int)"                                                    ,"contents": "${1:ofPolyline}.curveTo(${2:float x}, ${3:float y}, ${4:float z=0}, ${5:int curveResolution=16})"},
        { "trigger:": "ofPolyline::draw"                                                                                    ,"contents": "${1:ofPolyline}.draw()"},
        { "trigger:": "ofPolyline::fromRectangle \t(const ofRectangle)"                                                     ,"contents": "${1:ofPolyline}.fromRectangle(${2:const ofRectangle &rect})"},
        { "trigger:": "ofPolyline::getArea"                                                                                 ,"contents": "${1:ofPolyline}.getArea()"},
        { "trigger:": "ofPolyline::getBoundingBox"                                                                          ,"contents": "${1:ofPolyline}.getBoundingBox()"},
        { "trigger:": "ofPolyline::getCentroid2D"                                                                           ,"contents": "${1:ofPolyline}.getCentroid2D()"},
        { "trigger:": "ofPolyline::getClosestPoint \t(const ofPoint, unsigned int)"                                         ,"contents": "${1:ofPolyline}.getClosestPoint(${2:const ofPoint &target}, ${3:unsigned int *nearestIndex=NULL})"},
        { "trigger:": "ofPolyline::getPerimeter"                                                                            ,"contents": "${1:ofPolyline}.getPerimeter()"},
        { "trigger:": "ofPolyline::getResampledByCount \t(int)"                                                             ,"contents": "${1:ofPolyline}.getResampledByCount(${2:int count})"},
        { "trigger:": "ofPolyline::getResampledBySpacing \t(float)"                                                         ,"contents": "${1:ofPolyline}.getResampledBySpacing(${2:float spacing})"},
        { "trigger:": "ofPolyline::getSmoothed \t(int, float)"                                                              ,"contents": "${1:ofPolyline}.getSmoothed(${2:int smoothingSize}, ${3:float smoothingShape=0})"},
        { "trigger:": "ofPolyline::getVertices"                                                                             ,"contents": "${1:ofPolyline}.getVertices()"},
        { "trigger:": "ofPolyline::hasChanged"                                                                              ,"contents": "${1:ofPolyline}.hasChanged()"},
        { "trigger:": "ofPolyline::inside \t(float, float)"                                                                 ,"contents": "${1:ofPolyline}.inside(${2:float x}, ${3:float y})"},
        { "trigger:": "ofPolyline::inside \t(const ofPoint)"                                                                ,"contents": "${1:ofPolyline}.inside(${2:const ofPoint &p})"},
        { "trigger:": "ofPolyline::inside \t(float, float, const ofPolyline)"                                               ,"contents": "${1:ofPolyline}.inside(${2:float x}, ${3:float y}, ${4:const ofPolyline &polyline})"},
        { "trigger:": "ofPolyline::inside \t(const ofPoint, const ofPolyline)"                                              ,"contents": "${1:ofPolyline}.inside(${2:const ofPoint &p}, ${3:const ofPolyline &polyline})"},
        { "trigger:": "ofPolyline::isClosed"                                                                                ,"contents": "${1:ofPolyline}.isClosed()"},
        { "trigger:": "ofPolyline::lineTo \t(const ofPoint)"                                                                ,"contents": "${1:ofPolyline}.lineTo(${2:const ofPoint &to})"},
        { "trigger:": "ofPolyline::lineTo \t(float, float, float)"                                                          ,"contents": "${1:ofPolyline}.lineTo(${2:float x}, ${3:float y}, ${4:float z=0})"},
        { "trigger:": "ofPolyline::quadBezierTo \t(float, float, float, float, float, float, float, float, float, int)"     ,"contents": "${1:ofPolyline}.quadBezierTo(${2:float cx1}, ${3:float cy1}, ${4:float cz1}, ${5:float cx2}, ${6:float cy2}, ${7:float cz2}, ${8:float x}, ${9:float y}, ${10:float z}, ${11:int curveResolution=16})"},
        { "trigger:": "ofPolyline::quadBezierTo \t(const ofPoint, const ofPoint, const ofPoint, int)"                       ,"contents": "${1:ofPolyline}.quadBezierTo(${2:const ofPoint &p1}, ${3:const ofPoint &p2}, ${4:const ofPoint &p3}, ${5:int curveResolution=16})"},
        { "trigger:": "ofPolyline::quadBezierTo \t(float, float, float, float, float, float, int)"                          ,"contents": "${1:ofPolyline}.quadBezierTo(${2:float cx1}, ${3:float cy1}, ${4:float cx2}, ${5:float cy2}, ${6:float x}, ${7:float y}, ${8:int curveResolution=16})"},
        { "trigger:": "ofPolyline::resize \t(size_t)"                                                                       ,"contents": "${1:ofPolyline}.resize(${2:size_t size})"},
        { "trigger:": "ofPolyline::setClosed \t(bool)"                                                                      ,"contents": "${1:ofPolyline}.setClosed(${2:bool tf})"},
        { "trigger:": "ofPolyline::simplify \t(float)"                                                                      ,"contents": "${1:ofPolyline}.simplify(${2:float tolerance=0.3})"},
        { "trigger:": "ofPolyline::size"                                                                                    ,"contents": "${1:ofPolyline}.size()"},

        ///////////////////////////////////////////
        // ofPixels
        { "trigger": "ofPixels::allocate \t(channel)"                                ,"contents": "${1:ofPixels}.allocate(${2:int w}, ${3:int h}, ${4:int channels})"},
        { "trigger": "ofPixels::allocate \t(ofPixelFormat)"                          ,"contents": "${1:ofPixels}.allocate(${2:int w}, ${3:int h}, ${4:ofPixelFormat type})"},
        { "trigger": "ofPixels::allocate \t(ofImageType)"                            ,"contents": "${1:ofPixels}.allocate(${2:int w}, ${3:int h}, ${4:ofImageType type})"},
        { "trigger": "ofPixels::bicubicInterpolate"                                  ,"contents": "${1:ofPixels}.bicubicInterpolate(${2:const float *patch}, ${3:float x}, ${4:float y}, ${5:float x2}, ${6:float y2}, ${7:float x3}, ${8:float y3})"},
        { "trigger": "ofPixels::clear"                                               ,"contents": "${1:ofPixels}.clear()"},
        { "trigger": "ofPixels::copyFrom \t(PixelType)"                              ,"contents": "${1:ofPixels}.copyFrom(${2:const ofPixels_< PixelType > &mom})"},
        { "trigger": "ofPixels::copyFrom \t(SrcType)"                                ,"contents": "${1:ofPixels}.copyFrom(${2:const ofPixels_< SrcType > &mom})"},
        { "trigger": "ofPixels::crop"                                                ,"contents": "${1:ofPixels}.crop(${2:int x}, ${2:int y}, ${3:int width}, ${4:int height})"},
        { "trigger": "ofPixels::cropTo"                                              ,"contents": "${1:ofPixels}.cropTo(${2:ofPixels_< PixelType > &toPix}, ${3:int x}, ${4:int y}, ${5:int _width}, ${6:int _height})"},
        { "trigger": "ofPixels::getBitsPerChannel"                                   ,"contents": "${1:ofPixels}.getBitsPerChannel()"},
        { "trigger": "ofPixels::getBitsPerPixel"                                     ,"contents": "${1:ofPixels}.getBitsPerPixel()"},
        { "trigger": "ofPixels::getBytesPerChannel"                                  ,"contents": "${1:ofPixels}.getBytesPerChannel()"},
        { "trigger": "ofPixels::getBytesPerPixel"                                    ,"contents": "${1:ofPixels}.getBytesPerPixel()"},
        { "trigger": "ofPixels::getChannel"                                          ,"contents": "${1:ofPixels}.getChannel(${2:int channel)"},
        { "trigger": "ofPixels::getColor"                                            ,"contents": "${1:ofPixels}.getColor(${2:int x}, ${3:int y})"},
        { "trigger": "ofPixels::getHeight"                                           ,"contents": "${1:ofPixels}.getHeight()"},
        { "trigger": "ofPixels::getImageType"                                        ,"contents": "${1:ofPixels}.getImageType()"},
        { "trigger": "ofPixels::getNumChannels"                                      ,"contents": "${1:ofPixels}.getNumChannels()"},
        { "trigger": "ofPixels::getPixelIndex"                                       ,"contents": "${1:ofPixels}.getPixelIndex(${2:int x}, ${3:int y})"},
        { "trigger": "ofPixels::getPixels"                                           ,"contents": "${1:ofPixels}.getPixels()"},
        { "trigger": "ofPixels::getWidth"                                            ,"contents": "${1:ofPixels}.getWidth()"},
        { "trigger": "ofPixels::isAllocated"                                         ,"contents": "${1:ofPixels}.isAllocated()"},
        { "trigger": "ofPixels::mirror"                                              ,"contents": "${1:ofPixels}.mirror(${2:bool vertically}, ${3:bool horizontal})"},
        { "trigger": "ofPixels::mirrorTo"                                            ,"contents": "${1:ofPixels}.mirrorTo(${2:ofPixels_< PixelType > &dst, bool vertically}, ${3:bool horizontal})"},
        { "trigger": "ofPixels::ofPixels"                                            ,"contents": "${1:ofPixels}.ofPixels()"},
        { "trigger": "ofPixels::ofPixels \t(PixelType)"                              ,"contents": "${1:ofPixels}.ofPixels(${2:const ofPixels_< PixelType > &mom})"},
        { "trigger": "ofPixels::ofPixels \t(SrcType)"                                ,"contents": "${1:ofPixels}.ofPixels(${2:const ofPixels_< SrcType > &mom})"},
        { "trigger": "ofPixels::operator \t(PixelType)"                              ,"contents": "${1:ofPixels}.operator(${2:const ofPixels_< PixelType > &mom})"},
        { "trigger": "ofPixels::operator \t(SrcType)"                                ,"contents": "${1:ofPixels}.operator(${2:const ofPixels_< SrcType > &mom})"},
        { "trigger": "ofPixels::operator"                                            ,"contents": "${1:ofPixels}.operator(${2:int pos})"},
        { "trigger": "ofPixels::pasteInto"                                           ,"contents": "${1:ofPixels}.pasteInto(${2:ofPixels_< PixelType > &dst}, ${3:int x}, ${4:int y})"},
        { "trigger": "ofPixels::resize"                                              ,"contents": "${1:ofPixels}.resize(${2:int dstWidth}, ${3:int dstHeight}, ${4:ofInterpolationMethod interpMethod=OF_INTERPOLATE_NEAREST_NEIGHBOR})"},
        { "trigger": "ofPixels::resizeTo"                                            ,"contents": "${1:ofPixels}.resizeTo(${2:ofPixels_< PixelType > &dst}, ${4:ofInterpolationMethod interpMethod=OF_INTERPOLATE_NEAREST_NEIGHBOR})"},
        { "trigger": "ofPixels::rotate"                                              ,"contents": "${1:ofPixels}.rotate(${2:int nClockwiseRotations})"},
        { "trigger": "ofPixels::rotate \t(PixelType)"                                ,"contents": "${1:ofPixels}.rotate(${2:ofPixels_< PixelType > &dst}, ${3:int nClockwiseRotations})"},
        { "trigger": "ofPixels::set \t(PixelType)"                                   ,"contents": "${1:ofPixels}.set(${2:PixelType val})"},
        { "trigger": "ofPixels::set \t(channel)"                                     ,"contents": "${1:ofPixels}.set(${2:int channel, PixelType val})"},
        { "trigger": "ofPixels::setChannel"                                          ,"contents": "${1:ofPixels}.setChannel(${2:int channel, ${3:const ofPixels_< PixelType > channelPixels})"},
        { "trigger": "ofPixels::setColor"                                            ,"contents": "${1:ofPixels}.setColor(${2:int x, ${3:int y}, ${4:ofColor_< PixelType > color})"},
        { "trigger": "ofPixels::setFromAlignedPixels"                                ,"contents": "${1:ofPixels}.setFromAlignedPixels(${2:const PixelType *newPixels}, ${3:int width}, ${4:int height}, ${5:int channels}, ${6:int stride})"},
        { "trigger": "ofPixels::setFromExternalPixels"                               ,"contents": "${1:ofPixels}.setFromExternalPixels(${2:PixelType *newPixels}, ${3:int w}, ${4:int h}, ${5:int channels})"},
        { "trigger": "ofPixels::setFromPixels \t(PixelType)"                         ,"contents": "${1:ofPixels}.setFromPixels(${2:const PixelType *newPixels}, ${3:int w}, ${4:int h}, ${5:int channels})"},
        { "trigger": "ofPixels::setFromPixels \t(ofImageType)"                       ,"contents": "${1:ofPixels}.setFromPixels(${2:const PixelType *newPixels}, ${3:int w}, ${4:int h}, ${5:ofImageType type})"},
        { "trigger": "ofPixels::setImageType"                                        ,"contents": "${1:ofPixels}.setImageType(${2:ofImageType imageType})"},
        { "trigger": "ofPixels::setNumChannels"                                      ,"contents": "${1:ofPixels}.setNumChannels(${2:int numChannels})"},
        { "trigger": "ofPixels::size"                                                ,"contents": "${1:ofPixels}.size()"},
        { "trigger": "ofPixels::swap"                                                ,"contents": "${1:ofPixels}.swap(${2:ofPixels_< PixelType > &pix})"},
        { "trigger": "ofPixels::swapRgb"                                             ,"contents": "${1:ofPixels}.swapRgb(})"},
        //////////////////////////////////////////////
        // ofPolyUtils
        { "trigger": "ofGetBoundingBox \t(const ofPolyline)"                                                ,"contents": "ofGetBoundingBox(${1:const ofPolyline &polyline})"},
        { "trigger": "ofGetClosestPoint \t(const ofPoint, const ofPoint, const ofPoint, float)"             ,"contents": "ofGetClosestPoint(${1:const ofPoint &p1}, ${2:const ofPoint &p2}, ${3:const ofPoint &p3}, ${4:float *normalizedPosition=NULL})"},
        { "trigger": "ofGetResampledCount \t(const ofPolyline, int)"                                        ,"contents": "ofGetResampledCount(${1:const ofPolyline &polyline}, ${2:int count})"},
        { "trigger": "ofGetResampledSpacing \t(const ofPolyline, float)"                                    ,"contents": "ofGetResampledSpacing(${1:const ofPolyline &polyline}, ${2:float spacing})"},
        { "trigger": "ofGetSmoothed \t(const ofPolyline, int, float)"                                       ,"contents": "ofGetSmoothed(${1:const ofPolyline &polyline}, ${2:int smoothingSize}, ${3:float smoothingShape=0})"},
        ///////////////////////////
        // ofTessellator
        { "trigger": "ofTessellator::tessellateToMesh \t(const vector< ofPolyline >, ofPolyWindingMode, ofMesh, bool)"                          ,"contents": "${1:ofTessellator}.tessellateToMesh(${2:const vector< ofPolyline > &src}, ${3:ofPolyWindingMode polyWindingMode}, ${4:ofMesh &dstmesh}, ${5:bool bIs2D=false})"},
        { "trigger": "ofTessellator::tessellateToMesh \t(const ofPolyline, ofPolyWindingMode, ofMesh, bool)"                                    ,"contents": "${1:ofTessellator}.tessellateToMesh(${2:const ofPolyline &src}, ${3:ofPolyWindingMode polyWindingMode}, ${4:ofMesh &dstmesh}, ${5:bool bIs2D=false})"},
        { "trigger": "ofTessellator::tessellateToPolylines \t(const vector< ofPolyline >, ofPolyWindingMode, vector< ofPolyline >, bool)"       ,"contents": "${1:ofTessellator}.tessellateToPolylines(${2:const vector< ofPolyline > &src}, ${3:ofPolyWindingMode polyWindingMode}, ${4:vector< ofPolyline > &dstpoly}, ${5:bool bIs2D=false})"},
        { "trigger": "ofTessellator::tessellateToPolylines \t(const ofPolyline, ofPolyWindingMode, vector< ofPolyline >, bool)"                 ,"contents": "${1:ofTessellator}.tessellateToPolylines(${2:const ofPolyline &src}, ${3:ofPolyWindingMode polyWindingMode}, ${4:vector< ofPolyline > &dstpoly}, ${5:bool bIs2D=false})"},
        ///////////////////////////
        // ofTrueTypeFont
        { "trigger": "ofTrueTypeFont::drawString \t(string, float, float)"                          ,"contents": "${1:ofTrueTypeFont}.drawString(${2:string s}, ${3:float x}, ${4:float y})"},
        { "trigger": "ofTrueTypeFont::drawStringAsShapes \t(string, float, float)"                  ,"contents": "${1:ofTrueTypeFont}.drawStringAsShapes(${2:string s}, ${3:float x}, ${4:float y})"},
        { "trigger": "ofTrueTypeFont::getLetterSpacing"                                             ,"contents": "${1:ofTrueTypeFont}.getLetterSpacing()"},
        { "trigger": "ofTrueTypeFont::getLineHeight"                                                ,"contents": "${1:ofTrueTypeFont}.getLineHeight()"},
        { "trigger": "ofTrueTypeFont::getNumCharacters"                                             ,"contents": "${1:ofTrueTypeFont}.getNumCharacters()"},
        { "trigger": "ofTrueTypeFont::getSize"                                                      ,"contents": "${1:ofTrueTypeFont}.getSize()"},
        { "trigger": "ofTrueTypeFont::getSpaceSize"                                                 ,"contents": "${1:ofTrueTypeFont}.getSpaceSize()"},
        { "trigger": "ofTrueTypeFont::getStringAsPoints \t(string)"                                 ,"contents": "${1:ofTrueTypeFont}.getStringAsPoints(${2:string str})"},
        { "trigger": "ofTrueTypeFont::getStringBoundingBox \t(string, float, float)"                ,"contents": "${1:ofTrueTypeFont}.getStringBoundingBox(${2:string s}, ${3:float x}, ${4:float y})"},
        { "trigger": "ofTrueTypeFont::hasFullCharacterSet"                                          ,"contents": "${1:ofTrueTypeFont}.hasFullCharacterSet()"},
        { "trigger": "ofTrueTypeFont::isAntiAliased"                                                ,"contents": "${1:ofTrueTypeFont}.isAntiAliased()"},
        { "trigger": "ofTrueTypeFont::isLoaded"                                                     ,"contents": "${1:ofTrueTypeFont}.isLoaded()"},
        { "trigger": "ofTrueTypeFont::loadFont \t(string, int)"                                     ,"contents": "${1:ofTrueTypeFont}.loadFont(${2:string filename}, ${3:int fontsize})"},
        { "trigger": "ofTrueTypeFont::loadFont \t(string, int, bool, bool, bool)"                   ,"contents": "${1:ofTrueTypeFont}.loadFont(${2:string filename}, ${3:int fontsize}, ${4:bool _bAntiAliased}, ${5:bool _bFullCharacterSet}, ${6:bool makeContours})"},
        { "trigger": "ofTrueTypeFont::loadFont \t(string, int, bool, bool, bool, float, int)"       ,"contents": "${1:ofTrueTypeFont}.loadFont(${2:string filename}, ${3:int fontsize}, ${4:bool _bAntiAliased=true}, ${5:bool _bFullCharacterSet=false}, ${6:bool makeContours=false}, ${7:float simplifyAmt=0.3}, ${8:int dpi=0})"},
        { "trigger": "ofTrueTypeFont::setGlobalDpi \t(int)"                                         ,"contents": "${1:ofTrueTypeFont}.setGlobalDpi(${2:int newDpi})"},
        { "trigger": "ofTrueTypeFont::setLetterSpacing \t(float)"                                   ,"contents": "${1:ofTrueTypeFont}.setLetterSpacing(${2:float spacing})"},
        { "trigger": "ofTrueTypeFont::setLineHeight \t(float)"                                      ,"contents": "${1:ofTrueTypeFont}.setLineHeight(${2:float height})"},
        { "trigger": "ofTrueTypeFont::setSpaceSize \t(float)"                                       ,"contents": "${1:ofTrueTypeFont}.setSpaceSize(${2:float size})"},
        { "trigger": "ofTrueTypeFont::stringHeight \t(string)"                                      ,"contents": "${1:ofTrueTypeFont}.stringHeight(${2:string s})"},
        { "trigger": "ofTrueTypeFont::stringWidth \t(string)"                                       ,"contents": "${1:ofTrueTypeFont}.stringWidth(${2:string s})"},
        { "trigger": "ofTrueTypeFont::unbind"                                                       ,"contents": "${1:ofTrueTypeFont}.unbind()"},
        { "trigger": "ofTrueTypeFont::bAntiAlised"                                                  ,"contents": "${1:ofTrueTypeFont}.bAntiAlised"},
        { "trigger": "ofTrueTypeFont::bFullCharacterSet"                                            ,"contents": "${1:ofTrueTypeFont}.bFullCharacterSet"},
        { "trigger": "ofTrueTypeFont::bLoadedOk"                                                    ,"contents": "${1:ofTrueTypeFont}.bLoadedOk"},
        { "trigger": "ofTrueTypeFont::nCharacters"                                                  ,"contents": "${1:ofTrueTypeFont}.nCharacters"},




        ////////////////////// 3D /////////////////////
        ///////////////////////////////////////////
        // ofCamera
        { "trigger": "ofCamera::begin \t(ofRectangle)"                               ,"contents": "${1:ofCamera}.begin(${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::cacheMatrices \t(bool)"                              ,"contents": "${1:ofCamera}.cacheMatrices(${2:bool cache=true})"},
        { "trigger": "ofCamera::cameraToWorld \t(ofVec3f, ofRectangle)"              ,"contents": "${1:ofCamera}.cameraToWorld(${2:ofVec3f CameraXYZ}, ${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::disableOrtho"                                        ,"contents": "${1:ofCamera}.disableOrtho()"},
        { "trigger": "ofCamera::enableOrtho"                                         ,"contents": "${1:ofCamera}.enableOrtho()"},
        { "trigger": "ofCamera::end"                                                 ,"contents": "${1:ofCamera}.end()"},
        { "trigger": "ofCamera::getFarClip"                                          ,"contents": "${1:ofCamera}.getFarClip()"},
        { "trigger": "ofCamera::getImagePlaneDistance \t(ofRectangle)"               ,"contents": "${1:ofCamera}.getImagePlaneDistance(${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::getModelViewMatrix"                                  ,"contents": "${1:ofCamera}.getModelViewMatrix()"},
        { "trigger": "ofCamera::getModelViewProjectionMatrix \t(ofRectangle)"        ,"contents": "${1:ofCamera}.getModelViewProjectionMatrix(${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::getNearClip"                                         ,"contents": "${1:ofCamera}.getNearClip()"},
        { "trigger": "ofCamera::getOrtho"                                            ,"contents": "${1:ofCamera}.getOrtho()"},
        { "trigger": "ofCamera::getProjectionMatrix"                                 ,"contents": "${1:ofCamera}.getProjectionMatrix(${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::screenToWorld \t(ofVec3f, ofRectangle)"              ,"contents": "${1:ofCamera}.screenToWorld(${2:ofVec3f ScreenXYZ, ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::setFarClip \t(float)"                                ,"contents": "${1:ofCamera}.setFarClip(${2:float f})"},
        { "trigger": "ofCamera::setFov \t(float)"                                    ,"contents": "${1:ofCamera}.setFov(${2:float f})"},
        { "trigger": "ofCamera::setNearClip \t(float)"                               ,"contents": "${1:ofCamera}.setNearClip(${2:float f})"},
        { "trigger": "ofCamera::setupPerspective"                                    ,"contents": "${1:ofCamera}.setupPerspective(${2:bool vFlip=true}, ${3:float fov=60}, ${4:float nearDist=0}, ${5:float farDist=0})"},
        { "trigger": "ofCamera::worldToCamera \t(ofVec3f, ofRectangle)"              ,"contents": "${1:ofCamera}.worldToCamera(${2:ofVec3f WorldXYZ}, ${3:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::worldToScreen"                                       ,"contents": "${1:ofCamera}.worldToScreen(${2:ofVec3f WorldXYZ}, ${3:ofRectangle viewport=ofGetCurrentViewport()})"},
        ////////////////////////////////////
        // ofEasyCam
        { "trigger": "ofEasyCam::begin \t(ofRectangle)"                              ,"contents": "${1:ofEasyCAm}.begin(${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofEasyCam::disableMouseInput"                                  ,"contents": "${1:ofEasyCAm}.disableMouseInput()"},
        { "trigger": "ofEasyCam::disableMouseMiddleButton"                           ,"contents": "${1:ofEasyCAm}.disableMouseMiddleButton()"},
        { "trigger": "ofEasyCam::enableMouseInput"                                   ,"contents": "${1:ofEasyCAm}.enableMouseInput()"},
        { "trigger": "ofEasyCam::enableMouseMiddleButton"                            ,"contents": "${1:ofEasyCAm}.enableMouseMiddleButton()"},
        { "trigger": "ofEasyCam::getDistance"                                        ,"contents": "${1:ofEasyCAm}.getDistance()"},
        { "trigger": "ofEasyCam::getDrag"                                            ,"contents": "${1:ofEasyCAm}.getDrag()"},
        { "trigger": "ofEasyCam::getMouseInputEnabled"                               ,"contents": "${1:ofEasyCAm}.getMouseInputEnabled()"},
        { "trigger": "ofEasyCam::getMouseMiddleButtonEnabled"                        ,"contents": "${1:ofEasyCAm}.getMouseMiddleButtonEnabled()"},
        { "trigger": "ofEasyCam::getTarget"                                          ,"contents": "${1:ofEasyCAm}.getTarget()"},
        { "trigger": "ofEasyCam::getTranslationKey"                                  ,"contents": "${1:ofEasyCAm}.getTranslationKey()"},
        { "trigger": "ofEasyCam::mouseDragged \t(ofMouseEventArgs)"                  ,"contents": "${1:ofEasyCAm}.mouseDragged(${2:ofMouseEventArgs &mouse})"},
        { "trigger": "ofEasyCam::mouseMoved \t(ofMouseEventArgs)"                    ,"contents": "${1:ofEasyCAm}.mouseMoved(${2:ofMouseEventArgs &mouse})"},
        { "trigger": "ofEasyCam::mousePressed \t(ofMouseEventArgs)"                  ,"contents": "${1:ofEasyCAm}.mousePressed(${2:ofMouseEventArgs &mouse})"},
        { "trigger": "ofEasyCam::mouseReleased \t(ofMouseEventArgs)"                 ,"contents": "${1:ofEasyCAm}.mouseReleased(${2:ofMouseEventArgs &mouse})"},
        { "trigger": "ofEasyCam::reset"                                              ,"contents": "${1:ofEasyCAm}.reset()"},
        { "trigger": "ofEasyCam::setDistance \t(float)"                              ,"contents": "${1:ofEasyCAm}.setDistance(${2:float distance})"},
        { "trigger": "ofEasyCam::setDrag \t(float)"                                  ,"contents": "${1:ofEasyCAm}.setDrag(${2:float drag})"},
        { "trigger": "ofEasyCam::setTarget \t(const ofVec3f)"                        ,"contents": "${1:ofEasyCAm}.setTarget(${2:const ofVec3f &target})"},
        { "trigger": "ofEasyCam::setTarget \t(ofNode)"                               ,"contents": "${1:ofEasyCAm}.setTarget(${2:ofNode &target})"},
        { "trigger": "ofEasyCam::setTranslationKey \t(char)"                         ,"contents": "${1:ofEasyCAm}.setTranslationKey(${2:char key})"},
        /////////////////////////////////
        // ofMesh Primitives Modes
        { "trigger": "OF_PRIMITIVE_TRIANGLES"                                        ,"contents": "OF_PRIMITIVE_TRIANGLES"},
        { "trigger": "OF_PRIMITIVE_TRIANGLE_STRIP"                                   ,"contents": "OF_PRIMITIVE_TRIANGLE_STRIP"},
        { "trigger": "OF_PRIMITIVE_TRIANGLE_FAN"                                     ,"contents": "OF_PRIMITIVE_TRIANGLE_FAN"},
        { "trigger": "OF_PRIMITIVE_LINES"                                            ,"contents": "OF_PRIMITIVE_LINES"},
        { "trigger": "OF_PRIMITIVE_LINE_STRIP"                                       ,"contents": "OF_PRIMITIVE_LINE_STRIP"},
        { "trigger": "OF_PRIMITIVE_LINE_LOOP"                                        ,"contents": "OF_PRIMITIVE_LINE_LOOP"},
        { "trigger": "OF_PRIMITIVE_POINTS"                                           ,"contents": "OF_PRIMITIVE_POINTS"},
        /////////////////////////////////
        // ofMesh
        { "trigger": "ofMesh::addColor \t(const ofFloatColor)"                                  ,"contents": "${1:ofMesh}.addColor(${2:const ofFloatColor &c})"},
        { "trigger": "ofMesh::addColors \t(const vector< ofFloatColor >)"                       ,"contents": "${1:ofMesh}.addColors(${2:const vector< ofFloatColor > &cols})"},
        { "trigger": "ofMesh::addColors \t(const ofFloatColor, int)"                            ,"contents": "${1:ofMesh}.addColors(${2:const ofFloatColor *cols}, ${3:int amt})"},
        { "trigger": "ofMesh::addIndex \t(ofIndexType)"                                         ,"contents": "${1:ofMesh}.addIndex(${2:ofIndexType i})"},
        { "trigger": "ofMesh::addIndices \t(const vector< ofIndexType >)"                       ,"contents": "${1:ofMesh}.addIndices(${2:const vector< ofIndexType > &inds})"},
        { "trigger": "ofMesh::addIndices \t(const ofIndexType, int)"                            ,"contents": "${1:ofMesh}.addIndices(${2:const ofIndexType *inds}, ${3:int amt})"},
        { "trigger": "ofMesh::addNormal \t(const ofVec3f)"                                      ,"contents": "${1:ofMesh}.addNormal(${2:const ofVec3f &n})"},
        { "trigger": "ofMesh::addNormals \t(const vector< ofVec3f >)"                           ,"contents": "${1:ofMesh}.addNormals(${2:const vector< ofVec3f > &norms})"},
        { "trigger": "ofMesh::addNormals \t(const ofVec3f, int)"                                ,"contents": "${1:ofMesh}.addNormals(${2:const ofVec3f *norms}, ${3:int amt})"},
        { "trigger": "ofMesh::addTexCoord \t(const ofVec2f)"                                    ,"contents": "${1:ofMesh}.addTexCoord(${2:const ofVec2f &t})"},
        { "trigger": "ofMesh::addTexCoords \t(const vector< ofVec2f >)"                         ,"contents": "${1:ofMesh}.addTexCoords(${2:const vector< ofVec2f > &tCoords})"},
        { "trigger": "ofMesh::addTexCoords \t(const ofVec2f, int)"                              ,"contents": "${1:ofMesh}.addTexCoords(${2:const ofVec2f *tCoords}, ${3:int amt})"},
        { "trigger": "ofMesh::addTriangle \t(ofIndexType, ofIndexType, ofIndexType)"            ,"contents": "${1:ofMesh}.addTriangle(${2:ofIndexType index1}, ${3:ofIndexType index2}, ${3:ofIndexType index3})"},
        { "trigger": "ofMesh::addVertex \t(const ofVec3f)"                                      ,"contents": "${1:ofMesh}.addVertex(${2:const ofVec3f &v})"},
        { "trigger": "ofMesh::addVertices \t(const vector< ofVec3f >)"                          ,"contents": "${1:ofMesh}.addVertices(${2:const vector< ofVec3f > &verts})"},
        { "trigger": "ofMesh::addVertices \t(const ofVec3f, int)"                               ,"contents": "${1:ofMesh}.addVertices(${2:const ofVec3f *verts}, ${3:int amt})"},
        { "trigger": "ofMesh::clear"                                                            ,"contents": "${1:ofMesh}.clear()"},
        { "trigger": "ofMesh::clearColors"                                                      ,"contents": "${1:ofMesh}.clearColors()"},
        { "trigger": "ofMesh::clearIndices"                                                     ,"contents": "${1:ofMesh}.clearIndices()"},
        { "trigger": "ofMesh::clearNormals"                                                     ,"contents": "${1:ofMesh}.clearNormals()"},
        { "trigger": "ofMesh::clearTexCoords"                                                   ,"contents": "${1:ofMesh}.clearTexCoords()"},
        { "trigger": "ofMesh::clearVertices"                                                    ,"contents": "${1:ofMesh}.clearVertices()"},
        { "trigger": "ofMesh::disableColors"                                                    ,"contents": "${1:ofMesh}.disableColors()"},
        { "trigger": "ofMesh::disableIndices"                                                   ,"contents": "${1:ofMesh}.disableIndices()"},
        { "trigger": "ofMesh::disableNormals"                                                   ,"contents": "${1:ofMesh}.disableNormals()"},
        { "trigger": "ofMesh::disableTextures"                                                  ,"contents": "${1:ofMesh}.disableTextures()"},
        { "trigger": "ofMesh::draw"                                                             ,"contents": "${1:ofMesh}.draw()"},
        { "trigger": "ofMesh::drawFaces"                                                        ,"contents": "${1:ofMesh}.drawFaces()"},
        { "trigger": "ofMesh::drawVertices"                                                     ,"contents": "${1:ofMesh}.drawVertices()"},
        { "trigger": "ofMesh::drawWireframe"                                                    ,"contents": "${1:ofMesh}.drawWireframe()"},
        { "trigger": "ofMesh::enableColors"                                                     ,"contents": "${1:ofMesh}.enableColors()"},
        { "trigger": "ofMesh::enableIndices"                                                    ,"contents": "${1:ofMesh}.enableIndices()"},
        { "trigger": "ofMesh::enableNormals"                                                    ,"contents": "${1:ofMesh}.enableNormals()"},
        { "trigger": "ofMesh::enableTextures"                                                   ,"contents": "${1:ofMesh}.enableTextures()"},
        { "trigger": "ofMesh::getCentroid"                                                      ,"contents": "${1:ofMesh}.getCentroid()"},
        { "trigger": "ofMesh::getColor \t(int)"                                                 ,"contents": "${1:ofMesh}.getColor(${2:int i})"},
        { "trigger": "ofMesh::getColor \t(ofIndexType)"                                         ,"contents": "${1:ofMesh}.getColor(${2:ofIndexType i})"},
        { "trigger": "ofMesh::getColors"                                                        ,"contents": "${1:ofMesh}.getColors()"},
        { "trigger": "ofMesh::getColorsPointer"                                                 ,"contents": "${1:ofMesh}.getColorsPointer()"},
        { "trigger": "ofMesh::getFace (int)"                                                    ,"contents": "${1:ofMesh}.getFace(${2:int faceId})"},
        { "trigger": "ofMesh::getIndex \t(int)"                                                 ,"contents": "${1:ofMesh}.getIndex(${2:int i})"},
        { "trigger": "ofMesh::getIndex \t(ofIndexType)"                                         ,"contents": "${1:ofMesh}.getIndex(${2:ofIndexType i})"},
        { "trigger": "ofMesh::getIndexPointer"                                                  ,"contents": "${1:ofMesh}.getIndexPointer()"},
        { "trigger": "ofMesh::getIndices"                                                       ,"contents": "${1:ofMesh}.getIndices()"},
        { "trigger": "ofMesh::getMode"                                                          ,"contents": "${1:ofMesh}.getMode()"},
        { "trigger": "ofMesh::getNormal \t(int)"                                                ,"contents": "${1:ofMesh}.getNormal(${2:int i})"},
        { "trigger": "ofMesh::getNormal \t(ofIndexType)"                                        ,"contents": "${1:ofMesh}.getNormal(${2:ofIndexType i})"},
        { "trigger": "ofMesh::getNormals"                                                       ,"contents": "${1:ofMesh}.getNormals()"},
        { "trigger": "ofMesh::getNormalsPointer"                                                ,"contents": "${1:ofMesh}.getNormalsPointer()"},
        { "trigger": "ofMesh::getNumColors"                                                     ,"contents": "${1:ofMesh}.getNumColors()"},
        { "trigger": "ofMesh::getNumIndices"                                                    ,"contents": "${1:ofMesh}.getNumIndices()"},
        { "trigger": "ofMesh::getNumNormals"                                                    ,"contents": "${1:ofMesh}.getNumNormals()"},
        { "trigger": "ofMesh::getNumTexCoords"                                                  ,"contents": "${1:ofMesh}.getNumTexCoords()"},
        { "trigger": "ofMesh::getNumVertices"                                                   ,"contents": "${1:ofMesh}.getNumVertices()"},
        { "trigger": "ofMesh::getTexCoord \t(int)"                                              ,"contents": "${1:ofMesh}.getTexCoord(${2:int i})"},
        { "trigger": "ofMesh::getTexCoord \t(ofIndexType)"                                      ,"contents": "${1:ofMesh}.getTexCoord(${2:ofIndexType i})"},
        { "trigger": "ofMesh::getTexCoords"                                                     ,"contents": "${1:ofMesh}.getTexCoords()"},
        { "trigger": "ofMesh::getTexCoordsPointer"                                              ,"contents": "${1:ofMesh}.getTexCoordsPointer()"},
        { "trigger": "ofMesh::getVertex \t(int)"                                                ,"contents": "${1:ofMesh}.getVertex(${2:int i})"},
        { "trigger": "ofMesh::getVertex \t(ofIndexType)"                                        ,"contents": "${1:ofMesh}.getVertex(${2:ofIndexType i})"},
        { "trigger": "ofMesh::getVertices"                                                      ,"contents": "${1:ofMesh}.getVertices()"},
        { "trigger": "ofMesh::getVerticesPointer"                                               ,"contents": "${1:ofMesh}.getVerticesPointer()"},
        { "trigger": "ofMesh::hasColors"                                                        ,"contents": "${1:ofMesh}.hasColors()"},
        { "trigger": "ofMesh::hasIndices"                                                       ,"contents": "${1:ofMesh}.hasIndices()"},
        { "trigger": "ofMesh::hasNormals"                                                       ,"contents": "${1:ofMesh}.hasNormals()"},
        { "trigger": "ofMesh::hasTexCoords"                                                     ,"contents": "${1:ofMesh}.hasTexCoords()"},
        { "trigger": "ofMesh::hasVertices"                                                      ,"contents": "${1:ofMesh}.hasVertices()"},
        { "trigger": "ofMesh::haveColorsChanged"                                                ,"contents": "${1:ofMesh}.haveColorsChanged()"},
        { "trigger": "ofMesh::haveIndicesChanged"                                               ,"contents": "${1:ofMesh}.haveIndicesChanged()"},
        { "trigger": "ofMesh::haveNormalsChanged"                                               ,"contents": "${1:ofMesh}.haveNormalsChanged()"},
        { "trigger": "ofMesh::haveTexCoordsChanged"                                             ,"contents": "${1:ofMesh}.haveTexCoordsChanged()"},
        { "trigger": "ofMesh::haveVertsChanged"                                                 ,"contents": "${1:ofMesh}.haveVertsChanged()"},
        { "trigger": "ofMesh::load \t(string)"                                                  ,"contents": "${1:ofMesh}.load(${2:string path})"},
        { "trigger": "ofMesh::removeColor \t(int)"                                              ,"contents": "${1:ofMesh}.removeColor(${2:int index})"},
        { "trigger": "ofMesh::removeColor \t(ofIndexType)"                                      ,"contents": "${1:ofMesh}.removeColor(${2:ofIndexType index})"},
        { "trigger": "ofMesh::removeIndex \t(int)"                                              ,"contents": "${1:ofMesh}.removeIndex(${2:int i})"},
        { "trigger": "ofMesh::removeIndex \t(ofIndexType)"                                      ,"contents": "${1:ofMesh}.removeIndex(${2:ofIndexType index})"},
        { "trigger": "ofMesh::removeNormal \t(int)"                                             ,"contents": "${1:ofMesh}.removeNormal(${2:int index})"},
        { "trigger": "ofMesh::removeNormal \t(ofIndexType)"                                     ,"contents": "${1:ofMesh}.removeNormal(${2:ofIndexType index})"},
        { "trigger": "ofMesh::removeTexCoord \t(int)"                                           ,"contents": "${1:ofMesh}.removeTexCoord(${2:int index})"},
        { "trigger": "ofMesh::removeTexCoord \t(ofIndexType)"                                   ,"contents": "${1:ofMesh}.removeTexCoord(${2:ofIndexType index})"},
        { "trigger": "ofMesh::removeVertex \t(int)"                                             ,"contents": "${1:ofMesh}.removeVertex(${2:int index})"},
        { "trigger": "ofMesh::removeVertex \t(ofIndexType)"                                     ,"contents": "${1:ofMesh}.removeVertex(${2:ofIndexType index})"},
        { "trigger": "ofMesh::save \t(string, bool)"                                            ,"contents": "${1:ofMesh}.save(${2:string path}, ${3:bool useBinary=false})"},
        { "trigger": "ofMesh::setColor \t(int, const ofFloatColor)"                             ,"contents": "${1:ofMesh}.setColor(${2:int index}, ${:3const ofFloatColor &c})"},
        { "trigger": "ofMesh::setColor \t(ofIndexType, const ofFloatColor)"                     ,"contents": "${1:ofMesh}.setColor(${2:ofIndexType index}, ${3:const ofFloatColor &c})"},
        { "trigger": "ofMesh::setIndex \t(int, ofIndexType)"                                    ,"contents": "${1:ofMesh}.setIndex(${2:int i}, ${3:ofIndexType val})"},
        { "trigger": "ofMesh::setIndex \t(ofIndexType, ofIndexType)"                            ,"contents": "${1:ofMesh}.setIndex(${2:ofIndexType index}, ${3:ofIndexType val})"},
        { "trigger": "ofMesh::setMode \t(ofPrimitiveMode)"                                      ,"contents": "${1:ofMesh}.setMode(${2:ofPrimitiveMode mode})"},
        { "trigger": "ofMesh::setName     \t(string)"                                           ,"contents": "${1:ofMesh}.setName(${2:string name_})"},
        { "trigger": "ofMesh::setNormal \t(int, const ofVec3f)"                                 ,"contents": "${1:ofMesh}.setNormal(${2:int index}, ${3:const ofVec3f &n})"},
        { "trigger": "ofMesh::setTexCoord \t(int, const ofVec2f)"                               ,"contents": "${1:ofMesh}.setTexCoord(${2:int index}, ${3:const ofVec2f &t})"},
        { "trigger": "ofMesh::setTexCoord \t(ofIndexType, const ofVec2f)"                       ,"contents": "${1:ofMesh}.setTexCoord(${2:ofIndexType index}, ${3:const ofVec2f &t})"},
        { "trigger": "ofMesh::setVertex \t(int, const ofVec3f)"                                 ,"contents": "${1:ofMesh}.setVertex(${2:int index}, ${3:const ofVec3f &v})"},
        { "trigger": "ofMesh::setVertex \t(ofIndexType, const ofVec3f)"                         ,"contents": "${1:ofMesh}.setVertex(${2:ofIndexType index}, ${3:const ofVec3f &v})"},
        { "trigger": "ofMesh::setupIndicesAuto"                                                 ,"contents": "${1:ofMesh}.setupIndicesAuto()"},
        { "trigger": "ofMesh::usingColors"                                                      ,"contents": "${1:ofMesh}.usingColors()"},
        { "trigger": "ofMesh::usingIndices"                                                     ,"contents": "${1:ofMesh}.usingIndices()"},
        { "trigger": "ofMesh::usingNormals"                                                     ,"contents": "${1:ofMesh}.usingNormals()"},
        { "trigger": "ofMesh::usingTextures"                                                    ,"contents": "${1:ofMesh}.usingTextures()"},
        /////////////////////////////////
        // ofNode
        { "trigger": "ofNode::boom\t(float)"                                         ,"contents": "${1:ofNode}.boom(${2:float amount})"},
        { "trigger": "ofNode::clearParent"                                           ,"contents": "${1:ofNode}.clearParent()"},
        { "trigger": "ofNode::customDraw"                                            ,"contents": "${1:ofNode}.customDraw()"},
        { "trigger": "ofNode::dolly\t(float)"                                        ,"contents": "${1:ofNode}.dolly(${2:float amount})"},
        { "trigger": "ofNode::draw"                                                  ,"contents": "${1:ofNode}.draw()"},
        { "trigger": "ofNode::getGlobalOrientation"                                  ,"contents": "${1:ofNode}.getGlobalOrientation()"},
        { "trigger": "ofNode::getGlobalPosition"                                     ,"contents": "${1:ofNode}.getGlobalPosition()"},
        { "trigger": "ofNode::getGlobalScale"                                        ,"contents": "${1:ofNode}.getGlobalScale()"},
        { "trigger": "ofNode::getGlobalTransformMatrix"                              ,"contents": "${1:ofNode}.getGlobalTransformMatrix()"},
        { "trigger": "ofNode::getHeading"                                            ,"contents": "${1:ofNode}.getHeading()"},
        { "trigger": "ofNode::getLocalTransformMatrix"                               ,"contents": "${1:ofNode}.getLocalTransformMatrix()"},
        { "trigger": "ofNode::getLookAtDir"                                          ,"contents": "${1:ofNode}.getLookAtDir()"},
        { "trigger": "ofNode::getOrientationEuler"                                   ,"contents": "${1:ofNode}.getOrientationEuler()"},
        { "trigger": "ofNode::getOrientationQuat"                                    ,"contents": "${1:ofNode}.getOrientationQuat()"},
        { "trigger": "ofNode::getParent"                                             ,"contents": "${1:ofNode}.getParent()"},
        { "trigger": "ofNode::getPitch"                                              ,"contents": "${1:ofNode}.getPitch()"},
        { "trigger": "ofNode::getPosition"                                           ,"contents": "${1:ofNode}.getPosition()"},
        { "trigger": "ofNode::getRoll"                                               ,"contents": "${1:ofNode}.getRoll()"},
        { "trigger": "ofNode::getScale"                                              ,"contents": "${1:ofNode}.getScale()"},
        { "trigger": "ofNode::getSideDir"                                            ,"contents": "${1:ofNode}.getSideDir()"},
        { "trigger": "ofNode::getUpDir"                                              ,"contents": "${1:ofNode}.getUpDir()"},
        { "trigger": "ofNode::getX"                                                  ,"contents": "${1:ofNode}.getX()"},
        { "trigger": "ofNode::getXAxis"                                              ,"contents": "${1:ofNode}.getXAxis()"},
        { "trigger": "ofNode::getY"                                                  ,"contents": "${1:ofNode}.getY()"},
        { "trigger": "ofNode::getYAxis"                                              ,"contents": "${1:ofNode}.getYAxis()"},
        { "trigger": "ofNode::getZ"                                                  ,"contents": "${1:ofNode}.getZ()"},
        { "trigger": "ofNode::getZAxis"                                              ,"contents": "${1:ofNode}.getZAxis()"},
        { "trigger": "ofNode::lookAt\t(const ofVec3f, ofVec3f)"                      ,"contents": "${1:ofNode}.lookAt(${2:const ofVec3f &lookAtPosition}, ${3:ofVec3f upVector=ofVec3f(0, 1, 0)})"},
        { "trigger": "ofNode::lookAt\t(const ofNode, const ofVec3f)"                 ,"contents": "${1:ofNode}.lookAt(${2:const ofNode &lookAtNode}, ${3:const ofVec3f &upVector=ofVec3f(0, 1, 0)})"},
        { "trigger": "ofNode::move\t(float, float, float)    "                       ,"contents": "${1:ofNode}.move(${2:float x}, ${3:float y}, ${4:float z})"},
        { "trigger": "ofNode::move\t(const ofVec3f)  "                               ,"contents": "${1:ofNode}.move(${2:const ofVec3f &offset})"},
        { "trigger": "ofNode::orbit\t(float, float, float, const ofVec3f"            ,"contents": "${1:ofNode}.orbit(${2:float longitude}, ${3:float latitude}, ${4:float radius}, ${5:const ofVec3f &centerPoint=ofVec3f(0, 0, 0)})"},
        { "trigger": "ofNode::orbit\t(float, float, float, ofNode)   "               ,"contents": "${1:ofNode}.orbit(${2:float longitude}, ${3:float latitude}, ${4:float radius}, ${5:ofNode &centerNode})"},
        { "trigger": "ofNode::pan\t(float)   "                                       ,"contents": "${1:ofNode}.pan(${2:float degrees})"},
        { "trigger": "ofNode::resetTransform"                                        ,"contents": "${1:ofNode}.resetTransform()"},
        { "trigger": "ofNode::restoreTransformGL"                                    ,"contents": "${1:ofNode}.restoreTransformGL()"},
        { "trigger": "ofNode::roll\t(float)"                                         ,"contents": "${1:ofNode}.roll(${2:float degrees})"},
        { "trigger": "ofNode::rotate\t(const)"                                       ,"contents": "${1:ofNode}.rotate(${2:const ofQuaternion &q})"},
        ///////////////////////////////
        // ofFbo
        { "trigger": "ofFbo::allocate \t(int, int, int, int)"                                ,"contents": "${1:ofFbo}.allocate(${2:int width}, ${3:int height}, ${4:int internalformat=GL_RGBA}, ${5:int numSamples=0})"},
        { "trigger": "ofFbo::allocate \t(Settings)"                                          ,"contents": "${1:ofFbo}.allocate(${2:Settings settings=Settings()})"},
        { "trigger": "ofFbo::begin"                                                          ,"contents": "${1:ofFbo}.begin()"},
        { "trigger": "ofFbo::begin \t(bool)"                                                 ,"contents": "${1:ofFbo}.begin(${2:bool setupScreen=true})"},
        { "trigger": "ofFbo::bind"                                                           ,"contents": "${1:ofFbo}.bind()"},
        { "trigger": "ofFbo::checkGLSupport"                                                 ,"contents": "${1:ofFbo}.checkGLSupport()"},
        { "trigger": "ofFbo::draw \t(float, float)"                                          ,"contents": "${1:ofFbo}.draw(${2:float x}, ${3:float y})"},
        { "trigger": "ofFbo::draw \t(float, float, float, float)"                            ,"contents": "${1:ofFbo}.draw(${2:float x}, ${3:float y}, ${4:float width}, ${5:float height})"},
        { "trigger": "ofFbo::end"                                                            ,"contents": "${1:ofFbo}.end()"},
        { "trigger": "ofFbo::getDefaultTextureIndex"                                         ,"contents": "${1:ofFbo}.getDefaultTextureIndex()"},
        { "trigger": "ofFbo::getDepthBuffer"                                                 ,"contents": "${1:ofFbo}.getDepthBuffer()"},
        { "trigger": "ofFbo::getDepthTexture"                                                ,"contents": "${1:ofFbo}.getDepthTexture()"},
        { "trigger": "ofFbo::getFbo"                                                         ,"contents": "${1:ofFbo}.getFbo()"},
        { "trigger": "ofFbo::getHeight"                                                      ,"contents": "${1:ofFbo}.getHeight()"},
        { "trigger": "ofFbo::getNumTextures"                                                 ,"contents": "${1:ofFbo}.getNumTextures()"},
        { "trigger": "ofFbo::getStencilBuffer"                                               ,"contents": "${1:ofFbo}.getStencilBuffer()"},
        { "trigger": "ofFbo::getTextureReference"                                            ,"contents": "${1:ofFbo}.getTextureReference()"},
        { "trigger": "ofFbo::getTextureReference \t(int)"                                    ,"contents": "${1:ofFbo}.getTextureReference(${2:int attachmentPoint})"},
        { "trigger": "ofFbo::getWidth"                                                       ,"contents": "${1:ofFbo}.getWidth()"},
        { "trigger": "ofFbo::isAllocated"                                                    ,"contents": "${1:ofFbo}.isAllocated()"},
        { "trigger": "ofFbo::maxColorAttachments"                                            ,"contents": "${1:ofFbo}.maxColorAttachments()"},
        { "trigger": "ofFbo::maxDrawBuffers"                                                 ,"contents": "${1:ofFbo}.maxDrawBuffers()"},
        { "trigger": "ofFbo::maxSamples"                                                     ,"contents": "${1:ofFbo}.maxSamples()"},
        { "trigger": "ofFbo::operator= \t(const ofFbo)"                                      ,"contents": "${1:ofFbo}.operator=(${2:const ofFbo &fbo})"},
        { "trigger": "ofFbo::readToPixels \t(ofPixels, int)"                                 ,"contents": "${1:ofFbo}.readToPixels(${2:ofPixels &pixels}, ${3:int attachmentPoint=0})"},
        { "trigger": "ofFbo::readToPixels \t(ofShortPixels, int)"                            ,"contents": "${1:ofFbo}.readToPixels(${2:ofShortPixels &pixels}, ${3:int attachmentPoint=0})"},
        { "trigger": "ofFbo::readToPixels \t(ofFloatPixels, int)"                            ,"contents": "${1:ofFbo}.readToPixels(${2:ofFloatPixels &pixels}, ${3:int attachmentPoint=0})"},
        { "trigger": "ofFbo::resetAnchor"                                                    ,"contents": "${1:ofFbo}.resetAnchor()"},
        { "trigger": "ofFbo::setActiveDrawBuffer \t(int)"                                    ,"contents": "${1:ofFbo}.setActiveDrawBuffer(${2:int i})"},
        { "trigger": "ofFbo::setActiveDrawBuffers \t(const vector< int >)"                   ,"contents": "${1:ofFbo}.setActiveDrawBuffers(${2:const vector< int > &i})"},
        { "trigger": "ofFbo::setAnchorPercent \t(float xPct, float yPct)  "                  ,"contents": "${1:ofFbo}.setAnchorPercent(${2:float xPct}, ${3:float yPct})"},
        { "trigger": "ofFbo::setAnchorPoint \t(float, float)"                                ,"contents": "${1:ofFbo}.setAnchorPoint(${2:float x}, ${3:float y})"},
        { "trigger": "ofFbo::setDefaultTextureIndex \t(int)"                                 ,"contents": "${1:ofFbo}.setDefaultTextureIndex(${2:int defaultTexture})"},
        { "trigger": "ofFbo::setUseTexture \t(bool)"                                         ,"contents": "${1:ofFbo}.setUseTexture(${2:bool bUseTex})"},
        { "trigger": "ofFbo::unbind"                                                         ,"contents": "${1:ofFbo}.unbind()"},

        ///////////////////// OpenGL /////////////////////////
        //////////////////////////////////////////////////////
        // ofGLRenderer 
        { "trigger": "ofGLRenderer::bClearBg"                                                                                   ,"contents": "${1:ofGLRenderer}.bClearBg()"},
        { "trigger": "ofGLRenderer::background \t(const ofColor)"                                                               ,"contents": "${1:ofGLRenderer}.background(${2:const ofColor &c})"},
        { "trigger": "ofGLRenderer::background \t(float)"                                                                       ,"contents": "${1:ofGLRenderer}.background(${2:float brightness})"},
        { "trigger": "ofGLRenderer::background \t(int, float)"                                                                  ,"contents": "${1:ofGLRenderer}.background(${2:int hexColor}, ${3:float} ${4:_a=255.0f})"},
        { "trigger": "ofGLRenderer::background \t(int, int, int, int)"                                                          ,"contents": "${1:ofGLRenderer}.background(${2:int r}, ${3:int g}, ${4:int b}, ${5:int a=255})"},
        { "trigger": "ofGLRenderer::clear \t(float, float, float, float)"                                                       ,"contents": "${1:ofGLRenderer}.clear(${2:float r}, ${3:float g}, ${4:float b}, ${5:float a=0})"},
        { "trigger": "ofGLRenderer::clear \t(float, float)"                                                                     ,"contents": "${1:ofGLRenderer}.clear(${2:float brightness}, ${3:float a=0})"},
        { "trigger": "ofGLRenderer::clearAlpha"                                                                                 ,"contents": "${1:ofGLRenderer}.clearAlpha()"},
        { "trigger": "ofGLRenderer::disablePointSprites"                                                                        ,"contents": "${1:ofGLRenderer}.disablePointSprites()"},
        { "trigger": "ofGLRenderer::draw \t(ofMesh)"                                                                            ,"contents": "${1:ofGLRenderer}.draw(${2:ofMesh &vertexData})"},
        { "trigger": "ofGLRenderer::draw \t(ofMesh, ofPolyRenderMode)"                                                          ,"contents": "${1:ofGLRenderer}.draw(${2:ofMesh &vertexData}, ${3:ofPolyRenderMode renderType})"},
        { "trigger": "ofGLRenderer::draw \t(ofPolyline)"                                                                        ,"contents": "${1:ofGLRenderer}.draw(${2:ofPolyline &poly})"},
        { "trigger": "ofGLRenderer::draw \t(ofPath)"                                                                            ,"contents": "${1:ofGLRenderer}.draw(${2:ofPath &path})"},
        { "trigger": "ofGLRenderer::draw \t(vector< ofPoint >, ofPrimitiveMode)"                                                ,"contents": "${1:ofGLRenderer}.draw(${2:vector< ofPoint > &vertexData}, ${3:ofPrimitiveMode drawMode})"},
        { "trigger": "ofGLRenderer::draw \t(ofImage, float, float, float, float, float)"                                        ,"contents": "${1:ofGLRenderer}.draw(${2:ofImage &image}, ${3:float x}, ${4:float y}, ${5:float z}, ${6:float w}, ${7:float h})"},
        { "trigger": "ofGLRenderer::draw \t(ofFloatImage, float, float, float, float, float)"                                   ,"contents": "${1:ofGLRenderer}.draw(${2:ofFloatImage &image}, ${3:float x}, ${4:float y}, ${5:float z}, ${6:float w}, ${7:float h})"},
        { "trigger": "ofGLRenderer::draw \t(ofShortImage, float, float, float, float, float)"                                   ,"contents": "${1:ofGLRenderer}.draw(${2:ofShortImage &image}, ${3:float x}, ${4:float y}, ${5:float z}, ${6:float w}, ${7:float h})"},
        { "trigger": "ofGLRenderer::draw \t(ofMesh, bool, bool, bool)"                                                          ,"contents": "${1:ofGLRenderer}.draw(${2:ofMesh &vertexData}, ${3:bool useColors=true}, ${4:bool useTextures=true}, ${5:bool useNormals=true)}"},
        { "trigger": "ofGLRenderer::draw \t(ofMesh, ofPolyRenderMode, bool, bool, bool)"                                        ,"contents": "${1:ofGLRenderer}.draw(${2:ofMesh &vertexData}, ${3:ofPolyRenderMode renderType}, ${4:bool useColors=true}, ${5:bool useTextures=true}, ${6:bool useNormals=true})"},
        { "trigger": "ofGLRenderer::draw \t(ofImage, float, float, float, float, float, float, float, float, float)"            ,"contents": "${1:ofGLRenderer}.draw(${2:ofImage       &image}, ${3:float x}, ${4:float y}, ${5:float z}, ${6:float w}, ${7:float h}, ${8:float sx}, ${9:float sy}, ${10:float sw}, ${11:float sh})"},
        { "trigger": "ofGLRenderer::draw \t(ofFloatImage, float, float, float, float, float, float, float, float, float)"       ,"contents": "${1:ofGLRenderer}.draw(${2:ofFloatImage  &image}, ${3:float x}, ${4:float y}, ${5:float z}, ${6:float w}, ${7:float h}, ${8:float sx}, ${9:float sy}, ${10:float sw}, ${11:float sh})"},
        { "trigger": "ofGLRenderer::draw \t(ofShortImage, float, float, float, float, float, float, float, float, float)"       ,"contents": "${1:ofGLRenderer}.draw(${2:ofShortImage  &image}, ${3:float x}, ${4:float y}, ${5:float z}, ${6:float w}, ${7:float h}, ${8:float sx}, ${9:float sy}, ${10:float sw}, ${11:float sh})"},
        { "trigger": "ofGLRenderer::drawCircle \t(float, float, float, float)"                                                  ,"contents": "${1:ofGLRenderer}.drawCircle(${2:float x}, ${3:float y}, ${4:float z}, ${5:float radius})"},
        { "trigger": "ofGLRenderer::drawEllipse \t(float, float, float, float, float)"                                          ,"contents": "${1:ofGLRenderer}.drawEllipse(${2:float x}, ${3:float y}, ${4:float z}, ${5:float width}, ${6:float height})"},
        { "trigger": "ofGLRenderer::drawLine \t(float, float, float, float, float, float)"                                      ,"contents": "${1:ofGLRenderer}.drawLine(${2:float x1}, ${3:float y1}, ${4:float z1}, ${5:float x2}, ${6:float y2}, ${7:float z2})"},
        { "trigger": "ofGLRenderer::drawRectangle \t(float, float, float, float, float)"                                        ,"contents": "${1:ofGLRenderer}.drawRectangle(${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h})"},
        { "trigger": "ofGLRenderer::drawSphere \t(float, float, float, float)"                                                  ,"contents": "${1:ofGLRenderer}.drawSphere(${2:float x}, ${3:float y}, ${4:float z}, ${5:float radius})"},
        { "trigger": "ofGLRenderer::drawString \t(string, float, float, float, ofDrawBitmapMode)"                               ,"contents": "${1:ofGLRenderer}.drawString(${2:string text}, ${3:float x}, ${4:float y}, ${5:float z}, ${6:ofDrawBitmapMode mode})"},
        { "trigger": "ofGLRenderer::drawTriangle( \tfloat, float, float, float, float, float, float, float, float)"             ,"contents": "${1:ofGLRenderer}.drawTriangle(${2:float x1}, ${3:float y1}, ${4:float z1}, ${5:float x2}, ${6:float y2}, ${7:float z2}, ${8:float x3}, ${9:float y3}, ${10:float z3})"},
        { "trigger": "ofGLRenderer::enablePointSprites"                                                                         ,"contents": "${1:ofGLRenderer}.enablePointSprites()"},
        { "trigger": "ofGLRenderer::getBgColor"                                                                                 ,"contents": "${1:ofGLRenderer}.getBgColor()"},
        { "trigger": "ofGLRenderer::getCoordHandedness"                                                                         ,"contents": "${1:ofGLRenderer}.getCoordHandedness()"},
        { "trigger": "ofGLRenderer::getCurrentViewport"                                                                         ,"contents": "${1:ofGLRenderer}.getCurrentViewport()"},
        { "trigger": "ofGLRenderer::getFillMode"                                                                                ,"contents": "${1:ofGLRenderer}.getFillMode()"},
        { "trigger": "ofGLRenderer::getRectMode"                                                                                ,"contents": "${1:ofGLRenderer}.getRectMode()"},
        { "trigger": "ofGLRenderer::getType"                                                                                    ,"contents": "${1:ofGLRenderer}.getType()"},
        { "trigger": "ofGLRenderer::getViewportHeight"                                                                          ,"contents": "${1:ofGLRenderer}.getViewportHeight()"},
        { "trigger": "ofGLRenderer::getViewportWidth"                                                                           ,"contents": "${1:ofGLRenderer}.getViewportWidth()"},
        { "trigger": "ofGLRenderer::loadIdentityMatrix \t(void)"                                                                ,"contents": "${1:ofGLRenderer}.loadIdentityMatrix(${2:void})"},
        { "trigger": "ofGLRenderer::loadMatrix \t(const ofMatrix4x4)"                                                           ,"contents": "${1:ofGLRenderer}.loadMatrix(${2:const ofMatrix4x4 &m})"},
        { "trigger": "ofGLRenderer::loadMatrix \t(const float)"                                                                 ,"contents": "${1:ofGLRenderer}.loadMatrix(${2:const float *m})"},
        { "trigger": "ofGLRenderer::multMatrix \t(const ofMatrix4x4)"                                                           ,"contents": "${1:ofGLRenderer}.multMatrix(${2:const ofMatrix4x4 &m})"},
        { "trigger": "ofGLRenderer::multMatrix \t(const float)"                                                                 ,"contents": "${1:ofGLRenderer}.multMatrix(${2:const float *m})"},
        { "trigger": "ofGLRenderer::popMatrix"                                                                                  ,"contents": "${1:ofGLRenderer}.popMatrix()"},
        { "trigger": "ofGLRenderer::popView"                                                                                    ,"contents": "${1:ofGLRenderer}.popView()"},
        { "trigger": "ofGLRenderer::pushMatrix"                                                                                 ,"contents": "${1:ofGLRenderer}.pushMatrix()"},
        { "trigger": "ofGLRenderer::pushView"                                                                                   ,"contents": "${1:ofGLRenderer}.pushView()"},
        { "trigger": "ofGLRenderer::rendersPathPrimitives"                                                                      ,"contents": "${1:ofGLRenderer}.rendersPathPrimitives()"},
        { "trigger": "ofGLRenderer::rotate \t(float, float, float, float)"                                                      ,"contents": "${1:ofGLRenderer}.rotate(${2:float degrees}, ${3:float vecX}, ${4:float vecY}, ${5:float vecZ})"},
        { "trigger": "ofGLRenderer::rotate \t(float)"                                                                           ,"contents": "${1:ofGLRenderer}.rotate(${2:float degrees})"},
        { "trigger": "ofGLRenderer::rotateX \t(float)"                                                                          ,"contents": "${1:ofGLRenderer}.rotateX(${2:float degrees})"},
        { "trigger": "ofGLRenderer::rotateY \t(float)"                                                                          ,"contents": "${1:ofGLRenderer}.rotateY(${2:float degrees})"},
        { "trigger": "ofGLRenderer::rotateZ \t(float)"                                                                          ,"contents": "${1:ofGLRenderer}.rotateZ(${2:float degrees})"},
        { "trigger": "ofGLRenderer::scale \t(float, float, float)"                                                              ,"contents": "${1:ofGLRenderer}.scale(${2:float xAmnt}, ${3:float yAmnt}, ${4:float zAmnt=1})"},
        { "trigger": "ofGLRenderer::setBackgroundAuto \t(bool)"                                                                 ,"contents": "${1:ofGLRenderer}.setBackgroundAuto(${2:bool bManual})"},
        { "trigger": "ofGLRenderer::setBlendMode \t(ofBlendMode)"                                                               ,"contents": "${1:ofGLRenderer}.setBlendMode(${2:ofBlendMode blendMode})"},
        { "trigger": "ofGLRenderer::setCircleResolution \t(int)"                                                                ,"contents": "${1:ofGLRenderer}.setCircleResolution(${2:int res})"},
        { "trigger": "ofGLRenderer::setColor \t(int, int, int)"                                                                 ,"contents": "${1:ofGLRenderer}.setColor(${2:int r}, ${3:int g}, ${4:int b})"},
        { "trigger": "ofGLRenderer::setColor \t(int, int, int, int)"                                                            ,"contents": "${1:ofGLRenderer}.setColor(${2:int r}, ${3:int g}, ${4:int b}, ${5:int a})"},
        { "trigger": "ofGLRenderer::setColor \t(const ofColor)"                                                                 ,"contents": "${1:ofGLRenderer}.setColor(${2:const ofColor &color})"},
        { "trigger": "ofGLRenderer::setColor \t(const ofColor, int)"                                                            ,"contents": "${1:ofGLRenderer}.setColor(${2:const ofColor &color}, ${3:int _a})"},
        { "trigger": "ofGLRenderer::setColor \t(int)"                                                                           ,"contents": "${1:ofGLRenderer}.setColor(${2:int gray})"},
        { "trigger": "ofGLRenderer::setCoordHandedness \t(ofHandednessType)"                                                    ,"contents": "${1:ofGLRenderer}.setCoordHandedness(${1:ofHandednessType handedness})"},
        { "trigger": "ofGLRenderer::setCurrentFBO \t(ofFbo)"                                                                    ,"contents": "${1:ofGLRenderer}.setCurrentFBO(${2:ofFbo *fbo})"},
        { "trigger": "ofGLRenderer::setFillMode \t(ofFillFlag)"                                                                 ,"contents": "${1:ofGLRenderer}.setFillMode(${2:ofFillFlag fill})"},
        { "trigger": "ofGLRenderer::setHexColor \t(int)"                                                                        ,"contents": "${1:ofGLRenderer}.setHexColor(${2:int hexColor})"},
        { "trigger": "ofGLRenderer::setLineSmoothing \t(bool)"                                                                  ,"contents": "${1:ofGLRenderer}.setLineSmoothing(${2:bool smooth})"},
        { "trigger": "ofGLRenderer::setLineWidth \t(float)"                                                                     ,"contents": "${1:ofGLRenderer}.setLineWidth(${2:float lineWidth})"},
        { "trigger": "ofGLRenderer::setRectMode \t(ofRectMode)"                                                                 ,"contents": "${1:ofGLRenderer}.setRectMode(${2:ofRectMode mode})"},
        { "trigger": "ofGLRenderer::setSphereResolution \t(int)"                                                                ,"contents": "${1:ofGLRenderer}.setSphereResolution(${2:int res})"},
        { "trigger": "ofGLRenderer::setupGraphicDefaults"                                                                       ,"contents": "${1:ofGLRenderer}.setupGraphicDefaults()"},
        { "trigger": "ofGLRenderer::setupScreen"                                                                                ,"contents": "${1:ofGLRenderer}.setupScreen()"},
        { "trigger": "ofGLRenderer::setupScreenOrtho \t(float, float, ofOrientation, bool, float, float)"                       ,"contents": "${1:ofGLRenderer}.setupScreenOrtho(${2:float width=0}, ${3:float height=0}, ${4:ofOrientation orientation=OF_ORIENTATION_UNKNOWN}, ${5:bool vFlip=true}, ${6:float nearDist=-1}, ${7:float farDist=1})"},
        { "trigger": "ofGLRenderer::setupScreenPerspective \t(float, float, ofOrientation, bool, float, float, float)"          ,"contents": "${1:ofGLRenderer}.setupScreenPerspective(${2:float width=0}, ${3:float height=0}, ${4:ofOrientation orientation=OF_ORIENTATION_UNKNOWN}, ${5:bool vFlip=true}, ${6:float fov=60}, ${7:float nearDist=0}, ${8:float farDist=0})"},
        { "trigger": "ofGLRenderer::translate \t(float, float, float)"                                                          ,"contents": "${1:ofGLRenderer}.translate(${2:float x}, ${3:float y}, ${4:float z=0})"},
        { "trigger": "ofGLRenderer::translate \t(const ofPoint)"                                                                ,"contents": "${1:ofGLRenderer}.translate(${2:const ofPoint &p})"},
        { "trigger": "ofGLRenderer::update"                                                                                     ,"contents": "${1:ofGLRenderer}.update()"},
        { "trigger": "ofGLRenderer::viewport \t(ofRectangle)"                                                                   ,"contents": "${1:ofGLRenderer}.viewport(${2:ofRectangle viewport})"},
        { "trigger": "ofGLRenderer::viewport \t(float, float, float, float, bool)"                                              ,"contents": "${1:ofGLRenderer}.viewport(${2:float x=0}, ${3:float y=0}, ${4:float width=0}, ${5:float height=0}, ${6:bool invertY=true})"},
        //////////////////////////////////
        // ofOrientation
        { "trigger": "OF_ORIENTATION_UNKNOWN \tofOrientation"                                                                   ,"contents": "OF_ORIENTATION_UNKNOWN"},
        ///////////////////////////
        // ofLight
        { "trigger": "ofLight::customDraw"                                                          ,"contents": "${1:ofLight}.customDraw()"},
        { "trigger": "ofLight::destroy"                                                             ,"contents": "${1:ofLight}.destroy()"},
        { "trigger": "ofLight::disable"                                                             ,"contents": "${1:ofLight}.disable()"},
        { "trigger": "ofLight::enable"                                                              ,"contents": "${1:ofLight}.enable()"},
        { "trigger": "ofLight::getAmbientColor"                                                     ,"contents": "${1:ofLight}.getAmbientColor()"},
        { "trigger": "ofLight::getAttenuationConstant"                                              ,"contents": "${1:ofLight}.getAttenuationConstant()"},
        { "trigger": "ofLight::getAttenuationLinear"                                                ,"contents": "${1:ofLight}.getAttenuationLinear()"},
        { "trigger": "ofLight::getAttenuationQuadratic"                                             ,"contents": "${1:ofLight}.getAttenuationQuadratic()"},
        { "trigger": "ofLight::getDiffuseColor"                                                     ,"contents": "${1:ofLight}.getDiffuseColor()"},
        { "trigger": "ofLight::getIsDirectional"                                                    ,"contents": "${1:ofLight}.getIsDirectional()"},
        { "trigger": "ofLight::getIsEnabled"                                                        ,"contents": "${1:ofLight}.getIsEnabled()"},
        { "trigger": "ofLight::getIsPointLight"                                                     ,"contents": "${1:ofLight}.getIsPointLight()"},
        { "trigger": "ofLight::getIsSpotlight"                                                      ,"contents": "${1:ofLight}.getIsSpotlight()"},
        { "trigger": "ofLight::getLightID"                                                          ,"contents": "${1:ofLight}.getLightID()"},
        { "trigger": "ofLight::getSpecularColor"                                                    ,"contents": "${1:ofLight}.getSpecularColor()"},
        { "trigger": "ofLight::getSpotConcentration"                                                ,"contents": "${1:ofLight}.getSpotConcentration()"},
        { "trigger": "ofLight::getSpotlightCutOff"                                                  ,"contents": "${1:ofLight}.getSpotlightCutOff()"},
        { "trigger": "ofLight::getType"                                                             ,"contents": "${1:ofLight}.getType()"},
        { "trigger": "ofLight::setAmbientColor \t(const ofFloatColor)"                              ,"contents": "${1:ofLight}.setAmbientColor(${2:const ofFloatColor &c})"},
        { "trigger": "ofLight::setAttenuation \t(float, float, float)"                              ,"contents": "${1:ofLight}.setAttenuation(${2:float constant=1.f}, ${3:float linear=0.f}, ${4:float quadratic=0.f})"},
        { "trigger": "ofLight::setDiffuseColor \t(const ofFloatColor)"                              ,"contents": "${1:ofLight}.setDiffuseColor(${2:const ofFloatColor &c})"},
        { "trigger": "ofLight::setDirectional"                                                      ,"contents": "${1:ofLight}.setDirectional()"},
        { "trigger": "ofLight::setPointLight"                                                       ,"contents": "${1:ofLight}.setPointLight()"},
        { "trigger": "ofLight::setSpecularColor \t(const ofFloatColor)"                             ,"contents": "${1:ofLight}.setSpecularColor(${2:const ofFloatColor &c})"},
        { "trigger": "ofLight::setSpotConcentration \t(float)"                                      ,"contents": "${1:ofLight}.setSpotConcentration(${2:float exponent})"},
        { "trigger": "ofLight::setSpotlight \t(float, float)"                                       ,"contents": "${1:ofLight}.setSpotlight(${2:float spotCutOff=45.f}, ${3:float exponent=0.f})"},
        { "trigger": "ofLight::setSpotlightCutOff \t(float)"                                        ,"contents": "${1:ofLight}.setSpotlightCutOff(float spotCutOff)"},
        { "trigger": "ofLight::setup"                                                               ,"contents": "${1:ofLight}.setup()"},
        { "trigger": "ofDisableLighting"                                                            ,"contents": "ofDisableLighting()"},
        { "trigger": "ofDisableSeparateSpecularLight"                                               ,"contents": "ofDisableSeparateSpecularLight()"},
        { "trigger": "ofEnableLighting"                                                             ,"contents": "ofEnableLighting()"},
        { "trigger": "ofEnableSeparateSpecularLight"                                                ,"contents": "ofEnableSeparateSpecularLight()"},
        { "trigger": "ofGetLightingEnabled"                                                         ,"contents": "ofGetLightingEnabled()"},
        { "trigger": "ofSetGlobalAmbientColor \t(const ofColor)"                                    ,"contents": "ofSetGlobalAmbientColor(${1:const ofColor &c})"},
        { "trigger": "ofSetSmoothLighting \t(bool)"                                                 ,"contents": "ofSetSmoothLighting(bool b)"},

        ///////////////////////////
        // ofMaterial
        { "trigger": "ofMaterial \tinstance"                                                                    ,"contents": "ofMaterial ${1:myMaterial}"},
        { "trigger": "ofMaterial::begin"                                                                        ,"contents": "${1:ofMaterial}.begin()"},
        { "trigger": "ofMaterial::end"                                                                          ,"contents": "${1:ofMaterial}.end()"},
        { "trigger": "ofMaterial::getAmbientColor"                                                              ,"contents": "${1:ofMaterial}.getAmbientColor()"},
        { "trigger": "ofMaterial::getDiffuseColor"                                                              ,"contents": "${1:ofMaterial}.getDiffuseColor()"},
        { "trigger": "ofMaterial::getEmissiveColor"                                                             ,"contents": "${1:ofMaterial}.getEmissiveColor()"},
        { "trigger": "ofMaterial::getShininess"                                                                 ,"contents": "${1:ofMaterial}.getShininess()"},
        { "trigger": "ofMaterial::getSpecularColor"                                                             ,"contents": "${1:ofMaterial}.getSpecularColor()"},
        { "trigger": "ofMaterial::setAmbientColor \t(ofFloatColor)"                                             ,"contents": "${1:ofMaterial}.setAmbientColor(${2:ofFloatColor oAmbient})"},
        { "trigger": "ofMaterial::setColors \t(ofFloatColor, ofFloatColor, ofFloatColor, ofFloatColor)"         ,"contents": "${1:ofMaterial}.setColors(${2:ofFloatColor oDiffuse}, ${3:ofFloatColor oAmbient}, ${4:ofFloatColor oSpecular}, ${5:ofFloatColor emissive})"},
        { "trigger": "ofMaterial::setDiffuseColor \t(ofFloatColor)"                                             ,"contents": "${1:ofMaterial}.setDiffuseColor(${2:ofFloatColor oDiffuse})"},
        { "trigger": "ofMaterial::setEmissiveColor \t(ofFloatColor)"                                            ,"contents": "${1:ofMaterial}.setEmissiveColor(${2:ofFloatColor oEmmisive})"},
        { "trigger": "ofMaterial::setShininess \t(float)"                                                       ,"contents": "${1:ofMaterial}.setShininess(${2:float nShininess})"},
        { "trigger": "ofMaterial::setSpecularColor \t(ofFloatColor)"                                            ,"contents": "${1:ofMaterial}.setSpecularColor(${2:ofFloatColor oSpecular})"},
        // GLenum
        { "trigger": "GL_VERTEX_SHADER \tGLenum"                        ,"contents": "GL_VERTEX_SHADER"},
        { "trigger": "GL_GEOMETRY_SHADER_EXT \tGLenum"                  ,"contents": "GL_GEOMETRY_SHADER_EXT"},
        { "trigger": "GL_FRAGMENT_SHADER \tGLenum"                      ,"contents": "GL_FRAGMENT_SHADER"},
        { "trigger": "GL_POINTS \tGLenum"                               ,"contents": "GL_POINTS"},
        { "trigger": "GL_LINES \tGLenum"                                ,"contents": "GL_LINES"},
        { "trigger": "GL_LINES_ADJACENCY_EXT \tGLenum"                  ,"contents": "GL_LINES_ADJACENCY_EXT"},
        { "trigger": "GL_TRIANGLES \tGLenum"                            ,"contents": "GL_TRIANGLES"},
        { "trigger": "GL_TRIANGLES_ADJACENCY_EXT \tGLenum"              ,"contents": "GL_TRIANGLES_ADJACENCY_EXT"},
        { "trigger": "GL_POINTS \tGLenum"                               ,"contents": "GL_POINTS"},
        { "trigger": "GL_LINE_STRIP \tGLenum"                           ,"contents": "GL_LINE_STRIP"},
        { "trigger": "GL_TRIANGLE_STRIP \tGLenum"                       ,"contents": "GL_TRIANGLE_STRIP"},

        ///////////////////////////
        // ofTexture
        { "trigger": "ofTexture \tinstance"                                                                                     ,"contents": "ofTexture ${1:myTexture}"},
        { "trigger": "ofTexture::allocate \t(int, int, int)"                                                                    ,"contents": "${1:ofTexture}.allocate(${2:int w}, {$3:int h}, ${4:int glInternalFormat})"},
        { "trigger": "ofTexture::allocate \t(int, int, int, bool)"                                                              ,"contents": "${1:ofTexture}.allocate(${2:int w}, ${3:int h}, ${4:int glInternalFormat}, ${5:bool bUseARBExtention})"},
        { "trigger": "ofTexture::allocate \t(const ofTextureData)"                                                              ,"contents": "${1:ofTexture}.allocate(${2:const ofTextureData &textureData})"},
        { "trigger": "ofTexture::allocate \t(const ofPixels)"                                                                   ,"contents": "${1:ofTexture}.allocate(${2:const ofPixels &pix})"},
        { "trigger": "ofTexture::bAllocated"                                                                                    ,"contents": "${1:ofTexture}.bAllocated()"},
        { "trigger": "ofTexture::clear"                                                                                         ,"contents": "${1:ofTexture}.clear()"},
        { "trigger": "ofTexture::draw \t(float, float, float, float)"                                                           ,"contents": "${1:ofTexture}.draw(${2:float x}, ${3:float y}, ${4:float w}, ${5:float h})"},
        { "trigger": "ofTexture::draw \t(float, float)"                                                                         ,"contents": "${1:ofTexture}.draw(${2:float x}, ${3:float y})"},
        { "trigger": "ofTexture::draw \t(float, float, float, float, float)"                                                    ,"contents": "${1:ofTexture}.draw(${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h})"},
        { "trigger": "ofTexture::draw \t(float, float, float)"                                                                  ,"contents": "${1:ofTexture}.draw(${2:float x}, ${3:float y}, ${4:float z})"},
        { "trigger": "ofTexture::draw \t(const ofPoint, const ofPoint, const ofPoint, const ofPoint)"                           ,"contents": "${1:ofTexture}.draw(${2:const ofPoint &p1}, ${3:const ofPoint &p2}, ${4:const ofPoint &p3}, ${5:const ofPoint &p4})"},
        { "trigger": "ofTexture::draw \t(const ofRectangle)"                                                                    ,"contents": "${1:ofTexture}.draw(${2:const ofRectangle &r})"},
        { "trigger": "ofTexture::draw \t(const ofPoint, float, float)"                                                          ,"contents": "${1:ofTexture}.draw(${2:const ofPoint &p}, ${3:float w}, ${4:float h})"},
        { "trigger": "ofTexture::draw \t(const ofPoint)"                                                                        ,"contents": "${1:ofTexture}.draw(${2:const ofPoint &p})"},
        { "trigger": "ofTexture::drawSubsection \t(float, float, float, float, float, float)"                                   ,"contents": "${1:ofTexture}.drawSubsection(${2:float x}, ${3:float y}, ${4:float w}, ${5:float h}, ${6:float sx}, ${7:float sy})"},
        { "trigger": "ofTexture::drawSubsection \t(float, float, float, float, float, float, float)"                            ,"contents": "${1:ofTexture}.drawSubsection(${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h}, ${7:float sx}, ${8:float sy})"},
        { "trigger": "ofTexture::drawSubsection \t(float, float, float, float, float, float, float, float)"                     ,"contents": "${1:ofTexture}.drawSubsection(${2:float x}, ${3:float y}, ${4:float w}, ${5:float h}, ${6:float sx}, ${7:float sy}, ${8:float sw}, ${9:float sh})"},
        { "trigger": "ofTexture::drawSubsection \t(float, float, float, float, float, float, float, float, float)"              ,"contents": "${1:ofTexture}.drawSubsection(${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h}, ${7:float sx}, ${8:float sy}, ${9:float sw}, ${10:float sh})"},
        { "trigger": "ofTexture::getCoordFromPercent \t(float, float)"                                                          ,"contents": "${1:ofTexture}.getCoordFromPercent(${2:float xPts}, ${3:float yPts})"},
        { "trigger": "ofTexture::getCoordFromPoint \t(float, float)"                                                            ,"contents": "${1:ofTexture}.getCoordFromPoint(${2:float xPos}, ${3:float yPos})"},
        { "trigger": "ofTexture::getHeight"                                                                                     ,"contents": "${1:ofTexture}.getHeight()"},
        { "trigger": "ofTexture::getWidth"                                                                                      ,"contents": "${1:ofTexture}.getWidth()"},
        { "trigger": "ofTexture::isAllocated"                                                                                   ,"contents": "${1:ofTexture}.isAllocated()"},
        { "trigger": "ofTexture::loadData \t(unsigned char, int, int, int)"                                                     ,"contents": "${1:ofTexture}.loadData(${2:unsigned char * data}, ${3:int w}, ${4:int h}, ${5:int glDataType})"},
        { "trigger": "ofTexture::loadData \t(const float, int, int, int)"                                                       ,"contents": "${1:ofTexture}.loadData(${2:const float *data}, ${3:int w}, ${4:int h}, ${5:int glFormat})"},
        { "trigger": "ofTexture::loadData \t(const unsigned char, int, int, int)"                                               ,"contents": "${1:ofTexture}.loadData(${2:const unsigned char *const data}, ${3:int w}, ${4:int h}, ${5:int glFormat})"},
        { "trigger": "ofTexture::loadData \t(const unsigned short, int, int, int)"                                              ,"contents": "${1:ofTexture}.loadData(${2:const unsigned short *data}, ${3:int w}, ${4:int h}, ${5:int glFormat})"},
        { "trigger": "ofTexture::loadData \t(const ofPixels)"                                                                   ,"contents": "${1:ofTexture}.loadData(${2:const ofPixels &pix})"},
        { "trigger": "ofTexture::loadData \t(const ofShortPixels)"                                                              ,"contents": "${1:ofTexture}.loadData(${2:const ofShortPixels &pix})"},
        { "trigger": "ofTexture::loadData \t(const ofFloatPixels)"                                                              ,"contents": "${1:ofTexture}.loadData(${2:const ofFloatPixels &pix})"},
        { "trigger": "ofTexture::loadScreenData \t(int, int, int, int)"                                                         ,"contents": "${1:ofTexture}.loadScreenData(${2:int x}, ${3:int y}, ${4:int w}, ${5:int h})"},
        { "trigger": "ofTexture::readToPixels \t(ofPixels)"                                                                     ,"contents": "${1:ofTexture}.readToPixels(${2:ofPixels &pixels})"},
        { "trigger": "ofTexture::readToPixels \t(ofShortPixels)"                                                                ,"contents": "${1:ofTexture}.readToPixels(${2:ofShortPixels &pixels})"},
        { "trigger": "ofTexture::readToPixels \t(ofFloatPixels)"                                                                ,"contents": "${1:ofTexture}.readToPixels(${2:ofFloatPixels &pixels})"},
        { "trigger": "ofTexture::setAnchorPoint \t(float, float)"                                                               ,"contents": "${1:ofTexture}.setAnchorPoint(${2:float x}, ${3:float y})"},
        { "trigger": "ofTexture::setCompression \t(ofTexCompression)"                                                           ,"contents": "${1:ofTexture}.setCompression(${2:ofTexCompression compression})"},
        { "trigger": "ofTexture::setTextureMinMagFilter \t(GLint, GLint)"                                                       ,"contents": "${1:ofTexture}.setTextureMinMagFilter(${2:GLint minFilter}, ${3:GLint maxFilter})"},
        { "trigger": "ofTexture::setTextureWrap \t(GLint, GLint)"                                                               ,"contents": "${1:ofTexture}.setTextureWrap(${2:GLint wrapModeHorizontal}, ${3:GLint wrapModeVertical})"},
        { "trigger": "ofTexture::setUseExternalTextureID \t(GLuint)"                                                            ,"contents": "${1:ofTexture}.setUseExternalTextureID(${2:GLuint externTexID})"},
        { "trigger": "ofDisableArbTex"                                                                                          ,"contents": "ofDisableArbTex()"},
        { "trigger": "ofDisableNormalizedTexCoords"                                                                             ,"contents": "ofDisableNormalizedTexCoords()"},
        { "trigger": "ofDisableTextureEdgeHack"                                                                                 ,"contents": "ofDisableTextureEdgeHack()"},
        { "trigger": "ofEnableArbTex"                                                                                           ,"contents": "ofEnableArbTex()"},
        { "trigger": "ofEnableNormalizedTexCoords"                                                                              ,"contents": "ofEnableNormalizedTexCoords()"},
        { "trigger": "ofEnableTextureEdgeHack"                                                                                  ,"contents": "ofEnableTextureEdgeHack()"},
        { "trigger": "ofGetGlFormatAndType \t(int, int, int)"                                                                   ,"contents": "ofGetGlFormatAndType(${1:int glInternalFormat}, ${2:int &glFormat}, ${3:int &glType})"},
        { "trigger": "ofGetGlInternalFormat \t(const ofPixels)"                                                                 ,"contents": "ofGetGlInternalFormat(${1:const ofPixels &pix})"},
        { "trigger": "ofGetImageTypeFromGLType \t(int)"                                                                         ,"contents": "ofGetImageTypeFromGLType(${1:int glType})"},
        { "trigger": "ofGetUsingArbTex"                                                                                         ,"contents": "ofGetUsingArbTex()"},
        { "trigger": "ofGetUsingCustomMinMagFilters"                                                                            ,"contents": "ofGetUsingCustomMinMagFilters()"},
        { "trigger": "ofGetUsingCustomTextureWrap"                                                                              ,"contents": "ofGetUsingCustomTextureWrap()"},
        { "trigger": "ofGetUsingNormalizedTexCoords"                                                                            ,"contents": "ofGetUsingNormalizedTexCoords()"},
        { "trigger": "ofRestoreMinMagFilters"                                                                                   ,"contents": "ofRestoreMinMagFilters()"},
        { "trigger": "ofRestoreTextureWrap"                                                                                     ,"contents": "ofRestoreTextureWrap()"},
        { "trigger": "ofSetMinMagFilters \t(GLfloat, GLfloat)"                                                                  ,"contents": "ofSetMinMagFilters(${1:GLfloat minFilter=GL_LINEAR}, ${2:GLfloat maxFilter=GL_LINEAR})"},
        { "trigger": "ofSetTextureWrap \t(GLfloat, GLfloat)"                                                                    ,"contents": "ofSetTextureWrap(${1:GLfloat wrapS=GL_CLAMP_TO_EDGE}, ${2:GLfloat wrapT=GL_CLAMP_TO_EDGE})"},
        ///////////////////////////
        // GLfloat
        { "trigger": "GL_CLAMP_TO_EDGE \tGLfloat"                       ,"contents": "GL_CLAMP_TO_EDGE"},
        { "trigger": "GL_LINEAR \tGLfloat"                              ,"contents": "GL_LINEAR"},

        ///////////////////////////
        // ofTextureData
        { "trigger": "ofTextureData::bAllocated"                                                        ,"contents": "${1:ofTextureData}.bAllocated"},
        { "trigger": "ofTextureData::bFlipTexture"                                                      ,"contents": "${1:ofTextureData}.bFlipTexture"},
        { "trigger": "ofTextureData::bUseExternalTextureID"                                             ,"contents": "${1:ofTextureData}.bUseExternalTextureID"},
        { "trigger": "ofTextureData::compressionType"                                                   ,"contents": "${1:ofTextureData}.compressionType"},
        { "trigger": "ofTextureData::glType"                                                            ,"contents": "${1:ofTextureData}.glType"},
        { "trigger": "ofTextureData::glTypeInternal"                                                    ,"contents": "${1:ofTextureData}.glTypeInternal"},
        { "trigger": "ofTextureData::height"                                                            ,"contents": "${1:ofTextureData}.height"},
        { "trigger": "ofTextureData::pixelType"                                                         ,"contents": "${1:ofTextureData}.pixelType"},
        { "trigger": "ofTextureData::tex_h"                                                             ,"contents": "${1:ofTextureData}.tex_h"},
        { "trigger": "ofTextureData::tex_t"                                                             ,"contents": "${1:ofTextureData}.tex_t"},
        { "trigger": "ofTextureData::tex_u"                                                             ,"contents": "${1:ofTextureData}.tex_u"},
        { "trigger": "ofTextureData::tex_w"                                                             ,"contents": "${1:ofTextureData}.tex_w"},
        { "trigger": "ofTextureData::textureID"                                                         ,"contents": "${1:ofTextureData}.textureID"},
        { "trigger": "ofTextureData::textureTarget"                                                     ,"contents": "${1:ofTextureData}.textureTarget"},
        { "trigger": "ofTextureData::width"                                                             ,"contents": "${1:ofTextureData}.width"},
        ///////////////////////////
        // ofVbo
        // TODO 
        
        ///////////////////////////
        // ofVboMesh
        // TODO


        /////////////// VIDEO ////////////////////
        //////////////////////////////////////////
        // ofVideoGrabber
        { "trigger": "ofVideoGrabber \tinstance"                                   ,"contents": "ofVideoGrabber ${1:myVideoGrabber}"},
        { "trigger": "ofVideoGrabber::close"                                       ,"contents": "${1:ofVideoGrabber}.close()"},
        { "trigger": "ofVideoGrabber::draw(float, float, float, float)"            ,"contents": "${1:ofVideoGrabber}.draw(${2:float x}, ${3:float y}, ${4:float w}, ${5:float h})"},
        { "trigger": "ofVideoGrabber::draw(float, float)"                          ,"contents": "${1:ofVideoGrabber}.draw(${2:float x}, ${3:float y})"},
        { "trigger": "ofVideoGrabber::draw(const ofPoint)"                         ,"contents": "${1:ofVideoGrabber}.draw(${2:const ofPoint &p})"},
        { "trigger": "ofVideoGrabber::draw(const ofRectangle)"                     ,"contents": "${1:ofVideoGrabber}.draw(${2:const ofRectangle &r})"},
        { "trigger": "ofVideoGrabber::getGrabber"                                  ,"contents": "${1:ofVideoGrabber}.getGrabber()"},
        { "trigger": "ofVideoGrabber::getHeight"                                   ,"contents": "${1:ofVideoGrabber}.getHeight()"},
        { "trigger": "ofVideoGrabber::getPixelFormat"                              ,"contents": "${1:ofVideoGrabber}.getPixelFormat()"},
        { "trigger": "ofVideoGrabber::getPixels"                                   ,"contents": "${1:ofVideoGrabber}.getPixels()"},
        { "trigger": "ofVideoGrabber::getPixelsRef"                                ,"contents": "${1:ofVideoGrabber}.getPixelsRef()"},
        { "trigger": "ofVideoGrabber::getTextureReference"                         ,"contents": "${1:ofVideoGrabber}.getTextureReference()"},
        { "trigger": "ofVideoGrabber::getWidth"                                    ,"contents": "${1:ofVideoGrabber}.getWidth()"},
        { "trigger": "ofVideoGrabber::grabFrame"                                   ,"contents": "${1:ofVideoGrabber}.grabFrame()"},
        { "trigger": "ofVideoGrabber::initGrabber(int, int, bool)"                 ,"contents": "${1:ofVideoGrabber}.initGrabber(${2:int w}, ${3:int h}, ${4:bool bTexture})"},
        { "trigger": "ofVideoGrabber::initGrabber(int, int)"                       ,"contents": "${1:ofVideoGrabber}.initGrabber(${2:int w}, ${3:int h})"},
        { "trigger": "ofVideoGrabber::isFrameNew"                                  ,"contents": "${1:ofVideoGrabber}.isFrameNew()"},
        { "trigger": "ofVideoGrabber::isInitialized"                               ,"contents": "${1:ofVideoGrabber}.isInitialized()"},
        { "trigger": "ofVideoGrabber::listDevices"                                 ,"contents": "${1:ofVideoGrabber}.listDevices()"},
        { "trigger": "ofVideoGrabber::setAnchorPoint(float, float)"                ,"contents": "${1:ofVideoGrabber}.setAnchorPoint(${2:float x}, ${3:float y})"},
        { "trigger": "ofVideoGrabber::setDesiredFrameRate(int)"                    ,"contents": "${1:ofVideoGrabber}.setDesiredFrameRate(${2:int framerate})"},
        { "trigger": "ofVideoGrabber::setDeviceID(int)"                            ,"contents": "${1:ofVideoGrabber}.setDeviceID(${2:int _deviceID})"},
        { "trigger": "ofVideoGrabber::setGrabber(ofPtr< ofBaseVideoGrabber >)"     ,"contents": "${1:ofVideoGrabber}.setGrabber(${2:ofPtr< ofBaseVideoGrabber > newGrabber})"},
        { "trigger": "ofVideoGrabber::setPixelFormat(ofPixelFormat)"               ,"contents": "${1:ofVideoGrabber}.setPixelFormat(${2:ofPixelFormat pixelFormat})"},
        { "trigger": "ofVideoGrabber::setUseTexture(bool)"                         ,"contents": "${1:ofVideoGrabber}.setUseTexture(${2:bool bUse})"},
        { "trigger": "ofVideoGrabber::setVerbose(bool)"                            ,"contents": "${1:ofVideoGrabber}.setVerbose(${2:bool bTalkToMe})"},
        { "trigger": "ofVideoGrabber::update"                                      ,"contents": "${1:ofVideoGrabber}.update()"},
        { "trigger": "ofVideoGrabber::videoSettings"                               ,"contents": "${1:ofVideoGrabber}.videoSettings()"},
        { "trigger": "ofVideoGrabber::height"                                      ,"contents": "${1:ofVideoGrabber}.height"},
        { "trigger": "ofVideoGrabber::width"                                       ,"contents": "${1:ofVideoGrabber}.width"},

        /////////////////////////////////////
        // ofVideoPlayer
        { "trigger": "ofVideoPlayer \tinstance"                                          ,"contents": "ofVideoPlayer ${1:myVideoPlayer}"},
        { "trigger": "ofVideoPlayer::close"                                             ,"contents": "${1:ofVideoPlayer}.close()"},
        { "trigger": "ofVideoPlayer::closeMovie"                                        ,"contents": "${1:ofVideoPlayer}.closeMovie()"},
        { "trigger": "ofVideoPlayer::draw \t(float, float, float, float)"               ,"contents": "${1:ofVideoPlayer}.draw(${2:float x}, ${3:float y}, ${4:float w}, ${5:float h})"},
        { "trigger": "ofVideoPlayer::draw \t(float, float)"                             ,"contents": "${1:ofVideoPlayer}.draw(${2:float x}, ${3:float y})"},
        { "trigger": "ofVideoPlayer::draw \t(const ofPoint)"                            ,"contents": "${1:ofVideoPlayer}.draw(${2:const ofPoint &p})"},
        { "trigger": "ofVideoPlayer::draw \t(const ofRectangle)"                        ,"contents": "${1:ofVideoPlayer}.draw(${2:const ofRectangle &r})"},
        { "trigger": "ofVideoPlayer::firstFrame"                                        ,"contents": "${1:ofVideoPlayer}.firstFrame()"},
        { "trigger": "ofVideoPlayer::getCurrentFrame"                                   ,"contents": "${1:ofVideoPlayer}.getCurrentFrame()"},
        { "trigger": "ofVideoPlayer::getDuration"                                       ,"contents": "${1:ofVideoPlayer}.getDuration()"},
        { "trigger": "ofVideoPlayer::getHeight"                                         ,"contents": "${1:ofVideoPlayer}.getHeight()"},
        { "trigger": "ofVideoPlayer::getIsMovieDone"                                    ,"contents": "${1:ofVideoPlayer}.getIsMovieDone()"},
        { "trigger": "ofVideoPlayer::getLoopState"                                      ,"contents": "${1:ofVideoPlayer}.getLoopState()"},
        { "trigger": "ofVideoPlayer::getMoviePath"                                      ,"contents": "${1:ofVideoPlayer}.getMoviePath()"},
        { "trigger": "ofVideoPlayer::getPixelFormat"                                    ,"contents": "${1:ofVideoPlayer}.getPixelFormat()"},
        { "trigger": "ofVideoPlayer::getPixels"                                         ,"contents": "${1:ofVideoPlayer}.getPixels()"},
        { "trigger": "ofVideoPlayer::getPixelsRef"                                      ,"contents": "${1:ofVideoPlayer}.getPixelsRef()"},
        { "trigger": "ofVideoPlayer::getPlayer"                                         ,"contents": "${1:ofVideoPlayer}.getPlayer()"},
        { "trigger": "ofVideoPlayer::getPosition"                                       ,"contents": "${1:ofVideoPlayer}.getPosition()"},
        { "trigger": "ofVideoPlayer::getSpeed"                                          ,"contents": "${1:ofVideoPlayer}.getSpeed()"},
        { "trigger": "ofVideoPlayer::getTextureReference"                               ,"contents": "${1:ofVideoPlayer}.getTextureReference()"},
        { "trigger": "ofVideoPlayer::getTotalNumFrames"                                 ,"contents": "${1:ofVideoPlayer}.getTotalNumFrames()"},
        { "trigger": "ofVideoPlayer::getWidth"                                          ,"contents": "${1:ofVideoPlayer}.getWidth()"},
        { "trigger": "ofVideoPlayer::idleMovie"                                         ,"contents": "${1:ofVideoPlayer}.idleMovie()"},
        { "trigger": "ofVideoPlayer::isFrameNew"                                        ,"contents": "${1:ofVideoPlayer}.isFrameNew()"},
        { "trigger": "ofVideoPlayer::isLoaded"                                          ,"contents": "${1:ofVideoPlayer}.isLoaded()"},
        { "trigger": "ofVideoPlayer::isPaused"                                          ,"contents": "${1:ofVideoPlayer}.isPaused()"},
        { "trigger": "ofVideoPlayer::isPlaying"                                         ,"contents": "${1:ofVideoPlayer}.isPlaying()"},
        { "trigger": "ofVideoPlayer::loadMovie \t(string)"                              ,"contents": "${1:ofVideoPlayer}.loadMovie(${2:string name})"},
        { "trigger": "ofVideoPlayer::nextFrame"                                         ,"contents": "${1:ofVideoPlayer}.nextFrame()"},
        { "trigger": "ofVideoPlayer::play"                                              ,"contents": "${1:ofVideoPlayer}.play()"},
        { "trigger": "ofVideoPlayer::previousFrame"                                     ,"contents": "${1:ofVideoPlayer}.previousFrame()"},
        { "trigger": "ofVideoPlayer::setAnchorPoint \t(float, float)"                   ,"contents": "${1:ofVideoPlayer}.setAnchorPoint(${2:float x}, ${3:float y})"},
        { "trigger": "ofVideoPlayer::setFrame \t(int)"                                  ,"contents": "${1:ofVideoPlayer}.setFrame(${2:int frame})"},
        { "trigger": "ofVideoPlayer::setLoopState \t(int)"                              ,"contents": "${1:ofVideoPlayer}.setLoopState(${2:int state})"},
        { "trigger": "ofVideoPlayer::setLoopState \t(ofLoopType)"                       ,"contents": "${1:ofVideoPlayer}.setLoopState(${2:ofLoopType state})"},
        { "trigger": "ofVideoPlayer::setPaused \t(bool)"                                ,"contents": "${1:ofVideoPlayer}.setPaused(${2:bool bPause})"},
        { "trigger": "ofVideoPlayer::setPixelFormat \t(ofPixelFormat)"                  ,"contents": "${1:ofVideoPlayer}.setPixelFormat(${2:ofPixelFormat pixelFormat})"},
        { "trigger": "ofVideoPlayer::setPlayer \t(ofPtr< ofBaseVideoPlayer >)"          ,"contents": "${1:ofVideoPlayer}.setPlayer(${2:ofPtr< ofBaseVideoPlayer > newPlayer})"},
        { "trigger": "ofVideoPlayer::setPosition \t(float)"                             ,"contents": "${1:ofVideoPlayer}.setPosition(${2:float pct})"},
        { "trigger": "ofVideoPlayer::setSpeed \t(float)"                                ,"contents": "${1:ofVideoPlayer}.setSpeed(${2:float speed})"},
        { "trigger": "ofVideoPlayer::setUseTexture \t(bool)"                            ,"contents": "${1:ofVideoPlayer}.setUseTexture(${2:bool bUse})"},
        { "trigger": "ofVideoPlayer::setVolume \t(int)"                                 ,"contents": "${1:ofVideoPlayer}.setVolume(${2:int volume})"},
        { "trigger": "ofVideoPlayer::setVolume \t(float)"                               ,"contents": "${1:ofVideoPlayer}.setVolume(${2:float volume})"},
        { "trigger": "ofVideoPlayer::stop"                                              ,"contents": "${1:ofVideoPlayer}.stop()"},
        { "trigger": "ofVideoPlayer::update"                                            ,"contents": "${1:ofVideoPlayer}.update()"},
        { "trigger": "ofVideoPlayer::allocated"                                         ,"contents": "${1:ofVideoPlayer}.allocated"},
        { "trigger": "ofVideoPlayer::bHavePixelsChanged"                                ,"contents": "${1:ofVideoPlayer}.bHavePixelsChanged"},
        { "trigger": "ofVideoPlayer::bLoaded"                                           ,"contents": "${1:ofVideoPlayer}.bLoaded"},
        { "trigger": "ofVideoPlayer::bUseTexture"                                       ,"contents": "${1:ofVideoPlayer}.bUseTexture"},
        { "trigger": "ofVideoPlayer::height"                                            ,"contents": "${1:ofVideoPlayer}.height"},
        { "trigger": "ofVideoPlayer::nFrames"                                           ,"contents": "${1:ofVideoPlayer}.nFrames"},
        { "trigger": "ofVideoPlayer::pixels"                                            ,"contents": "${1:ofVideoPlayer}.pixels"},
        { "trigger": "ofVideoPlayer::speed"                                             ,"contents": "${1:ofVideoPlayer}.speed"},
        { "trigger": "ofVideoPlayer::tex"                                               ,"contents": "${1:ofVideoPlayer}.tex"},
        { "trigger": "ofVideoPlayer::width"                                             ,"contents": "${1:ofVideoPlayer}.width"},
        ///////////////////////////////////
        // ofLoopType
        { "trigger": "OF_LOOP_NONE \tloopType"            ,"contents": "OF_LOOP_NONE"},
        { "trigger": "OF_LOOP_NORMAL \tloopType"          ,"contents": "OF_LOOP_NORMAL"},
        { "trigger": "OF_LOOP_PALINDROME \tloopType"      ,"contents": "OF_LOOP_PALINDROME"},

        ///////////////// AUDIO /////////////////
        /////////////////////////////////////////
        // ofSoundPlayer


        /////////////////////////////////////
        // ofSoundStream

        ///////////////////////////
        // ofSerial
        { "trigger": "ofSerial \tinstance"                                  ,"contents": "ofSerial ${1:mySerial}"},
        { "trigger": "ofSerial::available"                                  ,"contents": "${1:ofSerial}.available()"},
        { "trigger": "ofSerial::close"                                      ,"contents": "${1:ofSerial}.close()"},
        { "trigger": "ofSerial::drain"                                      ,"contents": "${1:ofSerial}.drain()"},
        { "trigger": "ofSerial::enumerateDevices"                           ,"contents": "${1:ofSerial}.enumerateDevices()"},
        { "trigger": "ofSerial::flush \t(bool, bool)"                       ,"contents": "${1:ofSerial}.flush(${2:bool flushIn=true}, ${3:bool flushOut=true})"},
        { "trigger": "ofSerial::getDeviceList"                              ,"contents": "${1:ofSerial}.getDeviceList()"},
        { "trigger": "ofSerial::listDevices"                                ,"contents": "${1:ofSerial}.listDevices()"},
        { "trigger": "ofSerial::readByte"                                   ,"contents": "${1:ofSerial}.readByte()"},
        { "trigger": "ofSerial::readBytes \t(unsigned char, int)"           ,"contents": "${1:ofSerial}.readBytes(${2:unsigned char * buffer}, ${3:int length})"},
        { "trigger": "ofSerial::readBytes \t(unsigned char, int)"           ,"contents": "${1:ofSerial}.readBytes(${2:unsigned char *buffer}, ${3:int length})"},
        { "trigger": "ofSerial::setVerbose \t(bool)"                        ,"contents": "${1:ofSerial}.setVerbose(${2:bool bLoudmouth})"},
        { "trigger": "ofSerial::setup"                                      ,"contents": "${1:ofSerial}.setup()"},
        { "trigger": "ofSerial::setup \t(string, int)"                      ,"contents": "${1:ofSerial}.setup(${2:string portName}, ${3:int baudrate})"},
        { "trigger": "ofSerial::setup \t(int, int)"                         ,"contents": "${1:ofSerial}.setup(${2:int deviceNumber}, ${3:int baudrate})"},
        { "trigger": "ofSerial::writeByte \t(unsigned char)"                ,"contents": "${1:ofSerial}.writeByte(${2:unsigned char singleByte})"},
        { "trigger": "ofSerial::writeBytes \t(unsigned char, int)"          ,"contents": "${1:ofSerial}.writeBytes(${2:unsigned char * buffer}, ${3:int length})"},
        { "trigger": "ofSerial::writeBytes \t(unsigned char, int)"          ,"contents": "${1:ofSerial}.writeBytes(${2:unsigned char *buffer}, ${3:int length})"},


        /////////////////// MATH //////////////////
        //////////////////////////////////////////
        // ofMath
        { "trigger": "ofAngleDifferenceDegrees \t(float, float)"                                      ,"contents": "ofAngleDifferenceDegrees(${1:float currentAngle}, ${2:float targetAngle})"},
        { "trigger": "ofAngleDifferenceRadians \t(float, float)"                                      ,"contents": "ofAngleDifferenceRadians(${1:float currentAngle}, ${2:float targetAngle})"},
        { "trigger": "ofAngleSumRadians \t(float, float)"                                             ,"contents": "ofAngleSumRadians(${1:float currentAngle}, ${2:float targetAngle})"},
        { "trigger": "ofBezierPoint \t(ofPoint, ofPoint, ofPoint, ofPoint, float)"                    ,"contents": "ofBezierPoint(${1:ofPoint a}, ${2:ofPoint b}, ${3:ofPoint c}, ${4:ofPoint d}, ${5:float t})"},
        { "trigger": "ofBezierTangent \t(ofPoint, ofPoint, ofPoint, ofPoint, float)"                  ,"contents": "ofBezierTangent(${1:ofPoint a}, ${2:ofPoint b}, ${3:ofPoint c}, ${4:ofPoint d}, ${5:float t})"},
        { "trigger": "ofClamp \t(float, float, float)"                                                ,"contents": "ofClamp(${1:float value}, ${2:float min}, ${3:float max})"},
        { "trigger": "ofCurvePoint \t(ofPoint, ofPoint, ofPoint, ofPoint, float)"                     ,"contents": "ofCurvePoint(${1:ofPoint a}, ${2:ofPoint b}, ${3:ofPoint c}, ${4:ofPoint d}, ${5:float t})"},
        { "trigger": "ofCurveTangent \t(ofPoint, ofPoint, ofPoint, ofPoint, float)"                   ,"contents": "ofCurveTangent(${1:ofPoint a}, ${2:ofPoint b}, ${3:ofPoint c}, ${4:ofPoint d}, ${5:float t})"},
        { "trigger": "ofDegToRad \t(float)"                                                           ,"contents": "ofDegToRad(${1:float degrees})"},
        { "trigger": "ofDist \t(float, float, float, float)"                                          ,"contents": "ofDist(${1:float x1}, ${2:float y1}, ${3:float x2}, ${4:float y2})"},
        { "trigger": "ofDistSquared \t(float, float, float, float)"                                   ,"contents": "ofDistSquared(${1:float x1}, ${2:float y1}, ${3:float x2}, ${4:float y2})"},
        { "trigger": "ofInRange \t(float, float, float)"                                              ,"contents": "ofInRange(${1:float t}, ${2:float min}, ${3:float max})"},
        { "trigger": "ofInsidePoly \t(float, float, const vector< ofPoint >)"                         ,"contents": "ofInsidePoly(${1:float x}, ${2:float y}, ${3:const vector< ofPoint > &poly})"},
        { "trigger": "ofInsidePoly \t(const ofPoint, const vector< ofPoint >)"                        ,"contents": "ofInsidePoly(${1:const ofPoint &p}, ${2:const vector< ofPoint > &poly})"},
        { "trigger": "ofLerp \t(float, float, float)"                                                 ,"contents": "ofLerp(${1:float start}, ${2:float stop}, ${3:float amt})"},
        { "trigger": "ofLerpDegrees \t(float, float, float)"                                          ,"contents": "ofLerpDegrees(${1:float currentAngle}, ${2:float targetAngle}, ${3:float pct})"},
        { "trigger": "ofLerpRadians \t(float, float, float)"                                          ,"contents": "ofLerpRadians(${1:float currentAngle}, ${2:float targetAngle}, ${3:float pct})"},
        { "trigger": "ofLineSegmentIntersection \t(ofPoint, ofPoint, ofPoint, ofPoint, ofPoint)"      ,"contents": "ofLineSegmentIntersection(${1:ofPoint line1Start}, ${2:ofPoint line1End}, ${3:ofPoint line2Start}, ${4:ofPoint line2End}, ${5:ofPoint &intersection})"},
        { "trigger": "ofMap \t(float, float, float, float, float)"                                    ,"contents": "ofMap(${1:float value}, ${2:float inputMin}, ${3:float inputMax}, ${4:float outputMin}, ${5:float outputMax})"},
        { "trigger": "ofMap \t(float, float, float, float, float, bool)"                              ,"contents": "ofMap(${1:float value}, ${2:float inputMin}, ${3:float inputMax}, ${4:float outputMin}, ${5:float outputMax}, ${6:bool clamp=false})"},
        { "trigger": "ofNextPow2 \t(int)"                                                             ,"contents": "ofNextPow2(${1:int a})"},
        { "trigger": "ofNoise \t(float)"                                                              ,"contents": "ofNoise(${1:float x})"},
        { "trigger": "ofNoise \t(float, float)"                                                       ,"contents": "ofNoise(${1:float x}, ${2:float y})"},
        { "trigger": "ofNoise \t(float, float, float)"                                                ,"contents": "ofNoise(${1:float x}, ${2:float y}, ${3:float z})"},
        { "trigger": "ofNoise \t(float, float, float, float)"                                         ,"contents": "ofNoise(${1:float x}, ${2:float y}, ${3:float z}, ${4:float w})"},
        { "trigger": "ofNormalize \t(float, float, float)"                                            ,"contents": "ofNormalize(${1:float value}, ${2:float min}, ${3:float max})"},
        { "trigger": "ofRadToDeg \t(float)"                                                           ,"contents": "ofRadToDeg(${1:float radians})"},
        { "trigger": "ofRandom \t(float, float)"                                                      ,"contents": "ofRandom(${1:float val0}, ${2:float val1})"},
        { "trigger": "ofRandom \t(float)"                                                             ,"contents": "ofRandom(${1:float max})"},
        { "trigger": "ofRandomHeight"                                                                 ,"contents": "ofRandomHeight()"},
        { "trigger": "ofRandomWidth"                                                                  ,"contents": "ofRandomWidth()"},
        { "trigger": "ofRandomf"                                                                      ,"contents": "ofRandomf()"},
        { "trigger": "ofRandomuf"                                                                     ,"contents": "ofRandomuf()"},
        { "trigger": "ofSeedRandom"                                                                   ,"contents": "ofSeedRandom()"},
        { "trigger": "ofSeedRandom \t(int)"                                                           ,"contents": "ofSeedRandom(${1:int val})"},
        { "trigger": "ofSign \t(float)"                                                               ,"contents": "ofSign(${1:float n})"},
        { "trigger": "ofSignedNoise \t(float)"                                                        ,"contents": "ofSignedNoise(${1:float x})"},
        { "trigger": "ofSignedNoise \t(float, float)"                                                 ,"contents": "ofSignedNoise(${1:float x}, ${2:float y})"},
        { "trigger": "ofSignedNoise \t(float, float, float)"                                          ,"contents": "ofSignedNoise(${1:float x}, ${2:float y}, ${3:float z})"},
        { "trigger": "ofSignedNoise \t(float, float, float, float)"                                   ,"contents": "ofSignedNoise(${1:float x}, ${2:float y}, ${3:float z}, ${4:float w})"},
        { "trigger": "ofWrapDegrees \t(float, float, float)"                                          ,"contents": "ofWrapDegrees(${1:float angle}, ${2:float from=-180}, ${3:float to=+180})"},
        { "trigger": "ofWrapRadians \t(float, float, float)"                                          ,"contents": "ofWrapRadians(${1:float angle}, ${2:float from=-PI}, ${3:float to=+PI})"},

        /////////////////////////////////////
        // ofMatrix3x3

        /////////////////////////////////////
        // ofMatrix4x4

        /////////////////////////////////////
        // ofQuaternion

        /////////////////////////////////////
        // ofVec2f

        /////////////////////////////////////
        // ofVec3f

        /////////////////////////////////////
        // ofVec4f


        ///////////////////// UTILS /////////////////////////
        ////////////////////////////////////////////////////
        // ofBuffer

        /////////////////////////////////////
        // ofDirectory

        /////////////////////////////////////
        // ofFile
        { "trigger": "ofFile \tinstance"                                                ,"contents": "ofFile ${1:myFile}"},
        { "trigger": "ofFile::canExecute"                                               ,"contents": "${1:ofFile}.canExecute()"},
        { "trigger": "ofFile::canRead"                                                  ,"contents": "${1:ofFile}.canRead()"},
        { "trigger": "ofFile::canWrite"                                                 ,"contents": "${1:ofFile}.canWrite()"},
        { "trigger": "ofFile::changeMode \t(Mode, bool)"                                ,"contents": "${1:ofFile}.changeMode(${2:Mode mode}, ${3:bool binary=false})"},
        { "trigger": "ofFile::close"                                                    ,"contents": "${1:ofFile}.close()"},
        { "trigger": "ofFile::copyFromTo \t(string, string, bool, bool)"                ,"contents": "${1:ofFile}.copyFromTo({$2:string pathSrc}, ${3:string pathDst}, ${4:bool bRelativeToData=true},${5: bool overwrite=false})"},
        { "trigger": "ofFile::copyTo \t(string, bool, bool)"                            ,"contents": "${1:ofFile}.copyTo(${2:string path}, ${3:bool bRelativeToData=true}, ${4:bool overwrite=false})"},
        { "trigger": "ofFile::create"                                                   ,"contents": "${1:ofFile}.create()"},
        { "trigger": "ofFile::doesFileExist \t(string, bool)"                           ,"contents": "${1:ofFile}.doesFileExist(${2:string fPath}, ${3:bool bRelativeToData=true})"},
        { "trigger": "ofFile::exists"                                                   ,"contents": "${1:ofFile}.exists()"},
        { "trigger": "ofFile::getAbsolutePath"                                          ,"contents": "${1:ofFile}.getAbsolutePath()"},
        { "trigger": "ofFile::getBaseName"                                              ,"contents": "${1:ofFile}.getBaseName()"},
        { "trigger": "ofFile::getEnclosingDirectory"                                    ,"contents": "${1:ofFile}.getEnclosingDirectory()"},
        { "trigger": "ofFile::getExtension"                                             ,"contents": "${1:ofFile}.getExtension()"},
        { "trigger": "ofFile::getFileBuffer"                                            ,"contents": "${1:ofFile}.getFileBuffer()"},
        { "trigger": "ofFile::getFileName"                                              ,"contents": "${1:ofFile}.getFileName()"},
        { "trigger": "ofFile::getPocoFile"                                              ,"contents": "${1:ofFile}.getPocoFile()"},
        { "trigger": "ofFile::getSize"                                                  ,"contents": "${1:ofFile}.getSize()"},
        { "trigger": "ofFile::isDevice"                                                 ,"contents": "${1:ofFile}.isDevice()"},
        { "trigger": "ofFile::isDirectory"                                              ,"contents": "${1:ofFile}.isDirectory()"},
        { "trigger": "ofFile::isFile"                                                   ,"contents": "${1:ofFile}.isFile()"},
        { "trigger": "ofFile::isHidden"                                                 ,"contents": "${1:ofFile}.isHidden()"},
        { "trigger": "ofFile::isLink"                                                   ,"contents": "${1:ofFile}.isLink()"},
        { "trigger": "ofFile::moveFromTo \t(string, string, bool, bool)"                ,"contents": "${1:ofFile}.moveFromTo(${2:string pathSrc}, ${3:string pathDst}, ${4:bool bRelativeToData=true}, ${5:bool overwrite=false})"},
        { "trigger": "ofFile::moveTo \t(string, bool, bool)"                            ,"contents": "${1:ofFile}.moveTo(${2:string path}, ${3:bool bRelativeToData=true}, ${4:bool overwrite=false})"},
        { "trigger": "ofFile::open \t(string, Mode, bool)"                              ,"contents": "${1:ofFile}.open(${2:string path}, ${3:Mode mode=ReadOnly}, ${4:bool binary=false})"},
        { "trigger": "ofFile::path"                                                     ,"contents": "${1:ofFile}.path()"},
        { "trigger": "ofFile::readToBuffer"                                             ,"contents": "${1:ofFile}.readToBuffer()"},
        { "trigger": "ofFile::remove \t(bool)"                                          ,"contents": "${1:ofFile}.remove(${2:bool recursive=false})"},
        { "trigger": "ofFile::removeFile \t(string, bool)"                              ,"contents": "${1:ofFile}.removeFile(${2:string path}, ${3:bool bRelativeToData=true})"},
        { "trigger": "ofFile::renameTo \t(string, bool, bool)"                          ,"contents": "${1:ofFile}.renameTo(${2:string path}, ${3:bool bRelativeToData=true}, ${4:bool overwrite=false})"},
        { "trigger": "ofFile::setExecutable \t(bool)"                                   ,"contents": "${1:ofFile}.setExecutable(${2:bool executable})"},
        { "trigger": "ofFile::setReadOnly \t(bool)"                                     ,"contents": "${1:ofFile}.setReadOnly(${2:bool readable})"},
        { "trigger": "ofFile::setWriteable \t(bool)"                                    ,"contents": "${1:ofFile}.setWriteable(${2:bool writeable})"},
        { "trigger": "ofFile::writeFromBuffer \t(ofBuffer)"                             ,"contents": "${1:ofFile}.writeFromBuffer(${2:ofBuffer &buffer})"},
        /////////////////////////////////////
        // ofFileDialogResult
        { "trigger": "ofFileDialogResult::getName"                     ,"contents": "${1:ofFileDialogResult}.getName()"},
        { "trigger": "ofFileDialogResult::getPath"                     ,"contents": "${1:ofFileDialogResult}.getPath()"},
        { "trigger": "ofFileDialogResult::bSuccess"                    ,"contents": "${1:ofFileDialogResult}.bSuccess"},
        { "trigger": "ofFileDialogResult::fileName"                    ,"contents": "${1:ofFileDialogResult}.fileName"},
        { "trigger": "ofFileDialogResult::filePath"                    ,"contents": "${1:ofFileDialogResult}.filePath"},
        /////////////////////////////////////
        // ofFilePath
        { "trigger": "ofFilePath::addLeadingSlash(string)"                                  ,"contents": "${1:ofFilePath}.addLeadingSlash(${2:string path})"},
        { "trigger": "ofFilePath::addTrailingSlash(string)"                                 ,"contents": "${1:ofFilePath}.addTrailingSlash(${2:string path})"},
        { "trigger": "ofFilePath::getAbsolutePath(string, bool)"                            ,"contents": "${1:ofFilePath}.getAbsolutePath(${2:string path}, ${3:bool bRelativeToData=true})"},
        { "trigger": "ofFilePath::getBaseName(string)"                                      ,"contents": "${1:ofFilePath}.getBaseName(${2:string filePath})"},
        { "trigger": "ofFilePath::getCurrentExeDir"                                         ,"contents": "${1:ofFilePath}.getCurrentExeDir()"},
        { "trigger": "ofFilePath::getCurrentExePath"                                        ,"contents": "${1:ofFilePath}.getCurrentExePath()"},
        { "trigger": "ofFilePath::getCurrentWorkingDirectory"                               ,"contents": "${1:ofFilePath}.getCurrentWorkingDirectory()"},
        { "trigger": "ofFilePath::getEnclosingDirectory(string, bool)"                      ,"contents": "${1:ofFilePath}.getEnclosingDirectory(${2:string filePath}, ${3:bool bRelativeToData=true})"},
        { "trigger": "ofFilePath::getFileExt(string)"                                       ,"contents": "${1:ofFilePath}.getFileExt(${2:string filename})"},
        { "trigger": "ofFilePath::getFileName(string, bool)"                                ,"contents": "${1:ofFilePath}.getFileName(${2:string filePath}, ${3:bool bRelativeToData=true})"},
        { "trigger": "ofFilePath::getPathForDirectory(string)"                              ,"contents": "${1:ofFilePath}.getPathForDirectory(${2:string path})"},
        { "trigger": "ofFilePath::getUserHomeDir"                                           ,"contents": "${1:ofFilePath}.getUserHomeDir()"},
        { "trigger": "ofFilePath::isAbsolute(string)"                                       ,"contents": "${1:ofFilePath}.isAbsolute(${2:string path})"},
        { "trigger": "ofFilePath::join(string, string)"                                     ,"contents": "${1:ofFilePath}.join(${2:string path1}, ${3:string path2})"},
        { "trigger": "ofFilePath::removeExt(string)"                                        ,"contents": "${1:ofFilePath}.removeExt(${2:string filename})"},
        { "trigger": "ofFilePath::removeTrailingSlash(string)"                              ,"contents": "${1:ofFilePath}.removeTrailingSlash(${2:string path})"},
        /////////////////////////////////////
        // ofFileUtils
        { "trigger": "ofBufferFromFile \t(const string, bool)"             ,"contents": "ofBufferFromFile(${1:const string &path}, ${2:bool binary=false})"},
        { "trigger": "ofBufferToFile \t(const string, ofBuffer, bool)"     ,"contents": "ofBufferToFile(${1:const string &path}, ${2:ofBuffer &buffer}, ${3:bool binary=false})"},

        /////////////////////////////////////
        // ofHttpRequest
        // ofHttpRequest methods
        { "trigger": "ofHttpRequest::getID"                                     ,"contents": "${1:ofHttpRequest}.getID()"},
        { "trigger": "ofHttpRequest::name"                                      ,"contents": "${1:ofHttpRequest}.name"},
        { "trigger": "ofHttpRequest::saveTo"                                    ,"contents": "${1:ofHttpRequest}.saveTo"},
        { "trigger": "ofHttpRequest::url"                                       ,"contents": "${1:ofHttpRequest}.url"},
        /////////////////////////////////////
        // ofHttpResponse
        // ofHttpResponse variables
        { "trigger": "ofHttpResponse::data"                                     ,"contents": "ofHttpResponse::data"},
        { "trigger": "ofHttpResponse::error"                                    ,"contents": "ofHttpResponse::error"},
        { "trigger": "ofHttpResponse::request"                                  ,"contents": "ofHttpResponse::request"},
        { "trigger": "ofHttpResponse::status"                                   ,"contents": "ofHttpResponse::status"},
        /////////////////////////////////////
        // ofLog
        // log levels
        { "trigger": "OF_LOG_VERBOSE \tlogLevel"                                    ,"contents": "OF_LOG_VERBOSE"},
        { "trigger": "OF_LOG_NOTICE \tlogLevel"                                     ,"contents": "OF_LOG_NOTICE"},
        { "trigger": "OF_LOG_WARNING \tlogLevel"                                    ,"contents": "OF_LOG_WARNING"},
        { "trigger": "OF_LOG_ERROR \tlogLevel"                                      ,"contents": "OF_LOG_ERROR"},
        { "trigger": "OF_LOG_FATAL_ERROR \tlogLevel"                                ,"contents": "OF_LOG_FATAL_ERROR"},
        { "trigger": "OF_LOG_SILENT \tlogLevel"                                     ,"contents": "OF_LOG_SILENT"},

        // ofLog methods
        { "trigger": "ofLog::setAutoSpace \t(bool)"                             ,"contents": "ofLog::setAutoSpace(bool autoSpace)"},
        { "trigger": "ofLog::setChannel \t(ofPtr< ofBaseLoggerChannel >)"       ,"contents": "ofLog::setChannel(ofPtr< ofBaseLoggerChannel > channel)"},


        // ofLog functions
        { "trigger": "ofLogLevel \tinstance"                                            ,"contents": "ofLogLevel logLevel;"},
        { "trigger": "ofGetLogLevel"                                                    ,"contents": "ofGetLogLevel()"},
        { "trigger": "ofGetLogLevelName \t(ofLogLevel)"                                 ,"contents": "ofGetLogLevelName(${1:ofLogLevel level})"},
        { "trigger": "ofLogToConsole"                                                   ,"contents": "ofLogToConsole()"},
        { "trigger": "ofLogToFile \t(const string, bool)"                               ,"contents": "ofLogToFile(${1:const string &path}, ${2:bool append=false})"},
        { "trigger": "ofSetLogLevel \t(ofLogLevel)"                                     ,"contents": "ofSetLogLevel(${1:ofLogLevel logLevel})"},
        { "trigger": "ofSetLogLevel \t(string, ofLogLevel)"                             ,"contents": "ofSetLogLevel(${1:string module}, ${2:ofLogLevel logLevel})"},
        { "trigger": "ofSetLoggerChannel \t(ofPtr< ofBaseLoggerChannel >)"              ,"contents": "ofSetLoggerChannel(${1:ofPtr< ofBaseLoggerChannel > loggerChannel})"},
        /////////////////////////////////////
        // ofSystemUtils

        /////////////////////////////////////
        // ofThread

        /////////////////////////////////////
        // ofURLFileLoader
        // ofURLFileLoader methods
        { "trigger": "ofURLFileLoader::clear"                                               ,"contents": "${1:ofURLFileLoader}.clear()"},
        { "trigger": "ofURLFileLoader::get \t(string)"                                      ,"contents": "${1:ofURLFileLoader}.get(string url)"},
        { "trigger": "ofURLFileLoader::getAsync \t(string, string)"                         ,"contents": "${1:ofURLFileLoader}.getAsync(${2:string url}, ${3:string name='$4'})"},
        { "trigger": "ofURLFileLoader::remove \t(int)"                                      ,"contents": "${1:ofURLFileLoader}.remove(${2:int id})"},
        { "trigger": "ofURLFileLoader::saveAsync \t(string, string)"                        ,"contents": "${1:ofURLFileLoader}.saveAsync(${2:string url}, ${3:string path})"},
        { "trigger": "ofURLFileLoader::saveTo \t(string, string)"                           ,"contents": "${1:ofURLFileLoader}.saveTo(${2:string url}, ${3:string path})"},
        // ofURLFileLoader functions
        { "trigger": "ofLoadURL \t(string)"                                                     ,"contents": "ofLoadURL(${1:string url})"},
        { "trigger": "ofLoadURLAsync \t(string, string)"                                        ,"contents": "ofLoadURLAsync(${1:string url}, ${2:string name='$3'})"},
        { "trigger": "ofRegisterURLNotification \t(T)"                                          ,"contents": "ofRegisterURLNotification(${1:T *obj})"},
        { "trigger": "ofRemoveAllURLRequests"                                                   ,"contents": "ofRemoveAllURLRequests()"},
        { "trigger": "ofRemoveURLRequest \t(int)"                                               ,"contents": "ofRemoveURLRequest(${1:int id})"},
        { "trigger": "ofSaveURLAsync \t(string, string)"                                        ,"contents": "ofSaveURLAsync(${2:string url}, ${3:string path})"},
        { "trigger": "ofSaveURLTo \t(string, string)"                                           ,"contents": "ofSaveURLTo(${2:string url}, ${3:string path})"},
        { "trigger": "ofUnregisterURLNotification \t(T)"                                        ,"contents": "ofUnregisterURLNotification(${2:T *obj})"},
        /////////////////////////////////////
        // ofUtils
        /////////////////////////////////////
        // ofUtils
        { "trigger": "ofBinaryToChar \t(const string)"                                    ,"contents": "ofBinaryToChar(${1:const string &value})"},
        { "trigger": "ofBinaryToFloat \t(const string)"                                   ,"contents": "ofBinaryToFloat(${1:const string &value})"},
        { "trigger": "ofBinaryToInt \t(const string)"                                     ,"contents": "ofBinaryToInt(${1:const string &value})"},
        { "trigger": "ofBinaryToString \t(const string)"                                  ,"contents": "ofBinaryToString(${1:const string &value})"},
        { "trigger": "ofContains \t(const vector< T >, const T)"                          ,"contents": "ofContains(${1:const vector< T > &values}, ${2:const T &target})"},
        { "trigger": "ofFind \t(const vector< T >, const T)"                              ,"contents": "ofFind(${1:const vector< T > &values}, ${2:const T &target})"},
        { "trigger": "ofGetDay"                                                           ,"contents": "ofGetDay()"},
        { "trigger": "ofGetElapsedTimeMicros"                                             ,"contents": "ofGetElapsedTimeMicros()"},
        { "trigger": "ofGetElapsedTimeMillis"                                             ,"contents": "ofGetElapsedTimeMillis()"},
        { "trigger": "ofGetElapsedTimef"                                                  ,"contents": "ofGetElapsedTimef()"},
        { "trigger": "ofGetFrameNum"                                                      ,"contents": "ofGetFrameNum()"},
        { "trigger": "ofGetHours"                                                         ,"contents": "ofGetHours()"},
        { "trigger": "ofGetMinutes"                                                       ,"contents": "ofGetMinutes()"},
        { "trigger": "ofGetMonth"                                                         ,"contents": "ofGetMonth()"},
        { "trigger": "ofGetSeconds"                                                       ,"contents": "ofGetSeconds()"},
        { "trigger": "ofGetSystemTimeMicros"                                              ,"contents": "ofGetSystemTimeMicros()"},
        { "trigger": "ofGetTargetPlatform"                                                ,"contents": "ofGetTargetPlatform()"},
        { "trigger": "ofGetTimestampString"                                               ,"contents": "ofGetTimestampString()"},
        { "trigger": "ofGetTimestampString \t(string)"                                    ,"contents": "ofGetTimestampString(${1:string timestampFormat})"},
        { "trigger": "ofGetUnixTime"                                                      ,"contents": "ofGetUnixTime()"},
        { "trigger": "ofGetVersionInfo"                                                   ,"contents": "ofGetVersionInfo()"},
        { "trigger": "ofGetWeekday"                                                       ,"contents": "ofGetWeekday()"},
        { "trigger": "ofGetYear"                                                          ,"contents": "ofGetYear()"},
        { "trigger": "ofHexToChar \t(const string)"                                       ,"contents": "ofHexToChar(${1:const string &charHexString})"},
        { "trigger": "ofHexToFloat \t(const string)"                                      ,"contents": "ofHexToFloat(${1:const string &floatHexString})"},
        { "trigger": "ofHexToInt \t(const string)"                                        ,"contents": "ofHexToInt(${1:const string &intHexString})"},
        { "trigger": "ofHexToString \t(const string)"                                     ,"contents": "ofHexToString(${1:const string &stringHexString})"},
        { "trigger": "ofIsStringInString \t(string, string)"                              ,"contents": "ofIsStringInString(${1:string haystack}, ${2:string needle})"},
        { "trigger": "ofJoinString \t(vector< string >, const string)"                    ,"contents": "ofJoinString(${1:vector< string > stringElements}, ${2:const string &delimiter})"},
        { "trigger": "ofLaunchBrowser \t(string)"                                         ,"contents": "ofLaunchBrowser(${1:string url})"},
        { "trigger": "ofNextPow2 \t(int)"                                                 ,"contents": "ofNextPow2(${1:int input})"},
        { "trigger": "ofRandomize \t(vector< T >)"                                        ,"contents": "ofRandomize(${1:vector< T > &values})"},
        { "trigger": "ofRemove \t(vector< T >, BoolFunction)"                             ,"contents": "ofRemove(${1:vector< T > &values}, ${2:BoolFunction shouldErase})"},
        { "trigger": "ofResetElapsedTimeCounter"                                          ,"contents": "ofResetElapsedTimeCounter()"},
        { "trigger": "ofSaveFrame"                                                        ,"contents": "ofSaveFrame()"},
        { "trigger": "ofSaveFrame \t(bool)"                                               ,"contents": "ofSaveFrame(${1:bool bUseViewport=false})"},
        { "trigger": "ofSaveScreen \t(string)"                                            ,"contents": "ofSaveScreen(${1:string filename})"},
        { "trigger": "ofSaveViewport \t(string)"                                          ,"contents": "ofSaveViewport(${1:string filename})"},
        { "trigger": "ofSetDataPathRoot \t(string)"                                       ,"contents": "ofSetDataPathRoot(${1:string root})"},
        { "trigger": "ofSort \t(vector< T >)"                                             ,"contents": "ofSort(${1:vector< T > &values})"},
        { "trigger": "ofSort \t(vector< T >, BoolFunction)"                               ,"contents": "ofSort(${1:vector< T > &values}, ${2:BoolFunction compare})"},
        { "trigger": "ofSplitString \t(const string&, const string&)"                     ,"contents": "ofSplitString(${1:const string& str}, ${2:const string& delimiter = '$3'})"},
        { "trigger": "ofSplitString \t(const string, const string, bool, bool)"           ,"contents": "ofSplitString(${1:const string &source}, ${2:const string &delimiter}, ${3:bool ignoreEmpty=false}, ${4:bool trim=false})"},
        { "trigger": "ofStringReplace \t(string, string, string)"                         ,"contents": "ofStringReplace(${1:string &input}, ${2:string searchStr}, ${3:string replaceStr})"},
        { "trigger": "ofSystem \t(string)"                                                ,"contents": "ofSystem(${1:string command})"},
        { "trigger": "ofToBinary \t(const T)"                                             ,"contents": "ofToBinary(${1:const T &value})"},
        { "trigger": "ofToBinary \t(const string)"                                        ,"contents": "ofToBinary(${1:const string &value})"},
        { "trigger": "ofToBinary \t(const char)"                                          ,"contents": "ofToBinary(${1:const char *value})"},
        { "trigger": "ofToBool \t(const string)"                                          ,"contents": "ofToBool(${1:const string &boolString})"},
        { "trigger": "ofToChar \t(const string)"                                          ,"contents": "ofToChar(${1:const string &charString})"},
        { "trigger": "ofToDataPath \t(string, bool)"                                      ,"contents": "ofToDataPath(${1:string path}, ${2:bool absolute=false})"},
        { "trigger": "ofToFloat \t(const string&)"                                        ,"contents": "ofToFloat(${1:const string& floatString})"},
        { "trigger": "ofToFloat \t(const string)"                                         ,"contents": "ofToFloat(${1:const string &floatString})"},
        { "trigger": "ofToHex \t(const T)"                                                ,"contents": "ofToHex(${1:const T &value})"},
        { "trigger": "ofToHex \t(const string)"                                           ,"contents": "ofToHex(${1:const string &value})"},
        { "trigger": "ofToHex \t(const char)"                                             ,"contents": "ofToHex(${1:const char *value})"},
        { "trigger": "ofToInt \t(const string&)"                                          ,"contents": "ofToInt(${1:const string& intString})"},
        { "trigger": "ofToInt \t(const string)"                                           ,"contents": "ofToInt(${1:const string &intString})"},
        { "trigger": "ofToLower \t(const string)"                                         ,"contents": "ofToLower(${1:const string &src})"},
        { "trigger": "ofToString \t(int)"                                                 ,"contents": "ofToString({int value})"},
        { "trigger": "ofToString \t(const T)"                                             ,"contents": "ofToString(${1:const T &value})"},
        { "trigger": "ofToString \t(const T, int)"                                        ,"contents": "ofToString(${1:const T &value, int precision})"},
        { "trigger": "ofToString \t(const vector< T >)"                                   ,"contents": "ofToString(${1:const vector< T > &values})"},
        { "trigger": "ofToString \t(const T, int, char)"                                  ,"contents": "ofToString(${1:const T &value}, ${2:int width}, ${3:char fill})"},
        { "trigger": "ofToString \t(const T, int, int, char)"                             ,"contents": "ofToString(${1:const T &value}, ${2:int precision}, ${3:int width}, ${4:char fill})"},
        { "trigger": "ofToUpper \t(const string)"                                         ,"contents": "ofToUpper(${1:const string &src})"},
        { "trigger": "ofVAArgsToString \t(const char, ...)"                               ,"contents": "ofVAArgsToString(${1:const char *format},${2:...})"},
        { "trigger": "ofVAArgsToString \t(const char, va_list)"                           ,"contents": "ofVAArgsToString(${1:const char *format}, ${2:va_list args})"},

        ///////////////////// OFX ADDONS //////////////////////
        //////////////////////////////////////////////////////
        // ofxXmlSettings methods
        { "trigger": "ofxXmlSettings::addAttribute \t(const string, const string, int, int)"                ,"contents": "${1:ofxXmlSettings}.addAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:int value}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::addAttribute \t(const string, const string, double, int)"             ,"contents": "${1:ofxXmlSettings}.addAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:double value}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::addAttribute \t(const string, const string, const string, int)"       ,"contents": "${1:ofxXmlSettings}.addAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:const string &value}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::addAttribute \t(const string, const string, int)"                     ,"contents": "${1:ofxXmlSettings}.addAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:int value})"},
        { "trigger": "ofxXmlSettings::addAttribute \t(const string, const string, double)"                  ,"contents": "${1:ofxXmlSettings}.addAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:double value})"},
        { "trigger": "ofxXmlSettings::addAttribute \t(const string, const string, const string)"            ,"contents": "${1:ofxXmlSettings}.addAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:const string &value})"},
        { "trigger": "ofxXmlSettings::addTag \t(const string)"                                              ,"contents": "${1:ofxXmlSettings}.addTag(${2:const string &tag})"},
        { "trigger": "ofxXmlSettings::addValue \t(const string, int)"                                       ,"contents": "${1:ofxXmlSettings}.addValue(${2:const string &tag}, ${3:int value})"},
        { "trigger": "ofxXmlSettings::addValue \t(const string, double)"                                    ,"contents": "${1:ofxXmlSettings}.addValue(${2:const string &tag}, ${3:double value})"},
        { "trigger": "ofxXmlSettings::addValue \t(const string, const string)"                              ,"contents": "${1:ofxXmlSettings}.addValue(${2:const string &tag}, ${3:const string &value})"},
        { "trigger": "ofxXmlSettings::attributeExists \t(const string, const string, int)"                  ,"contents": "${1:ofxXmlSettings}.attributeExists(${2:const string &tag}, ${3:const string &attribute}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::clear"                                                                ,"contents": "${1:ofxXmlSettings}.clear()"},
        { "trigger": "ofxXmlSettings::clearTagAttributes \t(const string, int)"                             ,"contents": "${1:ofxXmlSettings}.clearTagAttributes(${2:const string &tag}, ${3:int which=0})"},
        { "trigger": "ofxXmlSettings::clearTagContents \t(const string, int)"                               ,"contents": "${1:ofxXmlSettings}.clearTagContents(${2:const string &tag}, ${3:int which=0})"},
        { "trigger": "ofxXmlSettings::copyXmlToString \t(string)"                                           ,"contents": "${1:ofxXmlSettings}.copyXmlToString(${2:string &str})"},
        { "trigger": "ofxXmlSettings::getAttribute \t(const string, const string, int, int)"                ,"contents": "${1:ofxXmlSettings}.getAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:int defaultValue}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::getAttribute \t(const string, const string, double, int)"             ,"contents": "${1:ofxXmlSettings}.getAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:double defaultValue}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::getAttribute \t(const string, const string, const string, int)"       ,"contents": "${1:ofxXmlSettings}.getAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:const string &defaultValue}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::getAttributeNames \t(const string, vector< string >, int)"            ,"contents": "${1:ofxXmlSettings}.getAttributeNames(${2:const string &tag}, ${3:vector< string > &outNames}, ${:4int which=0})"},
        { "trigger": "ofxXmlSettings::getNumAttributes \t(const string, int)"                               ,"contents": "${1:ofxXmlSettings}.getNumAttributes(${2:const string &tag}, ${3:int which=0})"},
        { "trigger": "ofxXmlSettings::getNumTags \t(const string)"                                          ,"contents": "${1:ofxXmlSettings}.getNumTags(${2:const string &tag})"},
        { "trigger": "ofxXmlSettings::getPushLevel"                                                         ,"contents": "${1:ofxXmlSettings}.getPushLevel()"},
        { "trigger": "ofxXmlSettings::getValue \t(const string, int , int)"                                 ,"contents": "${1:ofxXmlSettings}.getValue(${2:const string &tag}, ${3:int defaultValue}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::getValue \t(const string, double, int)"                               ,"contents": "${1:ofxXmlSettings}.getValue(${2:const string &tag}, ${3:double defaultValue}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::getValue \t(const string, const string, int)"                         ,"contents": "${1:ofxXmlSettings}.getValue(${2:const string &tag}, ${3:const string &defaultValue}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::loadFile \t(const string)"                                            ,"contents": "${1:ofxXmlSettings}.loadFile(${2:const string &xmlFile})"},
        { "trigger": "ofxXmlSettings::loadFromBuffer \t(string)"                                            ,"contents": "${1:ofxXmlSettings}.loadFromBuffer({$2:string buffer})"},
        { "trigger": "ofxXmlSettings::popTag"                                                               ,"contents": "${1:ofxXmlSettings}.popTag()"},
        { "trigger": "ofxXmlSettings::pushTag \t(const string, int)"                                        ,"contents": "${1:ofxXmlSettings}.pushTag(${2:const string &tag}, ${3:int which=0})"},
        { "trigger": "ofxXmlSettings::removeAttribute \t(const string, const string, int)"                  ,"contents": "${1:ofxXmlSettings}.removeAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::removeTag \t(const string, int)"                                      ,"contents": "${1:ofxXmlSettings}.removeTag(${2:const string &tag}, ${3:int which=0})"},
        { "trigger": "ofxXmlSettings::saveFile \t(const string)"                                            ,"contents": "${1:ofxXmlSettings}.saveFile(${2:const string &xmlFile})"},
        { "trigger": "ofxXmlSettings::saveFile"                                                             ,"contents": "${1:ofxXmlSettings}.saveFile()"},
        { "trigger": "ofxXmlSettings::setAttribute \t(const string, const string, int, int)"                ,"contents": "${1:ofxXmlSettings}.setAttribute($2{:const string &tag}, ${3:const string &attribute}, ${4:int value}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::setAttribute \t(const string, const string, double, int)"             ,"contents": "${1:ofxXmlSettings}.setAttribute($2{:const string &tag}, ${3:const string &attribute}, ${4:double value}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::setAttribute \t(const string, const string, const string, int)"       ,"contents": "${1:ofxXmlSettings}.setAttribute($2{:const string &tag}, ${3:const string &attribute}, ${4:const string &value}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::setAttribute \t(const string, const string, int)"                     ,"contents": "${1:ofxXmlSettings}.setAttribute($2{:const string &tag}, ${3:const string &attribute}, ${4:int value})"},
        { "trigger": "ofxXmlSettings::setAttribute \t(const string, const string, double)"                  ,"contents": "${1:ofxXmlSettings}.setAttribute($2{:const string &tag}, ${3:const string &attribute}, ${4:double value})"},
        { "trigger": "ofxXmlSettings::setAttribute \t(const string, const string, const string)"            ,"contents": "${1:ofxXmlSettings}.setAttribute($2{:const string &tag}, ${3:const string &attribute}, ${4:const string &value})"},
        { "trigger": "ofxXmlSettings::setValue \t(const string, int, int)"                                  ,"contents": "${1:ofxXmlSettings}.setValue(${2:const string &tag}, ${3:int value}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::setValue \t(const string, double, int)"                               ,"contents": "${1:ofxXmlSettings}.setValue(${2:const string &tag}, ${3:double value}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::setValue \t(const string, const string, int)"                         ,"contents": "${1:ofxXmlSettings}.setValue(${2:const string &tag}, ${3:const string &value}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::tagExists \t(const string, int)"                                      ,"contents": "${1:ofxXmlSettings}.tagExists(${2:const string &tag}, ${3:int which=0})"},
        { "trigger": "ofxXmlSettings::bDocLoaded"                                                           ,"contents": "${1:ofxXmlSettings}.bDocLoaded"},
        { "trigger": "ofxXmlSettings::doc"                                                                  ,"contents": "${1:ofxXmlSettings}.doc"},

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        // EMPTY - Kept so that all JSON objects above can keep the trailing ","
        {}
    ]
}