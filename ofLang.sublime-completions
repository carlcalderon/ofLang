// openFrameworks - completions
//
// syntax:
//
// {
//  "trigger": "namespace::method \t(variation)",
//  "contents": "namespace::method()"
// }
//
// example:
// { "trigger": "ofBackground \t(ofColor)"                                           ,"contents": "ofBackground(${1:const ofColor &c})" },
//
{
    "scope": "source.c++",

    "completions":
    [

        /////////////// Types  //(/////////////

        //////////////////////////////////////
        // ofColor
        { "trigger": "ofColor"                                                      ,"contents": "ofColor ${1:color}"},
        // TODO

        //////////////////////////////////////
        // ofPoint
        { "trigger": "ofPoint"                                                      ,"contents": "ofPoint ${1:point}"},
        { "trigger": "ofPoint::set \t(float, float, float)"                         ,"contents": "set(${1:float _x}, ${2:float _y}, ${3:float _z})"},
        // TODO, so many operators, should they even be here?

        //////////////////////////////////////
        // ofPtr
        { "trigger": "ofPtr"                                                        ,"contents": "ofPtr< ${1:instance} > ptr(new ${1:instance}());"},
        // DONE

        //////////////////////////////////////
        // ofRectangle
        { "trigger": "ofRectangle"                                                      ,"contents": "ofRectangle ${1:rectangle}"},
        { "trigger": "ofRectangle::set \t(float px, float py, float w, float h)"        ,"contents": "${1:ofRectangle}.set(${2:float px}, ${3:float py}, ${4:float w}, ${5:float h})"},
        { "trigger": "ofRectangle::set \t(const ofPoint &p, float w, float h)"          ,"contents": "${1:ofRectangle}.set(${2:const ofPoint &p}, ${3:float w}, ${4:float h})"},
        { "trigger": "ofRectangle::set \t(const ofRectangle &rect)"                     ,"contents": "${1:ofRectangle}.set(${2:const ofRectangle &rect})"},
        { "trigger": "ofRectangle::set \t(const ofPoint &p0, const ofPoint &p1)"        ,"contents": "${1:ofRectangle}.set(${2:const ofPoint &p0}, ${3:const ofPoint &p1})"},
        { "trigger": "ofRectangle \theight"                                             ,"contents": "${1:ofRectangle}.height"},
        { "trigger": "ofRectangle \tposition"                                           ,"contents": "${1:ofRectangle}.position"},
        { "trigger": "ofRectangle \twidth"                                              ,"contents": "${1:ofRectangle}.width"},
        { "trigger": "ofRectangle \tx"                                                  ,"contents": "${1:ofRectangle}.x"},
        { "trigger": "ofRectangle \ty"                                                  ,"contents": "${1:ofRectangle}.y"},
        // TODO 


        //////////////////////////////////////
        // ofStyle
        { "trigger": "ofStyle"                                                      ,"contents": "ofStyle"},
        // TODO docs down [martin]



        ////////////////////////////////////
        // ofGradientModes
        { "trigger": "OF_GRADIENT_CIRCULAR \tofGradientMode"                         ,"contents": "OF_GRADIENT_CIRCULAR"},

        ////////////////////////////////////
        // ofGraphics

        // ofBackground
        { "trigger": "ofBackground \t(rgb)"                                          ,"contents": "ofBackground(${1:int r}, ${2:int g}, ${3:int b})"},
        { "trigger": "ofBackground \t(rgba)"                                         ,"contents": "ofBackground(${1:int r}, ${2:int g}, ${3:int b}, ${4:int a})" },
        { "trigger": "ofBackground \t(brightness, alpha)"                            ,"contents": "ofBackground(${1:int brightness}, ${2:int alpha=255})" },
        { "trigger": "ofBackground \t(ofColor)"                                      ,"contents": "ofBackground(${1:const ofColor &c})" },

        // ofBackgroundGradient
        { "trigger": "ofBackgroundGradient"                                          ,"contents": "ofBackgroundGradient(${1:const ofColor &start}, ${2:const ofColor &end}, ${3:ofGradientMode mode=OF_GRADIENT_CIRCULAR})" },

        // ofBackgroundHex
        { "trigger": "ofBackgroundHex"                                               ,"contents": "ofBackgroundHex(${1:int hexColor}, ${2:int alpha=255})" },

        // ofBeginSaveScreenAsPDF
        { "trigger": "ofBeginSaveScreenAsPDF"                                        ,"contents": "ofBeginSaveScreenAsPDF(${1:string filename}, ${2:bool bMultipage=false}, ${3:bool b3D=false}, ${4:ofRectangle viewport=ofRectangle(0, 0, 0, 0)})" },

        // ofBeginShape
        { "trigger": "ofBeginShape"                                                  ,"contents": "ofBeginShape()" },

        // ofBezier
        { "trigger": "ofBezier \t(xy)"                                               ,"contents": "ofBezier(${1:float x0}, ${2:float y0}, ${3:float x1}, ${4:float y1}, ${5:float x2}, ${6:float y2}, ${7:float x3}, ${8:float y3})" },
        { "trigger": "ofBezier \t(xyz)"                                              ,"contents": "ofBezier(${1:float x0}, ${2:float y0}, ${3:float z0}, ${4:float x1}, ${5:float y1}, ${6:float z1}, ${7:float x2}, ${8:float y2}, ${9:float z2}, ${10:float x3}, ${11:float y3}, ${12:float z3})" },

        // ofBezierVertex
        { "trigger": "ofBezierVertex \t(xy)"                                         ,"contents": "ofBezierVertex(${1:float x1}, ${2:float y1}, ${3:float x2}, ${4:float y2}, ${5:float x3}, ${6:float y3})" },
        { "trigger": "ofBezierVertex \t(xyz)"                                        ,"contents": "ofBezierVertex(${1:float x1}, ${2:float y1}, ${3:float z1}, ${4:float x2}, ${5:float y2}, ${6:float z2}, ${7:float x3}, ${8:float y3}, ${9:float z3})" },
        { "trigger": "ofBezierVertex \t(ofPoint)"                                    ,"contents": "ofBezierVertex(${1:const ofPoint &p1}, ${2:const ofPoint &p2}, ${3:const ofPoint &p3})" },

        // ofBgColorPtr
        { "trigger": "ofBgColorPtr"                                                  ,"contents": "ofBgColorPtr()" },

        // ofBox
        { "trigger": "ofBox"                                                         ,"contents": "ofBox(${1:float size})" },
        { "trigger": "ofBox \t(xy)"                                                  ,"contents": "ofBox(${1:float x}, ${2:float y}, ${3:float size})" },
        { "trigger": "ofBox \t(xyz)"                                                 ,"contents": "ofBox(${1:float x}, ${2:float y}, ${3:float z}, ${4:float size})" },
        { "trigger": "ofBox \t(ofPoint)"                                             ,"contents": "ofBox(${1:const ofPoint &position}, ${2:float size})" },

        // ofCircle
        { "trigger": "ofCircle \t(xy)"                                               ,"contents": "ofCircle(${1:float x}, ${2:float y}, ${3:float radius})" },
        { "trigger": "ofCircle \t(xyz)"                                              ,"contents": "ofCircle(${1:float x}, ${2:float y}, ${3:float z}, ${4:float radius})" },
        { "trigger": "ofCircle \t(ofPoint)"                                          ,"contents": "ofCircle(${1:const ofPoint &p}, ${2:float radius})" },

        // ofClear
        { "trigger": "ofClear \t(rgba)"                                              ,"contents": "ofClear(${1:float r}, ${2:float g}, ${3:float b}, ${4:float a=0})" },
        { "trigger": "ofClear \t(brightness, alpha)"                                 ,"contents": "ofClear(${1:float brightness}, ${2:float a=0})" },
        { "trigger": "ofClear \t(ofColor)"                                           ,"contents": "ofClear(${1:const ofColor &c})" },

        // ofClearAlpha
        { "trigger": "ofClearAlpha"                                                  ,"contents": "ofClearAlpha()" },

        // ofCone
        { "trigger": "ofCone \t(size)"                                               ,"contents": "ofCone(${1:float size})" },
        { "trigger": "ofCone \t(radius size)"                                        ,"contents": "ofCone(${1:float radius}, ${2:float height})" },
        { "trigger": "ofCone \t(xy)"                                                 ,"contents": "ofCone(${1:float x}, ${2:float y}, ${3:float radius}, ${4:float height})" },
        { "trigger": "ofCone \t(xyz)"                                                ,"contents": "ofCone(${1:float x}, ${2:float y}, ${3:float z}, ${4:float radius}, ${5:float height})" },
        { "trigger": "ofCone \t(ofPoint)"                                            ,"contents": "ofCone(${1:const ofPoint &position}, ${2:float radius}, ${3:float height})" },

        // ofCurve
        { "trigger": "ofCurve \t(xy)"                                                ,"contents": "ofCurve(${1:float x0}, ${2:float y0}, ${3:float x1}, ${4:float y1}, ${5:float x2}, ${6:float y2}, ${7:float x3}, ${8:float y3})" },
        { "trigger": "ofCurve \t(xyz)"                                               ,"contents": "ofCurve(${1:float x0}, ${2:float y0}, ${3:float z0}, ${4:float x1}, ${5:float y1}, ${6:float z1}, ${7:float x2}, ${8:float y2}, ${9:float z2}, ${10:float x3}, ${11:float y3}, ${12:float z3})" },

        // ofCurveVertex
        { "trigger": "ofCurveVertex \t(xy)"                                          ,"contents": "ofCurveVertex(${1:float x}, ${2:float y})" },
        { "trigger": "ofCurveVertex \t(ofPoint)"                                     ,"contents": "ofCurveVertex(${1:ofPoint &p})" },

        // ofCurveVertices
        { "trigger": "ofCurveVertices"                                               ,"contents": "ofCurveVertices(${1:const vector< ofPoint > &curvePoints})" },

        // ofDisableAlphaBlending
        { "trigger": "ofDisableAlphaBlending"                                        ,"contents": "ofDisableAlphaBlending()" },

        // ofDisableBlendMode
        { "trigger": "ofDisableBlendMode"                                            ,"contents": "ofDisableBlendMode()" },

        // ofDisablePointSprites
        { "trigger": "ofDisablePointSprites"                                         ,"contents": "ofDisablePointSprites()" },

        // ofDisableSmoothing
        { "trigger": "ofDisableSmoothing"                                            ,"contents": "ofDisableSmoothing()" },

        // ofDrawBitmapString
        { "trigger": "ofDrawBitmapString \t(xy)"                                     ,"contents": "ofDrawBitmapString(${1:string textString}, ${2:float x}, ${3:float y}})" },
        { "trigger": "ofDrawBitmapString \t(xyz)"                                    ,"contents": "ofDrawBitmapString(${1:string textString}, ${2:float x}, ${3:float y}, ${4:float z})" },
        { "trigger": "ofDrawBitmapString \t(ofPoint)"                                ,"contents": "ofDrawBitmapString(${1:string textString}, ${2:const ofPoint &p})" },

        // ofDrawBitmapStringHighlight
        { "trigger": "ofDrawBitmapStringHighlight \t(xy)"                            ,"contents": "ofDrawBitmapStringHighlight(${1:string text}, ${2:int x}, ${3:int x}, ${4:const ofColor &background=ofColor::black}, ${5:const ofColor &foreground=ofColor::white})" },
        { "trigger": "ofDrawBitmapStringHighlight \t(ofPoint)"                       ,"contents": "ofDrawBitmapStringHighlight(${1:string text}, ${2:const ofPoint &position}, ${3:const ofColor &background=ofColor::black}, ${4:const ofColor &foreground=ofColor::white})" },

        // ofEllipse
        { "trigger": "ofEllipse \t(xy)"                                              ,"contents": "ofEllipse(${1:float x}, ${2:float y}, ${3:float width}, ${4:float height})" },
        { "trigger": "ofEllipse \t(xyz)"                                             ,"contents": "ofEllipse(${1:float x}, ${2:float y}, ${3:float z}, ${4:float width}, ${5:float height})" },
        { "trigger": "ofEllipse \t(ofPoint)"                                         ,"contents": "ofEllipse(${1:const ofPoint &p}, ${2:float width}, ${3:float height})" },

        // ofEnableAlphaBlending
        { "trigger": "ofEnableAlphaBlending"                                         ,"contents": "ofEnableAlphaBlending()" },

        // ofEnableBlendMode
        { "trigger": "ofEnableBlendMode"                                             ,"contents": "ofEnableBlendMode(${1:ofBlendMode blendMode})" },

        // ofEnablePointSprites
        { "trigger": "ofEnablePointSprites"                                          ,"contents": "ofEnablePointSprites()" },

        // ofEnableSmoothing
        { "trigger": "ofEnableSmoothing"                                             ,"contents": "ofEnableSmoothing()" },

        // ofEndSaveScreenAsPDF
        { "trigger": "ofEndSaveScreenAsPDF"                                          ,"contents": "ofEndSaveScreenAsPDF()" },

        // ofEndShape
        { "trigger": "ofEndShape"                                                    ,"contents": "ofEndShape(${1:bool bClose=false)}" },

        // ofFill
        { "trigger": "ofFill"                                                        ,"contents": "ofFill()" },

        // ofGetCoordHandedness
        { "trigger": "ofGetCoordHandedness"                                          ,"contents": "ofGetCoordHandedness()" },

        // ofGetCurrentRenderer
        { "trigger": "ofGetCurrentRenderer"                                          ,"contents": "ofGetCurrentRenderer()" },

        // ofGetCurrentViewport
        { "trigger": "ofGetCurrentViewport"                                          ,"contents": "ofGetCurrentViewport()" },

        // ofGetFill
        { "trigger": "ofGetFill"                                                     ,"contents": "ofGetFill()" },

        // ofGetGLRenderer
        { "trigger": "ofGetGLRenderer"                                               ,"contents": "ofGetGLRenderer()" },

        // ofGetRectMode
        { "trigger": "ofGetRectMode"                                                 ,"contents": "ofGetRectMode()" },

        // ofGetStyle
        { "trigger": "ofGetStyle"                                                    ,"contents": "ofGetStyle()" },

        // ofGetViewportHeight
        { "trigger": "ofGetViewportHeight"                                           ,"contents": "ofGetViewportHeight()" },

        // ofGetViewportWidth
        { "trigger": "ofGetViewportWidth"                                            ,"contents": "ofGetViewportWidth()" },

        // ofLine
        { "trigger": "ofLine \t(xy)"                                                 ,"contents": "ofLine(${1:float x1}, ${2:float y1}, ${3:float x2}, ${4:float y2})" },
        { "trigger": "ofLine \t(xyz)"                                                ,"contents": "ofLine(${1:float x1}, ${2:float y1}, ${3:float z1}, ${4:float x2}, ${5:float y2}, ${6:float z2})" },
        { "trigger": "ofLine \t(ofPoint)"                                            ,"contents": "ofLine(${1:const ofPoint &p1}, ${2:const ofPoint &p2})" },

        // ofLoadIdentityMatrix
        { "trigger": "ofLoadIdentityMatrix"                                          ,"contents": "ofLoadIdentityMatrix()" },

        // ofLoadMatrix
        { "trigger": "ofLoadMatrix \t(ofMatrix4x4)"                                  ,"contents": "ofLoadMatrix(${1:const ofMatrix4x4 &m})" },
        { "trigger": "ofLoadMatrix \t(float)"                                        ,"contents": "ofLoadMatrix(${1:const float *m})" },

        // ofMultMatrix
        { "trigger": "ofMultMatrix \t(ofMatrix4x4)"                                  ,"contents": "ofMultMatrix(${1:const ofMatrix4x4 &m})" },
        { "trigger": "ofMultMatrix \t(float)"                                        ,"contents": "ofMultMatrix(${1:const float *m})" },

        // ofNextContour
        { "trigger": "ofNextContour"                                                 ,"contents": "ofNextContour(${1:bool bClose=false})" },

        // ofNoFill
        { "trigger": "ofNoFill"                                                      ,"contents": "ofNoFill()" },

        // ofOrientationToDegrees
        { "trigger": "ofOrientationToDegrees"                                        ,"contents": "ofOrientationToDegrees(${1:ofOrientation orientation})" },

        // ofPopMatrix
        { "trigger": "ofPopMatrix"                                                   ,"contents": "ofPopMatrix()" },

        // ofPopStyle
        { "trigger": "ofPopStyle"                                                    ,"contents": "ofPopStyle()" },

        // ofPopView
        { "trigger": "ofPopView"                                                     ,"contents": "ofPopView()" },

        // ofPushMatrix
        { "trigger": "ofPushMatrix"                                                  ,"contents": "ofPushMatrix()" },

        // ofPushStyle
        { "trigger": "ofPushStyle"                                                   ,"contents": "ofPushStyle()" },

        // ofPushView
        { "trigger": "ofPushView"                                                    ,"contents": "ofPushView()" },

        // ofRect
        { "trigger": "ofRect \t(xywh)"                                               ,"contents": "ofRect(${1:float x}, ${2:float y}, ${3:float w}, ${4:float h})" },
        { "trigger": "ofRect \t(xyzwh)"                                              ,"contents": "ofRect(${1:float x}, ${2:float y}, ${3:float z}, ${4:float w}, ${5:float h})" },
        { "trigger": "ofRect \t(ofPoint)"                                            ,"contents": "ofRect(${1:const ofPoint &p}, ${2:float w}, ${3:float h})" },
        { "trigger": "ofRect \t(ofRectangle)"                                        ,"contents": "ofRect(${1:const ofRectangle &r})" },

        // ofRectRounded
        { "trigger": "ofRectRounded \t(xy)"                                          ,"contents": "ofRectRounded(${1:float x}, ${2:float y}, ${3:float w}, ${4:float h}, ${5:float r})" },
        { "trigger": "ofRectRounded \t(xyz)"                                         ,"contents": "ofRectRounded(${1:float x}, ${2:float y}, ${3:float z}, ${4:float w}, ${5:float h}, ${6:float r})" },
        { "trigger": "ofRectRounded \t(ofPoint)"                                     ,"contents": "ofRectRounded(${1:const ofPoint &p}, ${2:float w}, ${3:float h}, ${4:float r})" },
        { "trigger": "ofRectRounded \t(ofRectangle)"                                 ,"contents": "ofRectRounded(${1:const ofRectangle &b}, ${2:float r})" },

        // ofRotate
        { "trigger": "ofRotate"                                                      ,"contents": "ofRotate(${1:float degrees})" },
        { "trigger": "ofRotate \t(xyz)"                                              ,"contents": "ofRotate(${1:float degrees}, ${2:float vecX}, ${3:float vecY}, ${4:float vecZ})" },

        // ofRotateX
        { "trigger": "ofRotateX"                                                     ,"contents": "ofRotateX(${1:float degrees})" },

        // ofRotateY
        { "trigger": "ofRotateY"                                                     ,"contents": "ofRotateY(${1:float degrees})" },

        // ofRotateZ
        { "trigger": "ofRotateZ"                                                     ,"contents": "ofRotateZ(${1:float degrees})" },

        // ofScale
        { "trigger": "ofScale"                                                       ,"contents": "ofScale(${1:float xAmnt}, ${2:float yAmnt}, ${3:float zAmnt=1})" },

        // ofSetBackgroundAuto
        { "trigger": "ofSetBackgroundAuto"                                           ,"contents": "ofSetBackgroundAuto(${1:bool bManual})" },

        // ofSetBackgroundColor
        { "trigger": "ofSetBackgroundColor \t(rgba)"                                 ,"contents": "ofSetBackgroundColor(${1:int r}, ${2:int g}, ${3:int b)}, ${4:int a=255})" },
        { "trigger": "ofSetBackgroundColor \t(brightness, alpha)"                    ,"contents": "ofSetBackgroundColor(${1:int brightness}, ${2:int alpha=255})" },
        { "trigger": "ofSetBackgroundColor \t(ofColor)"                              ,"contents": "ofSetBackgroundColor(${1:const ofColor &c})" },

        // ofSetBackgroundColorHex
        { "trigger": "ofSetBackgroundColorHex"                                       ,"contents": "ofSetBackgroundColorHex(${1:int hexColor}, ${2:int alpha=255})" },

        // ofSetCircleResolution
        { "trigger": "ofSetCircleResolution"                                         ,"contents": "ofSetCircleResolution(${1:int res})" },

        // ofSetColor
        { "trigger": "ofSetColor \t(rgb)"                                            ,"contents": "ofSetColor(${1:int r}, ${2:int g}, ${3:int b})" },
        { "trigger": "ofSetColor \t(rgba)"                                           ,"contents": "ofSetColor(${1:int r}, ${2:int g}, ${3:int b}, ${4:int a})" },
        { "trigger": "ofSetColor \t(gray)"                                           ,"contents": "ofSetColor(${1:int gray})" },
        { "trigger": "ofSetColor \t(ofColor)"                                        ,"contents": "ofSetColor(${1:const ofColor &color})" },
        { "trigger": "ofSetColor \t(ofColor, alpha)"                                 ,"contents": "ofSetColor(${1:const ofColor &color}, ${2:int _a})" },

        // ofSetCoordHandedness
        { "trigger": "ofSetCoordHandedness"                                          ,"contents": "ofSetCoordHandedness(${1:ofHandednessType handedness})" },

        // ofSetCurrentRenderer
        { "trigger": "ofSetCurrentRenderer"                                          ,"contents": "ofSetCurrentRenderer(${1:ofPtr< ofBaseRenderer > renderer})" },

        // ofSetCurveResolution
        { "trigger": "ofSetCurveResolution"                                          ,"contents": "ofSetCurveResolution(${1:int res})" },

        // ofSetDrawBitmapMode
        { "trigger": "ofSetDrawBitmapMode"                                           ,"contents": "ofSetDrawBitmapMode(${1:ofDrawBitmapMode mode})" },

        // ofSetHexColor
        { "trigger": "ofSetHexColor"                                                 ,"contents": "ofSetHexColor(${1:int hexColor})" },

        // ofSetLineWidth
        { "trigger": "ofSetLineWidth"                                                ,"contents": "ofSetLineWidth(${1:float lineWidth})" },

        // ofSetPolyMode
        { "trigger": "ofSetPolyMode"                                                 ,"contents": "ofSetPolyMode(${1:int mode})" },
        { "trigger": "ofSetPolyMode \t(ofPolyWindingMode)"                           ,"contents": "ofSetPolyMode(${1:ofPolyWindingMode mode})" },

        // ofSetRectMode
        { "trigger": "ofSetRectMode"                                                 ,"contents": "ofSetRectMode(${1:int mode})" },
        { "trigger": "ofSetRectMode \t(ofRectMode)"                                  ,"contents": "ofSetRectMode(${1:ofRectMode mode})" },

        // ofSetSphereResolution
        { "trigger": "ofSetSphereResolution"                                         ,"contents": "ofSetSphereResolution(${1:int res})" },

        // ofSetStyle
        { "trigger": "ofSetStyle"                                                    ,"contents": "ofSetStyle(${1:ofStyle style})" },

        // ofSetupScreen
        { "trigger": "ofSetupScreen"                                                 ,"contents": "ofSetupScreen()" },

        // ofSetupScreenOrtho
        { "trigger": "ofSetupScreenOrtho"                                            ,"contents": "ofSetupScreenOrtho(${1:float width=0}, ${2:float height=0}, ${3:ofOrientation orientation=OF_ORIENTATION_UNKNOWN}, ${4:bool vFlip=true}, ${5:float nearDist=-1}, ${6:float farDist=-1})" },

        // ofSetupScreenPerspective
        { "trigger": "ofSetupScreenPerspective"                                      ,"contents": "ofSetupScreenPerspective(${1:float width=0}, ${2:float height=0}, ${3:ofOrientation orientation=OF_ORIENTATION_UNKNOWN}, ${4:bool vFlip=true}, ${5:float fov=60}, ${6:float nearDist=0}, ${7:float farDist=0})" },

        // ofSphere
        { "trigger": "ofSphere"                                                      ,"contents": "ofSphere(${1:float radius})" },
        { "trigger": "ofSphere \t(xy)"                                               ,"contents": "ofSphere(${1:float x}, ${2:float y}, ${3:float radius})" },
        { "trigger": "ofSphere \t(xyz)"                                              ,"contents": "ofSphere(${1:float x}, ${2:float y}, ${3:float z}, ${4:float radius})" },
        { "trigger": "ofSphere \t(ofPoint)"                                          ,"contents": "ofSphere(${1:const ofPoint &position}, ${2:float radius})" },

        // ofTranslate
        { "trigger": "ofTranslate \t(xyz)"                                           ,"contents": "ofTranslate(${1:float x}, ${2:float y}, ${3:float z=0})" },
        { "trigger": "ofTranslate \t(ofPoint)"                                       ,"contents": "ofTranslate(${1:const ofPoint &p})" },

        // ofTriangle
        { "trigger": "ofTriangle \t(xy)"                                             ,"contents": "ofTriangle(${1:float x1}, ${2:float y1}, ${3:float x2}, ${4:float y2}, ${5:float x3}, ${6:float y3})" },
        { "trigger": "ofTriangle \t(xyz)"                                            ,"contents": "ofTriangle(${1:float x1}, ${2:float y1}, ${3:float z1}, ${4:float x2}, ${5:float y2}, ${6:float z2}, ${7:float x3}, ${8:float y3}, ${9:float z3})" },
        { "trigger": "ofTriangle \t(ofPoint, ofPoint, ofPoint)"                      ,"contents": "ofTriangle(${1:const ofPoint &p1}, ${2:const ofPoint &p2}, ${3:const ofPoint &p3})" },

        // ofVertex
        { "trigger": "ofVertex \t(xy)"                                               ,"contents": "ofVertex(${1:float x}, ${2:float y})" },
        { "trigger": "ofVertex \t(xyz)"                                              ,"contents": "ofVertex(${1:float x}, ${2:float y}, ${3:float z})" },
        { "trigger": "ofVertex \t(ofPoint)"                                          ,"contents": "ofVertex(${1:ofPoint &p})" },

        // ofVertices
        { "trigger": "ofVertices"                                                    ,"contents": "ofVertices(${1:const vector< ofPoint > &polyPoints})" },

        // ofViewport
        { "trigger": "ofViewport"                                                    ,"contents": "ofViewport(${1:float x=0}, ${2:float y=0}, ${3:float width=0}, ${4:float height=0}, ${5:bool invertY=true})" },
        { "trigger": "ofViewport \t(ofRectangle)"                                    ,"contents": "ofViewport(${1:ofRectangle viewport})" },

        // ofbClearBg
        { "trigger": "ofbClearBg"                                                    ,"contents": "ofbClearBg()" },

        /////////////////////////////////////////////
        // ofImage
        { "trigger": "ofImage::allocate"                                             ,"contents": "${1:ofImage}.allocate(${2:int w}, ${3:int h}, ${4:ofImageType type})" },
        { "trigger": "ofImage::bAllocated"                                           ,"contents": "${1:ofImage}.bAllocated()" },
        { "trigger": "ofImage::bind"                                                 ,"contents": "${1:ofImage}.bind()" },
        { "trigger": "ofImage::clear"                                                ,"contents": "${1:ofImage}.clear()" },
        { "trigger": "ofImage::clone"                                                ,"contents": "${1:ofImage}.clone(${2:const ofImage_< SrcType > &mom})" },
        { "trigger": "ofImage::crop"                                                 ,"contents": "${1:ofImage}.crop(${2:int x}, ${3:int y}, ${4:int w}, ${5:int h})" },
        { "trigger": "ofImage::cropFrom"                                             ,"contents": "${1:ofImage}.cropFrom(${2:ofImage_< PixelType > &otherImage}, ${3:int x}, ${4:int y}, ${5:int w}, ${6:int h})" },
        { "trigger": "ofImage::draw \t(ofRectangle)"                                 ,"contents": "${1:ofImage}.draw(${2:const ofRectangle &r})" },
        { "trigger": "ofImage::draw \t(ofPoint)"                                     ,"contents": "${1:ofImage}.draw(${2:const ofPoint &p}, ${3:float w}, ${4:float h})" },
        { "trigger": "ofImage::draw \t(xy)"                                          ,"contents": "${1:ofImage}.draw(${2:float x}, ${3:float y})" },
        { "trigger": "ofImage::draw \t(xyz)"                                         ,"contents": "${1:ofImage}.draw(${2:float x}, ${3:float y}, ${4:float z})" },
        { "trigger": "ofImage::draw \t(xywh)"                                        ,"contents": "${1:ofImage}.draw(${2:float x}, ${3:float y}, ${4:float w}, ${5:float h})" },
        { "trigger": "ofImage::draw \t(xyzwh)"                                       ,"contents": "${1:ofImage}.draw(${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h})" },
        { "trigger": "ofImage::draw \t(ofPoint)"                                     ,"contents": "${1:ofImage}.draw(${2:const ofPoint &p})" },
        { "trigger": "ofImage::drawSubsection \t(xywhsxsy)"                          ,"contents": "${1:ofImage}.drawSubsection(${2:float x}, ${3:float y}, ${4:float w}, ${5:float h}, ${6:float sx}, ${7:float sy})" },
        { "trigger": "ofImage::drawSubsection \t(xyzwhsxsy)"                         ,"contents": "${1:ofImage}.drawSubsection(${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h}, ${7:float sx}, ${8:float sy})" },
        { "trigger": "ofImage::drawSubsection \t(xywhsxsyswsh)"                      ,"contents": "${1:ofImage}.drawSubsection(${2:float x}, ${3:float y}, ${4:float w}, ${5:float h}, ${6:float sx}, ${7:float sy}, ${8:float sw}, ${9:float sh})" },
        { "trigger": "ofImage::drawSubsection \t(xyzwhsxsyswsh)"                     ,"contents": "${1:ofImage}.drawSubsection(${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h}, ${7:float sx}, ${8:float sy}, ${9:float sw}, ${10:float sh})" },
        { "trigger": "ofImage::getColor"                                             ,"contents": "${1:ofImage}.getColor(${2:int x}, ${3:int y})" },
        { "trigger": "ofImage::getHeight"                                            ,"contents": "${1:ofImage}.getHeight()" },
        { "trigger": "ofImage::getPixels"                                            ,"contents": "${1:ofImage}.getPixels()" },
        { "trigger": "ofImage::getPixelsRef"                                         ,"contents": "${1:ofImage}.getPixelsRef()" },
        { "trigger": "ofImage::getTextureReference"                                  ,"contents": "${1:ofImage}.getTextureReference()" },
        { "trigger": "ofImage::getWidth"                                             ,"contents": "${1:ofImage}.getWidth()" },
        { "trigger": "ofImage::grabScreen"                                           ,"contents": "${1:ofImage}.grabScreen(${2:int x}, ${3:int y}, ${4:int w}, ${5:int h})" },
        { "trigger": "ofImage::isAllocated"                                          ,"contents": "${1:ofImage}.isAllocated()" },
        { "trigger": "ofImage::isUsingTexture"                                       ,"contents": "${1:ofImage}.isUsingTexture()" },
        { "trigger": "ofImage::loadImage \t(string)"                                 ,"contents": "${1:ofImage}.loadImage(${2:string fileName})" },
        { "trigger": "ofImage::loadImage \t(ofBuffer)"                               ,"contents": "${1:ofImage}.loadImage(${2:const ofBuffer &buffer})" },
        { "trigger": "ofImage::loadImage \t(ofFile)"                                 ,"contents": "${1:ofImage}.loadImage(${2:const ofFile &file})" },
        { "trigger": "ofImage::mirror"                                               ,"contents": "${1:ofImage}.mirror(${2:bool vertical}, ${3:bool horizontal})" },
        { "trigger": "ofImage::reloadTexture"                                        ,"contents": "${1:ofImage}.reloadTexture()" },
        { "trigger": "ofImage::resetAnchor"                                          ,"contents": "${1:ofImage}.resetAnchor()" },
        { "trigger": "ofImage::resize"                                               ,"contents": "${1:ofImage}.resize(${2:int newWidth}, ${3:int newHeight})" },
        { "trigger": "ofImage::rotate90"                                             ,"contents": "${1:ofImage}.rotate90(${2:int rotation})" },
        { "trigger": "ofImage::saveImage \t(string)"                                 ,"contents": "${1:ofImage}.saveImage(${2:string fileName}, ${3:ofImageQualityType compressionLevel=OF_IMAGE_QUALITY_BEST})" },
        { "trigger": "ofImage::saveImage \t(ofBuffer)"                               ,"contents": "${1:ofImage}.saveImage(${2:ofBuffer &buffer}, ${3:ofImageQualityType compressionLevel=OF_IMAGE_QUALITY_BEST})" },
        { "trigger": "ofImage::saveImage \t(ofFile)"                                 ,"contents": "${1:ofImage}.saveImage(${2:const ofFile &file}, ${3:ofImageQualityType compressionLevel=OF_IMAGE_QUALITY_BEST})" },
        { "trigger": "ofImage::setAnchorPercent"                                     ,"contents": "${1:ofImage}.setAnchorPercent(${2:float xPct}, ${3:float yPct})" },
        { "trigger": "ofImage::setAnchorPoint"                                       ,"contents": "${1:ofImage}.setAnchorPoint(${2:float x}, ${3:float y})" },
        { "trigger": "ofImage::setColor"                                             ,"contents": "${1:ofImage}.setColor(${2:int x}, ${3:int y}, ${4:ofColor_< PixelType > color})" },
        { "trigger": "ofImage::setCompression"                                       ,"contents": "${1:ofImage}.setCompression(${2:ofTexCompression compression})" },
        { "trigger": "ofImage::setFromPixels \t(pixels, wh)"                         ,"contents": "${1:ofImage}.setFromPixels(${2:const PixelType *pixels}, ${3:int w}, ${4:int h}, ${5:ofImageType type}, ${6:bool bOrderIsRGB=true})" },
        { "trigger": "ofImage::setFromPixels \t(PixelsType)"                         ,"contents": "${1:ofImage}.setFromPixels(${2:const ofPixels_< PixelType > &pixels})" },
        { "trigger": "ofImage::setImageType"                                         ,"contents": "${1:ofImage}.setImageType(${2:ofImageType type})" },
        { "trigger": "ofImage::setUseTexture"                                        ,"contents": "${1:ofImage}.setUseTexture(${2:bool bUse})" },
        { "trigger": "ofImage::unbind"                                               ,"contents": "${1:ofImage}.unbind()" },
        { "trigger": "ofImage::update"                                               ,"contents": "${1:ofImage}.update()" },
        { "trigger": "ofImage::bpp"                                                  ,"contents": "${1:ofImage}.bpp" },
        { "trigger": "ofImage::height"                                               ,"contents": "${1:ofImage}.height" },
        { "trigger": "ofImage::type"                                                 ,"contents": "${1:ofImage}.type" },
        { "trigger": "ofImage::width"                                                ,"contents": "${1:ofImage}.width" },
        { "trigger": "ofImage::width"                                                ,"contents": "${1:ofImage}.width" },
        { "trigger": "ofLoadImage \t(ofPixels, string)"                              ,"contents": "ofLoadImage(${1:ofPixels &pix}, ${2:string path})" },
        { "trigger": "ofLoadImage \t(ofPixels, ofBuffer)"                            ,"contents": "ofLoadImage(${1:ofPixels &pix}, ${2:const ofBuffer &buffer})" },
        { "trigger": "ofLoadImage \t(ofTexture, string)"                             ,"contents": "ofLoadImage(${1:ofTexture &tex}, ${2:string path})" },
        { "trigger": "ofLoadImage \t(ofTexture, ofBuffer)"                           ,"contents": "ofLoadImage(${1:ofTexture &tex}, ${2:const ofBuffer &buffer})" },
        { "trigger": "ofSaveImage \t(ofPixels, string)"                              ,"contents": "ofSaveImage(${1:ofPixels &pix}, ${2:string path}, ${3:ofImageQualityType qualityLevel=OF_IMAGE_QUALITY_BEST})" },
        { "trigger": "ofSaveImage \t(ofPixels, ofBuffer)"                            ,"contents": "ofSaveImage(${1:ofPixels &pix}, ${2:ofBuffer &buffer}, ${3:ofImageFormat format=OF_IMAGE_FORMAT_PNG}, ${4:ofImageQualityType qualityLevel=OF_IMAGE_QUALITY_BEST})" },

        { "trigger": "OF_IMAGE_COLOR"                                                ,"contents": "OF_IMAGE_COLOR" },
        { "trigger": "OF_IMAGE_COLOR_ALPHA"                                          ,"contents": "OF_IMAGE_COLOR_ALPHA" },
        { "trigger": "OF_IMAGE_GRAYSCALE"                                            ,"contents": "OF_IMAGE_GRAYSCALE" },
        { "trigger": "OF_COLOR_IMAGE"                                                ,"contents": "OF_COLOR_IMAGE" },
        { "trigger": "OF_COMPRESS_NONE"                                              ,"contents": "OF_COMPRESS_NONE" },
        { "trigger": "OF_COMPRESS_SRGB"                                              ,"contents": "OF_COMPRESS_SRGB" },
        { "trigger": "OF_COMPRESS_ARB"                                               ,"contents": "OF_COMPRESS_ARB" },
        { "trigger": "OF_IMAGE_QUALITY_BEST"                                         ,"contents": "OF_IMAGE_QUALITY_BEST" },
        { "trigger": "OF_IMAGE_QUALITY_HIGH"                                         ,"contents": "OF_IMAGE_QUALITY_HIGH" },
        { "trigger": "OF_IMAGE_QUALITY_MEDIUM"                                       ,"contents": "OF_IMAGE_QUALITY_MEDIUM" },
        { "trigger": "OF_IMAGE_QUALITY_LOW"                                          ,"contents": "OF_IMAGE_QUALITY_LOW" },
        { "trigger": "OF_IMAGE_QUALITY_WORST"                                        ,"contents": "OF_IMAGE_QUALITY_WORST" },

        /////////////////////////////////////////////
        // ofPath
        { "trigger": "ofPath::arc \t(ofPoint)"                                       ,"contents": "${1:ofPath}.arc(${2:const ofPoint &centre}, float radiusX}, float radiusY}, float angleBegin}, float angleEnd})" },
        { "trigger": "ofPath::arc \t(xy)"                                            ,"contents": "${1:ofPath}.arc(${2:float x}, float y}, ${3:float radiusX}, ${4:float radiusY}, ${5:float angleBegin}, ${6:float angleEnd})" },
        { "trigger": "ofPath::arc \t(xyz)"                                           ,"contents": "${1:ofPath}.arc(${2:float x}, float y}, ${3:float z}, ${4:float radiusX}, ${5:float radiusY}, ${6:float angleBegin}, ${7:float angleEnd})" },
        { "trigger": "ofPath::arc \t(ofPoint clockwise)"                             ,"contents": "${1:ofPath}.arc(${2:const ofPoint &centre}, ${3:float radiusX}, ${4:float radiusY}, ${5:float angleBegin}, ${6:float angleEnd}, ${7:bool clockwise})" },
        { "trigger": "ofPath::arcNegative \t(ofPoint)"                               ,"contents": "${1:ofPath}.arcNegative(${2:const ofPoint &centre}, ${3:float radiusX}, ${4:float radiusY}, ${5:float angleBegin}, ${6:float angleEnd})" },
        { "trigger": "ofPath::arcNegative \t(xy)"                                    ,"contents": "${1:ofPath}.arcNegative(${2:float x}, ${3:float y}, ${4:float radiusX}, ${5:float radiusY}, ${6:float angleBegin}, ${7:float angleEnd})" },
        { "trigger": "ofPath::arcNegative \t(xyz)"                                   ,"contents": "${1:ofPath}.arcNegative(${2:float x}, ${3:float y}, ${4:float z}, ${5:float radiusX}, ${6:float radiusY}, ${7:float angleBegin}, ${8:float angleEnd})" },
        { "trigger": "ofPath::bezierTo \t(ofPoint)"                                  ,"contents": "${1:ofPath}.bezierTo(${2:const ofPoint &cp1}, ${3:const ofPoint &cp2}, ${4:const ofPoint &p})" },
        { "trigger": "ofPath::bezierTo \t(xy)"                                       ,"contents": "${1:ofPath}.bezierTo(${2:float cx1}, ${3:float cy1}, ${4:float cx2}, ${5:float cy2}, ${6:float x}, ${7:float y})" },
        { "trigger": "ofPath::bezierTo \t(xyz)"                                      ,"contents": "${1:ofPath}.bezierTo(${2:float cx1}, ${3:float cy1}, ${4:float cz1}, ${5:float cx2}, ${6:float cy2}, ${7:float cz2}, ${8:float x}, ${9:float y}, ${10:float z})" },
        { "trigger": "ofPath::clear"                                                 ,"contents": "${1:ofPath}.clear()" },
        { "trigger": "ofPath::close"                                                 ,"contents": "${1:ofPath}.close()" },
        { "trigger": "ofPath::curveTo \t(ofPoint)"                                   ,"contents": "${1:ofPath}.curveTo(${2:const ofPoint &p})" },
        { "trigger": "ofPath::curveTo \t(xy)"                                        ,"contents": "${1:ofPath}.curveTo(${2:float x}, ${3:float y})" },
        { "trigger": "ofPath::curveTo \t(xyz)"                                       ,"contents": "${1:ofPath}.curveTo(${2:float x}, ${3:float y}, ${4:float z})" },
        { "trigger": "ofPath::draw \t(xy)"                                           ,"contents": "${1:ofPath}.draw(${2:float x}, ${3:float y})" },
        { "trigger": "ofPath::draw"                                                  ,"contents": "${1:ofPath}.draw()" },
        { "trigger": "ofPath::flagShapeChanged"                                      ,"contents": "${1:ofPath}.flagShapeChanged()" },
        { "trigger": "ofPath::generatePolylinesFromPaths"                            ,"contents": "${1:ofPath}.generatePolylinesFromPaths()" },
        { "trigger": "ofPath::getArcResolution"                                      ,"contents": "${1:ofPath}.getArcResolution()" },
        { "trigger": "ofPath::getCurveResolution"                                    ,"contents": "${1:ofPath}.getCurveResolution()" },
        { "trigger": "ofPath::getFillColor"                                          ,"contents": "${1:ofPath}.getFillColor()" },
        { "trigger": "ofPath::getOutline"                                            ,"contents": "${1:ofPath}.getOutline()" },
        { "trigger": "ofPath::getStrokeColor"                                        ,"contents": "${1:ofPath}.getStrokeColor()" },
        { "trigger": "ofPath::getStrokeWidth"                                        ,"contents": "${1:ofPath}.getStrokeWidth()" },
        { "trigger": "ofPath::getSubPaths"                                           ,"contents": "${1:ofPath}.getSubPaths()" },
        { "trigger": "ofPath::getTessellation"                                       ,"contents": "${1:ofPath}.getTessellation()" },
        { "trigger": "ofPath::getUseShapeColor"                                      ,"contents": "${1:ofPath}.getUseShapeColor()" },
        { "trigger": "ofPath::getWindingMode"                                        ,"contents": "${1:ofPath}.getWindingMode()" },
        { "trigger": "ofPath::hasOutline"                                            ,"contents": "${1:ofPath}.hasOutline()" },
        { "trigger": "ofPath::isFilled"                                              ,"contents": "${1:ofPath}.isFilled()" },
        { "trigger": "ofPath::lastPath"                                              ,"contents": "${1:ofPath}.lastPath()" },
        { "trigger": "ofPath::lastPolyline"                                          ,"contents": "${1:ofPath}.lastPolyline()" },
        { "trigger": "ofPath::lineTo \t(ofPoint)"                                    ,"contents": "${1:ofPath}.lineTo(${2:const ofPoint &p})" },
        { "trigger": "ofPath::lineTo \t(xy)"                                         ,"contents": "${1:ofPath}.lineTo(${2:float x, ${3:float y})" },
        { "trigger": "ofPath::lineTo \t(xyz)"                                        ,"contents": "${1:ofPath}.lineTo(${2:float x, ${3:float y}, ${4:float z})" },
        { "trigger": "ofPath::moveTo \t(ofPoint)"                                    ,"contents": "${1:ofPath}.moveTo(${2:const ofPoint &p})" },
        { "trigger": "ofPath::moveTo \t(xy[z])"                                      ,"contents": "${1:ofPath}.moveTo(${2:float x, ${3:float y}, ${4:float z=0})" },
        { "trigger": "ofPath::newSubPath"                                            ,"contents": "${1:ofPath}.newSubPath()" },
        { "trigger": "ofPath::ofPath"                                                ,"contents": "${1:ofPath}.ofPath()" },
        { "trigger": "ofPath::quadBezierTo \t(ofPoint)"                              ,"contents": "${1:ofPath}.quadBezierTo(${2:const ofPoint &cp1}, ${3:const ofPoint &cp2}, ${4:const ofPoint &p})" },
        { "trigger": "ofPath::quadBezierTo \t(xy)"                                   ,"contents": "${1:ofPath}.quadBezierTo(${2:float cx1}, ${3:float cy1}, ${4:float cx2}, ${5:float cy2}, ${6:float x}, ${7:float y})" },
        { "trigger": "ofPath::quadBezierTo \t(xyz)"                                  ,"contents": "${1:ofPath}.quadBezierTo(${2:float cx1}, ${3:float cy1}, ${4:float cz1}, ${5:float cx2}, ${6:float cy2}, ${7:float cz2}, ${8:float x}, ${9:float y}, ${10:float z})" },
        { "trigger": "ofPath::rotate"                                                ,"contents": "${1:ofPath}.rotate(${2:float az}, ${3:const ofVec3f &axis})" },
        { "trigger": "ofPath::scale"                                                 ,"contents": "${1:ofPath}.scale(${2:float x}, ${3:float y})" },
        { "trigger": "ofPath::setArcResolution"                                      ,"contents": "${1:ofPath}.setArcResolution(${2:int res})" },
        { "trigger": "ofPath::setColor"                                              ,"contents": "${1:ofPath}.setColor(${2:const ofColor &color})" },
        { "trigger": "ofPath::setCurveResolution"                                    ,"contents": "${1:ofPath}.setCurveResolution(${2:int curveResolution})" },
        { "trigger": "ofPath::setFillColor"                                          ,"contents": "${1:ofPath}.setFillColor(${2:const ofColor &color})" },
        { "trigger": "ofPath::setFillHexColor"                                       ,"contents": "${1:ofPath}.setFillHexColor(${2:int hex})" },
        { "trigger": "ofPath::setFilled"                                             ,"contents": "${1:ofPath}.setFilled(${2:bool hasFill})" },
        { "trigger": "ofPath::setHexColor"                                           ,"contents": "${1:ofPath}.setHexColor(${2:int hex})" },
        { "trigger": "ofPath::setMode"                                               ,"contents": "${1:ofPath}.setMode(${2:Mode mode})" },
        { "trigger": "ofPath::setPolyWindingMode"                                    ,"contents": "${1:ofPath}.setPolyWindingMode(${2:ofPolyWindingMode mode})" },
        { "trigger": "ofPath::setStrokeColor"                                        ,"contents": "${1:ofPath}.setStrokeColor(${2:const ofColor &color})" },
        { "trigger": "ofPath::setStrokeHexColor"                                     ,"contents": "${1:ofPath}.setStrokeHexColor(${2:int hex})" },
        { "trigger": "ofPath::setStrokeWidth"                                        ,"contents": "${1:ofPath}.setStrokeWidth(${2:float width})" },
        { "trigger": "ofPath::setUseShapeColor"                                      ,"contents": "${1:ofPath}.setUseShapeColor(${2:bool useColor})" },
        { "trigger": "ofPath::simplify"                                              ,"contents": "${1:ofPath}.simplify(${2:float tolerance=0.3})" },
        { "trigger": "ofPath::tessellate"                                            ,"contents": "${1:ofPath}.tessellate()" },
        { "trigger": "ofPath::translate"                                             ,"contents": "${1:ofPath}.translate(${2:const ofPoint &p})" },

        { "trigger": "OF_POLY_WINDING_ODD"                                           ,"contents": "OF_POLY_WINDING_ODD" },
        { "trigger": "OF_POLY_WINDING_NONZERO"                                       ,"contents": "OF_POLY_WINDING_NONZERO" },
        { "trigger": "OF_POLY_WINDING_POSITIVE"                                      ,"contents": "OF_POLY_WINDING_POSITIVE" },
        { "trigger": "OF_POLY_WINDING_NEGATIVE"                                      ,"contents": "OF_POLY_WINDING_NEGATIVE" },
        { "trigger": "OF_POLY_WINDING_ABS_GEQ_TWO"                                   ,"contents": "OF_POLY_WINDING_ABS_GEQ_TWO" },

        ///////////////////////////////////////////
        // ofPixels
        { "trigger": "ofPixels::allocate \t(channel)"                                ,"contents": "${1:ofPixels}.allocate(${2:int w}, ${3:int h}, ${4:int channels})" },
        { "trigger": "ofPixels::allocate \t(ofPixelFormat)"                          ,"contents": "${1:ofPixels}.allocate(${2:int w}, ${3:int h}, ${4:ofPixelFormat type})" },
        { "trigger": "ofPixels::allocate \t(ofImageType)"                            ,"contents": "${1:ofPixels}.allocate(${2:int w}, ${3:int h}, ${4:ofImageType type})" },
        { "trigger": "ofPixels::bicubicInterpolate"                                  ,"contents": "${1:ofPixels}.bicubicInterpolate(${2:const float *patch}, ${3:float x}, ${4:float y}, ${5:float x2}, ${6:float y2}, ${7:float x3}, ${8:float y3})" },
        { "trigger": "ofPixels::clear"                                               ,"contents": "${1:ofPixels}.clear()" },
        { "trigger": "ofPixels::copyFrom \t(PixelType)"                              ,"contents": "${1:ofPixels}.copyFrom(${2:const ofPixels_< PixelType > &mom})" },
        { "trigger": "ofPixels::copyFrom \t(SrcType)"                                ,"contents": "${1:ofPixels}.copyFrom(${2:const ofPixels_< SrcType > &mom})" },
        { "trigger": "ofPixels::crop"                                                ,"contents": "${1:ofPixels}.crop(${2:int x}, ${2:int y}, ${3:int width}, ${4:int height})" },
        { "trigger": "ofPixels::cropTo"                                              ,"contents": "${1:ofPixels}.cropTo(${2:ofPixels_< PixelType > &toPix}, ${3:int x}, ${4:int y}, ${5:int _width}, ${6:int _height})" },
        { "trigger": "ofPixels::getBitsPerChannel"                                   ,"contents": "${1:ofPixels}.getBitsPerChannel()" },
        { "trigger": "ofPixels::getBitsPerPixel"                                     ,"contents": "${1:ofPixels}.getBitsPerPixel()" },
        { "trigger": "ofPixels::getBytesPerChannel"                                  ,"contents": "${1:ofPixels}.getBytesPerChannel()" },
        { "trigger": "ofPixels::getBytesPerPixel"                                    ,"contents": "${1:ofPixels}.getBytesPerPixel()" },
        { "trigger": "ofPixels::getChannel"                                          ,"contents": "${1:ofPixels}.getChannel(${2:int channel)" },
        { "trigger": "ofPixels::getColor"                                            ,"contents": "${1:ofPixels}.getColor(${2:int x}, ${3:int y})" },
        { "trigger": "ofPixels::getHeight"                                           ,"contents": "${1:ofPixels}.getHeight()" },
        { "trigger": "ofPixels::getImageType"                                        ,"contents": "${1:ofPixels}.getImageType()" },
        { "trigger": "ofPixels::getNumChannels"                                      ,"contents": "${1:ofPixels}.getNumChannels()" },
        { "trigger": "ofPixels::getPixelIndex"                                       ,"contents": "${1:ofPixels}.getPixelIndex(${2:int x}, ${3:int y})" },
        { "trigger": "ofPixels::getPixels"                                           ,"contents": "${1:ofPixels}.getPixels()" },
        { "trigger": "ofPixels::getWidth"                                            ,"contents": "${1:ofPixels}.getWidth()" },
        { "trigger": "ofPixels::isAllocated"                                         ,"contents": "${1:ofPixels}.isAllocated()" },
        { "trigger": "ofPixels::mirror"                                              ,"contents": "${1:ofPixels}.mirror(${2:bool vertically}, ${3:bool horizontal})" },
        { "trigger": "ofPixels::mirrorTo"                                            ,"contents": "${1:ofPixels}.mirrorTo(${2:ofPixels_< PixelType > &dst, bool vertically}, ${3:bool horizontal})" },
        { "trigger": "ofPixels::ofPixels"                                            ,"contents": "${1:ofPixels}.ofPixels()" },
        { "trigger": "ofPixels::ofPixels \t(PixelType)"                              ,"contents": "${1:ofPixels}.ofPixels(${2:const ofPixels_< PixelType > &mom})" },
        { "trigger": "ofPixels::ofPixels \t(SrcType)"                                ,"contents": "${1:ofPixels}.ofPixels(${2:const ofPixels_< SrcType > &mom})" },
        { "trigger": "ofPixels::operator \t(PixelType)"                              ,"contents": "${1:ofPixels}.operator(${2:const ofPixels_< PixelType > &mom})" },
        { "trigger": "ofPixels::operator \t(SrcType)"                                ,"contents": "${1:ofPixels}.operator(${2:const ofPixels_< SrcType > &mom})" },
        { "trigger": "ofPixels::operator"                                            ,"contents": "${1:ofPixels}.operator(${2:int pos})" },
        { "trigger": "ofPixels::pasteInto"                                           ,"contents": "${1:ofPixels}.pasteInto(${2:ofPixels_< PixelType > &dst}, ${3:int x}, ${4:int y})" },
        { "trigger": "ofPixels::resize"                                              ,"contents": "${1:ofPixels}.resize(${2:int dstWidth}, ${3:int dstHeight}, ${4:ofInterpolationMethod interpMethod=OF_INTERPOLATE_NEAREST_NEIGHBOR})" },
        { "trigger": "ofPixels::resizeTo"                                            ,"contents": "${1:ofPixels}.resizeTo(${2:ofPixels_< PixelType > &dst}, ${4:ofInterpolationMethod interpMethod=OF_INTERPOLATE_NEAREST_NEIGHBOR})" },
        { "trigger": "ofPixels::rotate"                                              ,"contents": "${1:ofPixels}.rotate(${2:int nClockwiseRotations})" },
        { "trigger": "ofPixels::rotate \t(PixelType)"                                ,"contents": "${1:ofPixels}.rotate(${2:ofPixels_< PixelType > &dst}, ${3:int nClockwiseRotations})" },
        { "trigger": "ofPixels::set \t(PixelType)"                                   ,"contents": "${1:ofPixels}.set(${2:PixelType val})" },
        { "trigger": "ofPixels::set \t(channel)"                                     ,"contents": "${1:ofPixels}.set(${2:int channel, PixelType val})" },
        { "trigger": "ofPixels::setChannel"                                          ,"contents": "${1:ofPixels}.setChannel(${2:int channel, ${3:const ofPixels_< PixelType > channelPixels})" },
        { "trigger": "ofPixels::setColor"                                            ,"contents": "${1:ofPixels}.setColor(${2:int x, ${3:int y}, ${4:ofColor_< PixelType > color})" },
        { "trigger": "ofPixels::setFromAlignedPixels"                                ,"contents": "${1:ofPixels}.setFromAlignedPixels(${2:const PixelType *newPixels}, ${3:int width}, ${4:int height}, ${5:int channels}, ${6:int stride})" },
        { "trigger": "ofPixels::setFromExternalPixels"                               ,"contents": "${1:ofPixels}.setFromExternalPixels(${2:PixelType *newPixels}, ${3:int w}, ${4:int h}, ${5:int channels})" },
        { "trigger": "ofPixels::setFromPixels \t(PixelType)"                         ,"contents": "${1:ofPixels}.setFromPixels(${2:const PixelType *newPixels}, ${3:int w}, ${4:int h}, ${5:int channels})" },
        { "trigger": "ofPixels::setFromPixels \t(ofImageType)"                       ,"contents": "${1:ofPixels}.setFromPixels(${2:const PixelType *newPixels}, ${3:int w}, ${4:int h}, ${5:ofImageType type})" },
        { "trigger": "ofPixels::setImageType"                                        ,"contents": "${1:ofPixels}.setImageType(${2:ofImageType imageType})" },
        { "trigger": "ofPixels::setNumChannels"                                      ,"contents": "${1:ofPixels}.setNumChannels(${2:int numChannels})" },
        { "trigger": "ofPixels::size"                                                ,"contents": "${1:ofPixels}.size()" },
        { "trigger": "ofPixels::swap"                                                ,"contents": "${1:ofPixels}.swap(${2:ofPixels_< PixelType > &pix})" },
        { "trigger": "ofPixels::swapRgb"                                             ,"contents": "${1:ofPixels}.swapRgb(})" },
        /////////////////////////////////////////////
        // ofPolyUtils
        { "trigger": "ofGetBoundingBox \t(const ofPolyline)"                                                ,"contents": "ofGetBoundingBox(${1:const ofPolyline &polyline})"},
        { "trigger": "ofGetClosestPoint \t(const ofPoint, const ofPoint, const ofPoint, float)"             ,"contents": "ofGetClosestPoint(${1:const ofPoint &p1}, ${2:const ofPoint &p2}, ${3:const ofPoint &p3}, ${4:float *normalizedPosition=NULL})"},
        { "trigger": "ofGetResampledCount \t(const ofPolyline, int)"                                        ,"contents": "ofGetResampledCount(${1:const ofPolyline &polyline}, ${2:int count})"},
        { "trigger": "ofGetResampledSpacing \t(const ofPolyline, float)"                                    ,"contents": "ofGetResampledSpacing(${1:const ofPolyline &polyline}, ${2:float spacing})"},
        { "trigger": "ofGetSmoothed \t(const ofPolyline, int, float)"                                       ,"contents": "ofGetSmoothed(${1:const ofPolyline &polyline}, ${2:int smoothingSize}, ${3:float smoothingShape=0})"},
        ///////////////////////////////////////////
        // ofCamera
        { "trigger": "ofCamera::begin \t(ofRectangle)"                               ,"contents": "${1:ofCamera}.begin(${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::cacheMatrices \t(bool)"                              ,"contents": "${1:ofCamera}.cacheMatrices(${2:bool cache=true})"},
        { "trigger": "ofCamera::cameraToWorld \t(ofVec3f, ofRectangle)"              ,"contents": "${1:ofCamera}.cameraToWorld(${2:ofVec3f CameraXYZ}, ${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::disableOrtho"                                        ,"contents": "${1:ofCamera}.disableOrtho()"},
        { "trigger": "ofCamera::enableOrtho"                                         ,"contents": "${1:ofCamera}.enableOrtho()"},
        { "trigger": "ofCamera::end"                                                 ,"contents": "${1:ofCamera}.end()"},
        { "trigger": "ofCamera::getFarClip"                                          ,"contents": "${1:ofCamera}.getFarClip()"},
        { "trigger": "ofCamera::getImagePlaneDistance \t(ofRectangle)"               ,"contents": "${1:ofCamera}.getImagePlaneDistance(${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::getModelViewMatrix"                                  ,"contents": "${1:ofCamera}.getModelViewMatrix()"},
        { "trigger": "ofCamera::getModelViewProjectionMatrix \t(ofRectangle)"        ,"contents": "${1:ofCamera}.getModelViewProjectionMatrix(${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::getNearClip"                                         ,"contents": "${1:ofCamera}.getNearClip()"},
        { "trigger": "ofCamera::getOrtho"                                            ,"contents": "${1:ofCamera}.getOrtho()"},
        { "trigger": "ofCamera::getProjectionMatrix"                                 ,"contents": "${1:ofCamera}.getProjectionMatrix(${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::screenToWorld \t(ofVec3f, ofRectangle)"              ,"contents": "${1:ofCamera}.screenToWorld(${2:ofVec3f ScreenXYZ, ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::setFarClip \t(float)"                                ,"contents": "${1:ofCamera}.setFarClip(${2:float f})"},
        { "trigger": "ofCamera::setFov \t(float)"                                    ,"contents": "${1:ofCamera}.setFov(${2:float f})"},
        { "trigger": "ofCamera::setNearClip \t(float)"                               ,"contents": "${1:ofCamera}.setNearClip(${2:float f})"},
        { "trigger": "ofCamera::setupPerspective"                                    ,"contents": "${1:ofCamera}.setupPerspective(${2:bool vFlip=true}, ${3:float fov=60}, ${4:float nearDist=0}, ${5:float farDist=0})"},
        { "trigger": "ofCamera::worldToCamera \t(ofVec3f, ofRectangle)"              ,"contents": "${1:ofCamera}.worldToCamera(${2:ofVec3f WorldXYZ}, ${3:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::worldToScreen"                                       ,"contents": "${1:ofCamera}.worldToScreen(${2:ofVec3f WorldXYZ}, ${3:ofRectangle viewport=ofGetCurrentViewport()})"},
        ////////////////////////////////////
        // ofEasyCam
        { "trigger": "ofEasyCam::begin \t(ofRectangle)"                              ,"contents": "${1:ofEasyCAm}.begin(${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofEasyCam::disableMouseInput"                                  ,"contents": "${1:ofEasyCAm}.disableMouseInput()"},
        { "trigger": "ofEasyCam::disableMouseMiddleButton"                           ,"contents": "${1:ofEasyCAm}.disableMouseMiddleButton()"},
        { "trigger": "ofEasyCam::enableMouseInput"                                   ,"contents": "${1:ofEasyCAm}.enableMouseInput()"},
        { "trigger": "ofEasyCam::enableMouseMiddleButton"                            ,"contents": "${1:ofEasyCAm}.enableMouseMiddleButton()"},
        { "trigger": "ofEasyCam::getDistance"                                        ,"contents": "${1:ofEasyCAm}.getDistance()"},
        { "trigger": "ofEasyCam::getDrag"                                            ,"contents": "${1:ofEasyCAm}.getDrag()"},
        { "trigger": "ofEasyCam::getMouseInputEnabled"                               ,"contents": "${1:ofEasyCAm}.getMouseInputEnabled()"},
        { "trigger": "ofEasyCam::getMouseMiddleButtonEnabled"                        ,"contents": "${1:ofEasyCAm}.getMouseMiddleButtonEnabled()"},
        { "trigger": "ofEasyCam::getTarget"                                          ,"contents": "${1:ofEasyCAm}.getTarget()"},
        { "trigger": "ofEasyCam::getTranslationKey"                                  ,"contents": "${1:ofEasyCAm}.getTranslationKey()"},
        { "trigger": "ofEasyCam::mouseDragged \t(ofMouseEventArgs)"                  ,"contents": "${1:ofEasyCAm}.mouseDragged(${2:ofMouseEventArgs &mouse})"},
        { "trigger": "ofEasyCam::mouseMoved \t(ofMouseEventArgs)"                    ,"contents": "${1:ofEasyCAm}.mouseMoved(${2:ofMouseEventArgs &mouse})"},
        { "trigger": "ofEasyCam::mousePressed \t(ofMouseEventArgs)"                  ,"contents": "${1:ofEasyCAm}.mousePressed(${2:ofMouseEventArgs &mouse})"},
        { "trigger": "ofEasyCam::mouseReleased \t(ofMouseEventArgs)"                 ,"contents": "${1:ofEasyCAm}.mouseReleased(${2:ofMouseEventArgs &mouse})"},
        { "trigger": "ofEasyCam::reset"                                              ,"contents": "${1:ofEasyCAm}.reset()"},
        { "trigger": "ofEasyCam::setDistance \t(float)"                              ,"contents": "${1:ofEasyCAm}.setDistance(${2:float distance})"},
        { "trigger": "ofEasyCam::setDrag \t(float)"                                  ,"contents": "${1:ofEasyCAm}.setDrag(${2:float drag})"},
        { "trigger": "ofEasyCam::setTarget \t(const ofVec3f)"                        ,"contents": "${1:ofEasyCAm}.setTarget(${2:const ofVec3f &target})"},
        { "trigger": "ofEasyCam::setTarget \t(ofNode)"                               ,"contents": "${1:ofEasyCAm}.setTarget(${2:ofNode &target})"},
        { "trigger": "ofEasyCam::setTranslationKey \t(char)"                         ,"contents": "${1:ofEasyCAm}.setTranslationKey(${2:char key})"},
        /////////////////////////////////
        // ofMesh Primitives Modes
        { "trigger": "OF_PRIMITIVE_TRIANGLES"                                        ,"contents": "OF_PRIMITIVE_TRIANGLES"},
        { "trigger": "OF_PRIMITIVE_TRIANGLE_STRIP"                                   ,"contents": "OF_PRIMITIVE_TRIANGLE_STRIP"},
        { "trigger": "OF_PRIMITIVE_TRIANGLE_FAN"                                     ,"contents": "OF_PRIMITIVE_TRIANGLE_FAN"},
        { "trigger": "OF_PRIMITIVE_LINES"                                            ,"contents": "OF_PRIMITIVE_LINES"},
        { "trigger": "OF_PRIMITIVE_LINE_STRIP"                                       ,"contents": "OF_PRIMITIVE_LINE_STRIP"},
        { "trigger": "OF_PRIMITIVE_LINE_LOOP"                                        ,"contents": "OF_PRIMITIVE_LINE_LOOP"},
        { "trigger": "OF_PRIMITIVE_POINTS"                                           ,"contents": "OF_PRIMITIVE_POINTS"},
        /////////////////////////////////
        // ofMesh
        { "trigger": "ofMesh::addColor \t(const ofFloatColor)"                                  ,"contents": "${1:ofMesh}.addColor(${2:const ofFloatColor &c})"},
        { "trigger": "ofMesh::addColors \t(const vector< ofFloatColor >)"                       ,"contents": "${1:ofMesh}.addColors(${2:const vector< ofFloatColor > &cols})"},
        { "trigger": "ofMesh::addColors \t(const ofFloatColor, int)"                            ,"contents": "${1:ofMesh}.addColors(${2:const ofFloatColor *cols}, ${3:int amt})"},
        { "trigger": "ofMesh::addIndex \t(ofIndexType)"                                         ,"contents": "${1:ofMesh}.addIndex(${2:ofIndexType i})"},
        { "trigger": "ofMesh::addIndices \t(const vector< ofIndexType >)"                       ,"contents": "${1:ofMesh}.addIndices(${2:const vector< ofIndexType > &inds})"},
        { "trigger": "ofMesh::addIndices \t(const ofIndexType, int)"                            ,"contents": "${1:ofMesh}.addIndices(${2:const ofIndexType *inds}, ${3:int amt})"},
        { "trigger": "ofMesh::addNormal \t(const ofVec3f)"                                      ,"contents": "${1:ofMesh}.addNormal(${2:const ofVec3f &n})"},
        { "trigger": "ofMesh::addNormals \t(const vector< ofVec3f >)"                           ,"contents": "${1:ofMesh}.addNormals(${2:const vector< ofVec3f > &norms})"},
        { "trigger": "ofMesh::addNormals \t(const ofVec3f, int)"                                ,"contents": "${1:ofMesh}.addNormals(${2:const ofVec3f *norms}, ${3:int amt})"},
        { "trigger": "ofMesh::addTexCoord \t(const ofVec2f)"                                    ,"contents": "${1:ofMesh}.addTexCoord(${2:const ofVec2f &t})"},
        { "trigger": "ofMesh::addTexCoords \t(const vector< ofVec2f >)"                         ,"contents": "${1:ofMesh}.addTexCoords(${2:const vector< ofVec2f > &tCoords})"},
        { "trigger": "ofMesh::addTexCoords \t(const ofVec2f, int)"                              ,"contents": "${1:ofMesh}.addTexCoords(${2:const ofVec2f *tCoords}, ${3:int amt})"},
        { "trigger": "ofMesh::addTriangle \t(ofIndexType, ofIndexType, ofIndexType)"            ,"contents": "${1:ofMesh}.addTriangle(${2:ofIndexType index1}, ${3:ofIndexType index2}, ${3:ofIndexType index3})"},
        { "trigger": "ofMesh::addVertex \t(const ofVec3f)"                                      ,"contents": "${1:ofMesh}.addVertex(${2:const ofVec3f &v})"},
        { "trigger": "ofMesh::addVertices \t(const vector< ofVec3f >)"                          ,"contents": "${1:ofMesh}.addVertices(${2:const vector< ofVec3f > &verts})"},
        { "trigger": "ofMesh::addVertices \t(const ofVec3f, int)"                               ,"contents": "${1:ofMesh}.addVertices(${2:const ofVec3f *verts}, ${3:int amt})"},
        { "trigger": "ofMesh::clear"                                                            ,"contents": "${1:ofMesh}.clear()"},
        { "trigger": "ofMesh::clearColors"                                                      ,"contents": "${1:ofMesh}.clearColors()"},
        { "trigger": "ofMesh::clearIndices"                                                     ,"contents": "${1:ofMesh}.clearIndices()"},
        { "trigger": "ofMesh::clearNormals"                                                     ,"contents": "${1:ofMesh}.clearNormals()"},
        { "trigger": "ofMesh::clearTexCoords"                                                   ,"contents": "${1:ofMesh}.clearTexCoords()"},
        { "trigger": "ofMesh::clearVertices"                                                    ,"contents": "${1:ofMesh}.clearVertices()"},
        { "trigger": "ofMesh::disableColors"                                                    ,"contents": "${1:ofMesh}.disableColors()"},
        { "trigger": "ofMesh::disableIndices"                                                   ,"contents": "${1:ofMesh}.disableIndices()"},
        { "trigger": "ofMesh::disableNormals"                                                   ,"contents": "${1:ofMesh}.disableNormals()"},
        { "trigger": "ofMesh::disableTextures"                                                  ,"contents": "${1:ofMesh}.disableTextures()"},
        { "trigger": "ofMesh::draw"                                                             ,"contents": "${1:ofMesh}.draw()"},
        { "trigger": "ofMesh::drawFaces"                                                        ,"contents": "${1:ofMesh}.drawFaces()"},
        { "trigger": "ofMesh::drawVertices"                                                     ,"contents": "${1:ofMesh}.drawVertices()"},
        { "trigger": "ofMesh::drawWireframe"                                                    ,"contents": "${1:ofMesh}.drawWireframe()"},
        { "trigger": "ofMesh::enableColors"                                                     ,"contents": "${1:ofMesh}.enableColors()"},
        { "trigger": "ofMesh::enableIndices"                                                    ,"contents": "${1:ofMesh}.enableIndices()"},
        { "trigger": "ofMesh::enableNormals"                                                    ,"contents": "${1:ofMesh}.enableNormals()"},
        { "trigger": "ofMesh::enableTextures"                                                   ,"contents": "${1:ofMesh}.enableTextures()"},
        { "trigger": "ofMesh::getCentroid"                                                      ,"contents": "${1:ofMesh}.getCentroid()"},
        { "trigger": "ofMesh::getColor \t(int)"                                                 ,"contents": "${1:ofMesh}.getColor(${2:int i})"},
        { "trigger": "ofMesh::getColor \t(ofIndexType)"                                         ,"contents": "${1:ofMesh}.getColor(${2:ofIndexType i})"},
        { "trigger": "ofMesh::getColors"                                                        ,"contents": "${1:ofMesh}.getColors()"},
        { "trigger": "ofMesh::getColorsPointer"                                                 ,"contents": "${1:ofMesh}.getColorsPointer()"},
        { "trigger": "ofMesh::getFace (int)"                                                    ,"contents": "${1:ofMesh}.getFace(${2:int faceId})"},
        { "trigger": "ofMesh::getIndex \t(int)"                                                 ,"contents": "${1:ofMesh}.getIndex(${2:int i})"},
        { "trigger": "ofMesh::getIndex \t(ofIndexType)"                                         ,"contents": "${1:ofMesh}.getIndex(${2:ofIndexType i})"},
        { "trigger": "ofMesh::getIndexPointer"                                                  ,"contents": "${1:ofMesh}.getIndexPointer()"},
        { "trigger": "ofMesh::getIndices"                                                       ,"contents": "${1:ofMesh}.getIndices()"},
        { "trigger": "ofMesh::getMode"                                                          ,"contents": "${1:ofMesh}.getMode()"},
        { "trigger": "ofMesh::getNormal \t(int)"                                                ,"contents": "${1:ofMesh}.getNormal(${2:int i})"},
        { "trigger": "ofMesh::getNormal \t(ofIndexType)"                                        ,"contents": "${1:ofMesh}.getNormal(${2:ofIndexType i})"},
        { "trigger": "ofMesh::getNormals"                                                       ,"contents": "${1:ofMesh}.getNormals()"},
        { "trigger": "ofMesh::getNormalsPointer"                                                ,"contents": "${1:ofMesh}.getNormalsPointer()"},
        { "trigger": "ofMesh::getNumColors"                                                     ,"contents": "${1:ofMesh}.getNumColors()"},
        { "trigger": "ofMesh::getNumIndices"                                                    ,"contents": "${1:ofMesh}.getNumIndices()"},
        { "trigger": "ofMesh::getNumNormals"                                                    ,"contents": "${1:ofMesh}.getNumNormals()"},
        { "trigger": "ofMesh::getNumTexCoords"                                                  ,"contents": "${1:ofMesh}.getNumTexCoords()"},
        { "trigger": "ofMesh::getNumVertices"                                                   ,"contents": "${1:ofMesh}.getNumVertices()"},
        { "trigger": "ofMesh::getTexCoord \t(int)"                                              ,"contents": "${1:ofMesh}.getTexCoord(${2:int i})"},
        { "trigger": "ofMesh::getTexCoord \t(ofIndexType)"                                      ,"contents": "${1:ofMesh}.getTexCoord(${2:ofIndexType i})"},
        { "trigger": "ofMesh::getTexCoords"                                                     ,"contents": "${1:ofMesh}.getTexCoords()"},
        { "trigger": "ofMesh::getTexCoordsPointer"                                              ,"contents": "${1:ofMesh}.getTexCoordsPointer()"},
        { "trigger": "ofMesh::getVertex \t(int)"                                                ,"contents": "${1:ofMesh}.getVertex(${2:int i})"},
        { "trigger": "ofMesh::getVertex \t(ofIndexType)"                                        ,"contents": "${1:ofMesh}.getVertex(${2:ofIndexType i})"},
        { "trigger": "ofMesh::getVertices"                                                      ,"contents": "${1:ofMesh}.getVertices()"},
        { "trigger": "ofMesh::getVerticesPointer"                                               ,"contents": "${1:ofMesh}.getVerticesPointer()"},
        { "trigger": "ofMesh::hasColors"                                                        ,"contents": "${1:ofMesh}.hasColors()"},
        { "trigger": "ofMesh::hasIndices"                                                       ,"contents": "${1:ofMesh}.hasIndices()"},
        { "trigger": "ofMesh::hasNormals"                                                       ,"contents": "${1:ofMesh}.hasNormals()"},
        { "trigger": "ofMesh::hasTexCoords"                                                     ,"contents": "${1:ofMesh}.hasTexCoords()"},
        { "trigger": "ofMesh::hasVertices"                                                      ,"contents": "${1:ofMesh}.hasVertices()"},
        { "trigger": "ofMesh::haveColorsChanged"                                                ,"contents": "${1:ofMesh}.haveColorsChanged()"},
        { "trigger": "ofMesh::haveIndicesChanged"                                               ,"contents": "${1:ofMesh}.haveIndicesChanged()"},
        { "trigger": "ofMesh::haveNormalsChanged"                                               ,"contents": "${1:ofMesh}.haveNormalsChanged()"},
        { "trigger": "ofMesh::haveTexCoordsChanged"                                             ,"contents": "${1:ofMesh}.haveTexCoordsChanged()"},
        { "trigger": "ofMesh::haveVertsChanged"                                                 ,"contents": "${1:ofMesh}.haveVertsChanged()"},
        { "trigger": "ofMesh::load \t(string)"                                                  ,"contents": "${1:ofMesh}.load(${2:string path})"},
        { "trigger": "ofMesh::removeColor \t(int)"                                              ,"contents": "${1:ofMesh}.removeColor(${2:int index})"},
        { "trigger": "ofMesh::removeColor \t(ofIndexType)"                                      ,"contents": "${1:ofMesh}.removeColor(${2:ofIndexType index})"},
        { "trigger": "ofMesh::removeIndex \t(int)"                                              ,"contents": "${1:ofMesh}.removeIndex(${2:int i})"},
        { "trigger": "ofMesh::removeIndex \t(ofIndexType)"                                      ,"contents": "${1:ofMesh}.removeIndex(${2:ofIndexType index})"},
        { "trigger": "ofMesh::removeNormal \t(int)"                                             ,"contents": "${1:ofMesh}.removeNormal(${2:int index})"},
        { "trigger": "ofMesh::removeNormal \t(ofIndexType)"                                     ,"contents": "${1:ofMesh}.removeNormal(${2:ofIndexType index})"},
        { "trigger": "ofMesh::removeTexCoord \t(int)"                                           ,"contents": "${1:ofMesh}.removeTexCoord(${2:int index})"},
        { "trigger": "ofMesh::removeTexCoord \t(ofIndexType)"                                   ,"contents": "${1:ofMesh}.removeTexCoord(${2:ofIndexType index})"},
        { "trigger": "ofMesh::removeVertex \t(int)"                                             ,"contents": "${1:ofMesh}.removeVertex(${2:int index})"},
        { "trigger": "ofMesh::removeVertex \t(ofIndexType)"                                     ,"contents": "${1:ofMesh}.removeVertex(${2:ofIndexType index})"},
        { "trigger": "ofMesh::save \t(string, bool)"                                            ,"contents": "${1:ofMesh}.save(${2:string path}, ${3:bool useBinary=false})"},
        { "trigger": "ofMesh::setColor \t(int, const ofFloatColor)"                             ,"contents": "${1:ofMesh}.setColor(${2:int index}, ${:3const ofFloatColor &c})"},
        { "trigger": "ofMesh::setColor \t(ofIndexType, const ofFloatColor)"                     ,"contents": "${1:ofMesh}.setColor(${2:ofIndexType index}, ${3:const ofFloatColor &c})"},
        { "trigger": "ofMesh::setIndex \t(int, ofIndexType)"                                    ,"contents": "${1:ofMesh}.setIndex(${2:int i}, ${3:ofIndexType val})"},
        { "trigger": "ofMesh::setIndex \t(ofIndexType, ofIndexType)"                            ,"contents": "${1:ofMesh}.setIndex(${2:ofIndexType index}, ${3:ofIndexType val})"},
        { "trigger": "ofMesh::setMode \t(ofPrimitiveMode)"                                      ,"contents": "${1:ofMesh}.setMode(${2:ofPrimitiveMode mode})"},
        { "trigger": "ofMesh::setName     \t(string)"                                           ,"contents": "${1:ofMesh}.setName(${2:string name_})"},
        { "trigger": "ofMesh::setNormal \t(int, const ofVec3f)"                                 ,"contents": "${1:ofMesh}.setNormal(${2:int index}, ${3:const ofVec3f &n})"},
        { "trigger": "ofMesh::setTexCoord \t(int, const ofVec2f)"                               ,"contents": "${1:ofMesh}.setTexCoord(${2:int index}, ${3:const ofVec2f &t})"},
        { "trigger": "ofMesh::setTexCoord \t(ofIndexType, const ofVec2f)"                       ,"contents": "${1:ofMesh}.setTexCoord(${2:ofIndexType index}, ${3:const ofVec2f &t})"},
        { "trigger": "ofMesh::setVertex \t(int, const ofVec3f)"                                 ,"contents": "${1:ofMesh}.setVertex(${2:int index}, ${3:const ofVec3f &v})"},
        { "trigger": "ofMesh::setVertex \t(ofIndexType, const ofVec3f)"                         ,"contents": "${1:ofMesh}.setVertex(${2:ofIndexType index}, ${3:const ofVec3f &v})"},
        { "trigger": "ofMesh::setupIndicesAuto"                                                 ,"contents": "${1:ofMesh}.setupIndicesAuto()"},
        { "trigger": "ofMesh::usingColors"                                                      ,"contents": "${1:ofMesh}.usingColors()"},
        { "trigger": "ofMesh::usingIndices"                                                     ,"contents": "${1:ofMesh}.usingIndices()"},
        { "trigger": "ofMesh::usingNormals"                                                     ,"contents": "${1:ofMesh}.usingNormals()"},
        { "trigger": "ofMesh::usingTextures"                                                    ,"contents": "${1:ofMesh}.usingTextures()"},
        /////////////////////////////////
        // ofNode
        { "trigger": "ofNode::boom\t(float)"                                         ,"contents": "${1:ofNode}.boom(${2:float amount})"},
        { "trigger": "ofNode::clearParent"                                           ,"contents": "${1:ofNode}.clearParent()"},
        { "trigger": "ofNode::customDraw"                                            ,"contents": "${1:ofNode}.customDraw()"},
        { "trigger": "ofNode::dolly\t(float)"                                        ,"contents": "${1:ofNode}.dolly(${2:float amount})"},
        { "trigger": "ofNode::draw"                                                  ,"contents": "${1:ofNode}.draw()"},
        { "trigger": "ofNode::getGlobalOrientation"                                  ,"contents": "${1:ofNode}.getGlobalOrientation()"},
        { "trigger": "ofNode::getGlobalPosition"                                     ,"contents": "${1:ofNode}.getGlobalPosition()"},
        { "trigger": "ofNode::getGlobalScale"                                        ,"contents": "${1:ofNode}.getGlobalScale()"},
        { "trigger": "ofNode::getGlobalTransformMatrix"                              ,"contents": "${1:ofNode}.getGlobalTransformMatrix()"},
        { "trigger": "ofNode::getHeading"                                            ,"contents": "${1:ofNode}.getHeading()"},
        { "trigger": "ofNode::getLocalTransformMatrix"                               ,"contents": "${1:ofNode}.getLocalTransformMatrix()"},
        { "trigger": "ofNode::getLookAtDir"                                          ,"contents": "${1:ofNode}.getLookAtDir()"},
        { "trigger": "ofNode::getOrientationEuler"                                   ,"contents": "${1:ofNode}.getOrientationEuler()"},
        { "trigger": "ofNode::getOrientationQuat"                                    ,"contents": "${1:ofNode}.getOrientationQuat()"},
        { "trigger": "ofNode::getParent"                                             ,"contents": "${1:ofNode}.getParent()"},
        { "trigger": "ofNode::getPitch"                                              ,"contents": "${1:ofNode}.getPitch()"},
        { "trigger": "ofNode::getPosition"                                           ,"contents": "${1:ofNode}.getPosition()"},
        { "trigger": "ofNode::getRoll"                                               ,"contents": "${1:ofNode}.getRoll()"},
        { "trigger": "ofNode::getScale"                                              ,"contents": "${1:ofNode}.getScale()"},
        { "trigger": "ofNode::getSideDir"                                            ,"contents": "${1:ofNode}.getSideDir()"},
        { "trigger": "ofNode::getUpDir"                                              ,"contents": "${1:ofNode}.getUpDir()"},
        { "trigger": "ofNode::getX"                                                  ,"contents": "${1:ofNode}.getX()"},
        { "trigger": "ofNode::getXAxis"                                              ,"contents": "${1:ofNode}.getXAxis()"},
        { "trigger": "ofNode::getY"                                                  ,"contents": "${1:ofNode}.getY()"},
        { "trigger": "ofNode::getYAxis"                                              ,"contents": "${1:ofNode}.getYAxis()"},
        { "trigger": "ofNode::getZ"                                                  ,"contents": "${1:ofNode}.getZ()"},
        { "trigger": "ofNode::getZAxis"                                              ,"contents": "${1:ofNode}.getZAxis()"},
        { "trigger": "ofNode::lookAt\t(const ofVec3f, ofVec3f)"                      ,"contents": "${1:ofNode}.lookAt(${2:const ofVec3f &lookAtPosition}, ${3:ofVec3f upVector=ofVec3f(0, 1, 0)})"},
        { "trigger": "ofNode::lookAt\t(const ofNode, const ofVec3f)"                 ,"contents": "${1:ofNode}.lookAt(${2:const ofNode &lookAtNode}, ${3:const ofVec3f &upVector=ofVec3f(0, 1, 0)})"},
        { "trigger": "ofNode::move\t(float, float, float)    "                       ,"contents": "${1:ofNode}.move(${2:float x}, ${3:float y}, ${4:float z})"},
        { "trigger": "ofNode::move\t(const ofVec3f)  "                               ,"contents": "${1:ofNode}.move(${2:const ofVec3f &offset})"},
        { "trigger": "ofNode::orbit\t(float, float, float, const ofVec3f"            ,"contents": "${1:ofNode}.orbit(${2:float longitude}, ${3:float latitude}, ${4:float radius}, ${5:const ofVec3f &centerPoint=ofVec3f(0, 0, 0)})"},
        { "trigger": "ofNode::orbit\t(float, float, float, ofNode)   "               ,"contents": "${1:ofNode}.orbit(${2:float longitude}, ${3:float latitude}, ${4:float radius}, ${5:ofNode &centerNode})"},
        { "trigger": "ofNode::pan\t(float)   "                                       ,"contents": "${1:ofNode}.pan(${2:float degrees})"},
        { "trigger": "ofNode::resetTransform"                                        ,"contents": "${1:ofNode}.resetTransform()"},
        { "trigger": "ofNode::restoreTransformGL"                                    ,"contents": "${1:ofNode}.restoreTransformGL()"},
        { "trigger": "ofNode::roll\t(float)"                                         ,"contents": "${1:ofNode}.roll(${2:float degrees})"},
        { "trigger": "ofNode::rotate\t(const)"                                       ,"contents": "${1:ofNode}.rotate(${2:const ofQuaternion &q})"},
        ///////////////////////////////
        // ofFbo
        { "trigger": "ofFbo::allocate \t(int, int, int, int)"                                ,"contents": "${1:ofFbo}.allocate(${2:int width}, ${3:int height}, ${4:int internalformat=GL_RGBA}, ${5:int numSamples=0})"},
        { "trigger": "ofFbo::allocate \t(Settings)"                                          ,"contents": "${1:ofFbo}.allocate(${2:Settings settings=Settings()})"},
        { "trigger": "ofFbo::begin"                                                          ,"contents": "${1:ofFbo}.begin()"},
        { "trigger": "ofFbo::begin \t(bool)"                                                 ,"contents": "${1:ofFbo}.begin(${2:bool setupScreen=true})"},
        { "trigger": "ofFbo::bind"                                                           ,"contents": "${1:ofFbo}.bind()"},
        { "trigger": "ofFbo::checkGLSupport"                                                 ,"contents": "${1:ofFbo}.checkGLSupport()"},
        { "trigger": "ofFbo::draw \t(float, float)"                                          ,"contents": "${1:ofFbo}.draw(${2:float x}, ${3:float y})"},
        { "trigger": "ofFbo::draw \t(float, float, float, float)"                            ,"contents": "${1:ofFbo}.draw(${2:float x}, ${3:float y}, ${4:float width}, ${5:float height})"},
        { "trigger": "ofFbo::end"                                                            ,"contents": "${1:ofFbo}.end()"},
        { "trigger": "ofFbo::getDefaultTextureIndex"                                         ,"contents": "${1:ofFbo}.getDefaultTextureIndex()"},
        { "trigger": "ofFbo::getDepthBuffer"                                                 ,"contents": "${1:ofFbo}.getDepthBuffer()"},
        { "trigger": "ofFbo::getDepthTexture"                                                ,"contents": "${1:ofFbo}.getDepthTexture()"},
        { "trigger": "ofFbo::getFbo"                                                         ,"contents": "${1:ofFbo}.getFbo()"},
        { "trigger": "ofFbo::getHeight"                                                      ,"contents": "${1:ofFbo}.getHeight()"},
        { "trigger": "ofFbo::getNumTextures"                                                 ,"contents": "${1:ofFbo}.getNumTextures()"},
        { "trigger": "ofFbo::getStencilBuffer"                                               ,"contents": "${1:ofFbo}.getStencilBuffer()"},
        { "trigger": "ofFbo::getTextureReference"                                            ,"contents": "${1:ofFbo}.getTextureReference()"},
        { "trigger": "ofFbo::getTextureReference \t(int)"                                    ,"contents": "${1:ofFbo}.getTextureReference(${2:int attachmentPoint})"},
        { "trigger": "ofFbo::getWidth"                                                       ,"contents": "${1:ofFbo}.getWidth()"},
        { "trigger": "ofFbo::isAllocated"                                                    ,"contents": "${1:ofFbo}.isAllocated()"},
        { "trigger": "ofFbo::maxColorAttachments"                                            ,"contents": "${1:ofFbo}.maxColorAttachments()"},
        { "trigger": "ofFbo::maxDrawBuffers"                                                 ,"contents": "${1:ofFbo}.maxDrawBuffers()"},
        { "trigger": "ofFbo::maxSamples"                                                     ,"contents": "${1:ofFbo}.maxSamples()"},
        { "trigger": "ofFbo::operator= \t(const ofFbo)"                                      ,"contents": "${1:ofFbo}.operator=(${2:const ofFbo &fbo})"},
        { "trigger": "ofFbo::readToPixels \t(ofPixels, int)"                                 ,"contents": "${1:ofFbo}.readToPixels(${2:ofPixels &pixels}, ${3:int attachmentPoint=0})"},
        { "trigger": "ofFbo::readToPixels \t(ofShortPixels, int)"                            ,"contents": "${1:ofFbo}.readToPixels(${2:ofShortPixels &pixels}, ${3:int attachmentPoint=0})"},
        { "trigger": "ofFbo::readToPixels \t(ofFloatPixels, int)"                            ,"contents": "${1:ofFbo}.readToPixels(${2:ofFloatPixels &pixels}, ${3:int attachmentPoint=0})"},
        { "trigger": "ofFbo::resetAnchor"                                                    ,"contents": "${1:ofFbo}.resetAnchor()"},
        { "trigger": "ofFbo::setActiveDrawBuffer \t(int)"                                    ,"contents": "${1:ofFbo}.setActiveDrawBuffer(${2:int i})"},
        { "trigger": "ofFbo::setActiveDrawBuffers \t(const vector< int >)"                   ,"contents": "${1:ofFbo}.setActiveDrawBuffers(${2:const vector< int > &i})"},
        { "trigger": "ofFbo::setAnchorPercent \t(float xPct, float yPct)  "                  ,"contents": "${1:ofFbo}.setAnchorPercent(${2:float xPct}, ${3:float yPct})"},
        { "trigger": "ofFbo::setAnchorPoint \t(float, float)"                                ,"contents": "${1:ofFbo}.setAnchorPoint(${2:float x}, ${3:float y})"},
        { "trigger": "ofFbo::setDefaultTextureIndex \t(int)"                                 ,"contents": "${1:ofFbo}.setDefaultTextureIndex(${2:int defaultTexture})"},
        { "trigger": "ofFbo::setUseTexture \t(bool)"                                         ,"contents": "${1:ofFbo}.setUseTexture(${2:bool bUseTex})"},
        { "trigger": "ofFbo::unbind"                                                         ,"contents": "${1:ofFbo}.unbind()"},
        
        /////////////////////////////////
        // ofGLRenderer 
        { "trigger": "ofGLRenderer::bClearBg"                                                                                   ,"contents": "${1:ofGLRenderer}.bClearBg()"},
        { "trigger": "ofGLRenderer::background \t(const ofColor)"                                                               ,"contents": "${1:ofGLRenderer}.background(${2:const ofColor &c})"},
        { "trigger": "ofGLRenderer::background \t(float)"                                                                       ,"contents": "${1:ofGLRenderer}.background(${2:float brightness})"},
        { "trigger": "ofGLRenderer::background \t(int, float)"                                                                  ,"contents": "${1:ofGLRenderer}.background(${2:int hexColor}, ${3:float} ${4:_a=255.0f})"},
        { "trigger": "ofGLRenderer::background \t(int, int, int, int)"                                                          ,"contents": "${1:ofGLRenderer}.background(${2:int r}, ${3:int g}, ${4:int b}, ${5:int a=255})"},
        { "trigger": "ofGLRenderer::clear \t(float, float, float, float)"                                                       ,"contents": "${1:ofGLRenderer}.clear(${2:float r}, ${3:float g}, ${4:float b}, ${5:float a=0})"},
        { "trigger": "ofGLRenderer::clear \t(float, float)"                                                                     ,"contents": "${1:ofGLRenderer}.clear(${2:float brightness}, ${3:float a=0})"},
        { "trigger": "ofGLRenderer::clearAlpha"                                                                                 ,"contents": "${1:ofGLRenderer}.clearAlpha()"},
        { "trigger": "ofGLRenderer::disablePointSprites"                                                                        ,"contents": "${1:ofGLRenderer}.disablePointSprites()"},
        { "trigger": "ofGLRenderer::draw \t(ofMesh)"                                                                            ,"contents": "${1:ofGLRenderer}.draw(${2:ofMesh &vertexData})"},
        { "trigger": "ofGLRenderer::draw \t(ofMesh, ofPolyRenderMode)"                                                          ,"contents": "${1:ofGLRenderer}.draw(${2:ofMesh &vertexData}, ${3:ofPolyRenderMode renderType})"},
        { "trigger": "ofGLRenderer::draw \t(ofPolyline)"                                                                        ,"contents": "${1:ofGLRenderer}.draw(${2:ofPolyline &poly})"},
        { "trigger": "ofGLRenderer::draw \t(ofPath)"                                                                            ,"contents": "${1:ofGLRenderer}.draw(${2:ofPath &path})"},
        { "trigger": "ofGLRenderer::draw \t(vector< ofPoint >, ofPrimitiveMode)"                                                ,"contents": "${1:ofGLRenderer}.draw(${2:vector< ofPoint > &vertexData}, ${3:ofPrimitiveMode drawMode})"},
        { "trigger": "ofGLRenderer::draw \t(ofImage, float, float, float, float, float)"                                        ,"contents": "${1:ofGLRenderer}.draw(${2:ofImage &image}, ${3:float x}, ${4:float y}, ${5:float z}, ${6:float w}, ${7:float h})"},
        { "trigger": "ofGLRenderer::draw \t(ofFloatImage, float, float, float, float, float)"                                   ,"contents": "${1:ofGLRenderer}.draw(${2:ofFloatImage &image}, ${3:float x}, ${4:float y}, ${5:float z}, ${6:float w}, ${7:float h})"},
        { "trigger": "ofGLRenderer::draw \t(ofShortImage, float, float, float, float, float)"                                   ,"contents": "${1:ofGLRenderer}.draw(${2:ofShortImage &image}, ${3:float x}, ${4:float y}, ${5:float z}, ${6:float w}, ${7:float h})"},
        { "trigger": "ofGLRenderer::draw \t(ofMesh, bool, bool, bool)"                                                          ,"contents": "${1:ofGLRenderer}.draw(${2:ofMesh &vertexData}, ${3:bool useColors=true}, ${4:bool useTextures=true}, ${5:bool useNormals=true)}"},
        { "trigger": "ofGLRenderer::draw \t(ofMesh, ofPolyRenderMode, bool, bool, bool)"                                        ,"contents": "${1:ofGLRenderer}.draw(${2:ofMesh &vertexData}, ${3:ofPolyRenderMode renderType}, ${4:bool useColors=true}, ${5:bool useTextures=true}, ${6:bool useNormals=true})"},
        { "trigger": "ofGLRenderer::draw \t(ofImage, float, float, float, float, float, float, float, float, float)"            ,"contents": "${1:ofGLRenderer}.draw(${2:ofImage       &image}, ${3:float x}, ${4:float y}, ${5:float z}, ${6:float w}, ${7:float h}, ${8:float sx}, ${9:float sy}, ${10:float sw}, ${11:float sh})"},
        { "trigger": "ofGLRenderer::draw \t(ofFloatImage, float, float, float, float, float, float, float, float, float)"       ,"contents": "${1:ofGLRenderer}.draw(${2:ofFloatImage  &image}, ${3:float x}, ${4:float y}, ${5:float z}, ${6:float w}, ${7:float h}, ${8:float sx}, ${9:float sy}, ${10:float sw}, ${11:float sh})"},
        { "trigger": "ofGLRenderer::draw \t(ofShortImage, float, float, float, float, float, float, float, float, float)"       ,"contents": "${1:ofGLRenderer}.draw(${2:ofShortImage  &image}, ${3:float x}, ${4:float y}, ${5:float z}, ${6:float w}, ${7:float h}, ${8:float sx}, ${9:float sy}, ${10:float sw}, ${11:float sh})"},
        { "trigger": "ofGLRenderer::drawCircle \t(float, float, float, float)"                                                  ,"contents": "${1:ofGLRenderer}.drawCircle(${2:float x}, ${3:float y}, ${4:float z}, ${5:float radius})"},
        { "trigger": "ofGLRenderer::drawEllipse \t(float, float, float, float, float)"                                          ,"contents": "${1:ofGLRenderer}.drawEllipse(${2:float x}, ${3:float y}, ${4:float z}, ${5:float width}, ${6:float height})"},
        { "trigger": "ofGLRenderer::drawLine \t(float, float, float, float, float, float)"                                      ,"contents": "${1:ofGLRenderer}.drawLine(${2:float x1}, ${3:float y1}, ${4:float z1}, ${5:float x2}, ${6:float y2}, ${7:float z2})"},
        { "trigger": "ofGLRenderer::drawRectangle \t(float, float, float, float, float)"                                        ,"contents": "${1:ofGLRenderer}.drawRectangle(${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h})"},
        { "trigger": "ofGLRenderer::drawSphere \t(float, float, float, float)"                                                  ,"contents": "${1:ofGLRenderer}.drawSphere(${2:float x}, ${3:float y}, ${4:float z}, ${5:float radius})"},
        { "trigger": "ofGLRenderer::drawString \t(string, float, float, float, ofDrawBitmapMode)"                               ,"contents": "${1:ofGLRenderer}.drawString(${2:string text}, ${3:float x}, ${4:float y}, ${5:float z}, ${6:ofDrawBitmapMode mode})"},
        { "trigger": "ofGLRenderer::drawTriangle( \tfloat, float, float, float, float, float, float, float, float)"             ,"contents": "${1:ofGLRenderer}.drawTriangle(${2:float x1}, ${3:float y1}, ${4:float z1}, ${5:float x2}, ${6:float y2}, ${7:float z2}, ${8:float x3}, ${9:float y3}, ${10:float z3})"},
        { "trigger": "ofGLRenderer::enablePointSprites"                                                                         ,"contents": "${1:ofGLRenderer}.enablePointSprites()"},
        { "trigger": "ofGLRenderer::getBgColor"                                                                                 ,"contents": "${1:ofGLRenderer}.getBgColor()"},
        { "trigger": "ofGLRenderer::getCoordHandedness"                                                                         ,"contents": "${1:ofGLRenderer}.getCoordHandedness()"},
        { "trigger": "ofGLRenderer::getCurrentViewport"                                                                         ,"contents": "${1:ofGLRenderer}.getCurrentViewport()"},
        { "trigger": "ofGLRenderer::getFillMode"                                                                                ,"contents": "${1:ofGLRenderer}.getFillMode()"},
        { "trigger": "ofGLRenderer::getRectMode"                                                                                ,"contents": "${1:ofGLRenderer}.getRectMode()"},
        { "trigger": "ofGLRenderer::getType"                                                                                    ,"contents": "${1:ofGLRenderer}.getType()"},
        { "trigger": "ofGLRenderer::getViewportHeight"                                                                          ,"contents": "${1:ofGLRenderer}.getViewportHeight()"},
        { "trigger": "ofGLRenderer::getViewportWidth"                                                                           ,"contents": "${1:ofGLRenderer}.getViewportWidth()"},
        { "trigger": "ofGLRenderer::loadIdentityMatrix \t(void)"                                                                ,"contents": "${1:ofGLRenderer}.loadIdentityMatrix(${2:void})"},
        { "trigger": "ofGLRenderer::loadMatrix \t(const ofMatrix4x4)"                                                           ,"contents": "${1:ofGLRenderer}.loadMatrix(${2:const ofMatrix4x4 &m})"},
        { "trigger": "ofGLRenderer::loadMatrix \t(const float)"                                                                 ,"contents": "${1:ofGLRenderer}.loadMatrix(${2:const float *m})"},
        { "trigger": "ofGLRenderer::multMatrix \t(const ofMatrix4x4)"                                                           ,"contents": "${1:ofGLRenderer}.multMatrix(${2:const ofMatrix4x4 &m})"},
        { "trigger": "ofGLRenderer::multMatrix \t(const float)"                                                                 ,"contents": "${1:ofGLRenderer}.multMatrix(${2:const float *m})"},
        { "trigger": "ofGLRenderer::popMatrix"                                                                                  ,"contents": "${1:ofGLRenderer}.popMatrix()"},
        { "trigger": "ofGLRenderer::popView"                                                                                    ,"contents": "${1:ofGLRenderer}.popView()"},
        { "trigger": "ofGLRenderer::pushMatrix"                                                                                 ,"contents": "${1:ofGLRenderer}.pushMatrix()"},
        { "trigger": "ofGLRenderer::pushView"                                                                                   ,"contents": "${1:ofGLRenderer}.pushView()"},
        { "trigger": "ofGLRenderer::rendersPathPrimitives"                                                                      ,"contents": "${1:ofGLRenderer}.rendersPathPrimitives()"},
        { "trigger": "ofGLRenderer::rotate \t(float, float, float, float)"                                                      ,"contents": "${1:ofGLRenderer}.rotate(${2:float degrees}, ${3:float vecX}, ${4:float vecY}, ${5:float vecZ})"},
        { "trigger": "ofGLRenderer::rotate \t(float)"                                                                           ,"contents": "${1:ofGLRenderer}.rotate(${2:float degrees})"},
        { "trigger": "ofGLRenderer::rotateX \t(float)"                                                                          ,"contents": "${1:ofGLRenderer}.rotateX(${2:float degrees})"},
        { "trigger": "ofGLRenderer::rotateY \t(float)"                                                                          ,"contents": "${1:ofGLRenderer}.rotateY(${2:float degrees})"},
        { "trigger": "ofGLRenderer::rotateZ \t(float)"                                                                          ,"contents": "${1:ofGLRenderer}.rotateZ(${2:float degrees})"},
        { "trigger": "ofGLRenderer::scale \t(float, float, float)"                                                              ,"contents": "${1:ofGLRenderer}.scale(${2:float xAmnt}, ${3:float yAmnt}, ${4:float zAmnt=1})"},
        { "trigger": "ofGLRenderer::setBackgroundAuto \t(bool)"                                                                 ,"contents": "${1:ofGLRenderer}.setBackgroundAuto(${2:bool bManual})"},
        { "trigger": "ofGLRenderer::setBlendMode \t(ofBlendMode)"                                                               ,"contents": "${1:ofGLRenderer}.setBlendMode(${2:ofBlendMode blendMode})"},
        { "trigger": "ofGLRenderer::setCircleResolution \t(int)"                                                                ,"contents": "${1:ofGLRenderer}.setCircleResolution(${2:int res})"},
        { "trigger": "ofGLRenderer::setColor \t(int, int, int)"                                                                 ,"contents": "${1:ofGLRenderer}.setColor(${2:int r}, ${3:int g}, ${4:int b})"},
        { "trigger": "ofGLRenderer::setColor \t(int, int, int, int)"                                                            ,"contents": "${1:ofGLRenderer}.setColor(${2:int r}, ${3:int g}, ${4:int b}, ${5:int a})"},
        { "trigger": "ofGLRenderer::setColor \t(const ofColor)"                                                                 ,"contents": "${1:ofGLRenderer}.setColor(${2:const ofColor &color})"},
        { "trigger": "ofGLRenderer::setColor \t(const ofColor, int)"                                                            ,"contents": "${1:ofGLRenderer}.setColor(${2:const ofColor &color}, ${3:int _a})"},
        { "trigger": "ofGLRenderer::setColor \t(int)"                                                                           ,"contents": "${1:ofGLRenderer}.setColor(${2:int gray})"},
        { "trigger": "ofGLRenderer::setCoordHandedness \t(ofHandednessType)"                                                    ,"contents": "${1:ofGLRenderer}.setCoordHandedness(${1:ofHandednessType handedness})"},
        { "trigger": "ofGLRenderer::setCurrentFBO \t(ofFbo)"                                                                    ,"contents": "${1:ofGLRenderer}.setCurrentFBO(${2:ofFbo *fbo})"},
        { "trigger": "ofGLRenderer::setFillMode \t(ofFillFlag)"                                                                 ,"contents": "${1:ofGLRenderer}.setFillMode(${2:ofFillFlag fill})"},
        { "trigger": "ofGLRenderer::setHexColor \t(int)"                                                                        ,"contents": "${1:ofGLRenderer}.setHexColor(${2:int hexColor})"},
        { "trigger": "ofGLRenderer::setLineSmoothing \t(bool)"                                                                  ,"contents": "${1:ofGLRenderer}.setLineSmoothing(${2:bool smooth})"},
        { "trigger": "ofGLRenderer::setLineWidth \t(float)"                                                                     ,"contents": "${1:ofGLRenderer}.setLineWidth(${2:float lineWidth})"},
        { "trigger": "ofGLRenderer::setRectMode \t(ofRectMode)"                                                                 ,"contents": "${1:ofGLRenderer}.setRectMode(${2:ofRectMode mode})"},
        { "trigger": "ofGLRenderer::setSphereResolution \t(int)"                                                                ,"contents": "${1:ofGLRenderer}.setSphereResolution(${2:int res})"},
        { "trigger": "ofGLRenderer::setupGraphicDefaults"                                                                       ,"contents": "${1:ofGLRenderer}.setupGraphicDefaults()"},
        { "trigger": "ofGLRenderer::setupScreen"                                                                                ,"contents": "${1:ofGLRenderer}.setupScreen()"},
        { "trigger": "ofGLRenderer::setupScreenOrtho \t(float, float, ofOrientation, bool, float, float)"                       ,"contents": "${1:ofGLRenderer}.setupScreenOrtho(${2:float width=0}, ${3:float height=0}, ${4:ofOrientation orientation=OF_ORIENTATION_UNKNOWN}, ${5:bool vFlip=true}, ${6:float nearDist=-1}, ${7:float farDist=1})"},
        { "trigger": "ofGLRenderer::setupScreenPerspective \t(float, float, ofOrientation, bool, float, float, float)"          ,"contents": "${1:ofGLRenderer}.setupScreenPerspective(${2:float width=0}, ${3:float height=0}, ${4:ofOrientation orientation=OF_ORIENTATION_UNKNOWN}, ${5:bool vFlip=true}, ${6:float fov=60}, ${7:float nearDist=0}, ${8:float farDist=0})"},
        { "trigger": "ofGLRenderer::translate \t(float, float, float)"                                                          ,"contents": "${1:ofGLRenderer}.translate(${2:float x}, ${3:float y}, ${4:float z=0})"},
        { "trigger": "ofGLRenderer::translate \t(const ofPoint)"                                                                ,"contents": "${1:ofGLRenderer}.translate(${2:const ofPoint &p})"},
        { "trigger": "ofGLRenderer::update"                                                                                     ,"contents": "${1:ofGLRenderer}.update()"},
        { "trigger": "ofGLRenderer::viewport \t(ofRectangle)"                                                                   ,"contents": "${1:ofGLRenderer}.viewport(${2:ofRectangle viewport})"},
        { "trigger": "ofGLRenderer::viewport \t(float, float, float, float, bool)"                                              ,"contents": "${1:ofGLRenderer}.viewport(${2:float x=0}, ${3:float y=0}, ${4:float width=0}, ${5:float height=0}, ${6:bool invertY=true})"},
        // orientation mode
        { "trigger": "OF_ORIENTATION_UNKNOWN"                                                                                   ,"contents": "OF_ORIENTATION_UNKNOWN"},



        /////////// Application ///////////////

        //////////////////////////////////////
        // ofAppBaseWindow
        { "trigger": "ofAppBaseWindow::disableSetupScreen"                              ,"contents": "${1:ofAppBaseWindow}.disableSetupScreen()"},
        { "trigger": "ofAppBaseWindow::doesHWOrientation"                               ,"contents": "${1:ofAppBaseWindow}.doesHWOrientation()"},
        { "trigger": "ofAppBaseWindow::enableSetupScreen"                               ,"contents": "${1:ofAppBaseWindow}.enableSetupScreen()"},
        { "trigger": "ofAppBaseWindow::getFrameNum"                                     ,"contents": "${1:ofAppBaseWindow}.getFrameNum()"},
        { "trigger": "ofAppBaseWindow::getFrameRate"                                    ,"contents": "${1:ofAppBaseWindow}.getFrameRate()"},
        { "trigger": "ofAppBaseWindow::getHeight"                                       ,"contents": "${1:ofAppBaseWindow}.getHeight()"},
        { "trigger": "ofAppBaseWindow::getLastFrameTime"                                ,"contents": "${1:ofAppBaseWindow}.getLastFrameTime()"},
        { "trigger": "ofAppBaseWindow::getOrientation"                                  ,"contents": "${1:ofAppBaseWindow}.getOrientation()"},
        { "trigger": "ofAppBaseWindow::getScreenSize"                                   ,"contents": "${1:ofAppBaseWindow}.getScreenSize()"},
        { "trigger": "ofAppBaseWindow::getWidth"                                        ,"contents": "${1:ofAppBaseWindow}.getWidth()"},
        { "trigger": "ofAppBaseWindow::getWindowMode"                                   ,"contents": "${1:ofAppBaseWindow}.getWindowMode()"},
        { "trigger": "ofAppBaseWindow::getWindowPosition"                               ,"contents": "${1:ofAppBaseWindow}.getWindowPosition()"},
        { "trigger": "ofAppBaseWindow::getWindowSize"                                   ,"contents": "${1:ofAppBaseWindow}.getWindowSize()"},
        { "trigger": "ofAppBaseWindow::hideCursor"                                      ,"contents": "${1:ofAppBaseWindow}.hideCursor()"},
        { "trigger": "ofAppBaseWindow::initializeWindow"                                ,"contents": "${1:ofAppBaseWindow}.initializeWindow()"},
        // { "trigger": "ofAppBaseWindow::runAppViaInfiniteLoop \t(ofBaseApp)"              ,"contents": "${1:ofAppBaseWindow}.runAppViaInfiniteLoop(${2:ofBaseApp * appPtr})"},
        { "trigger": "ofAppBaseWindow::runAppViaInfiniteLoop \t(ofBaseApp)"             ,"contents": "${1:ofAppBaseWindow}.runAppViaInfiniteLoop(${2:ofBaseApp *appPtr})"},
        { "trigger": "ofAppBaseWindow::setFrameRate \t(float)"                          ,"contents": "${1:ofAppBaseWindow}.setFrameRate(${2:float targetRate})"},
        { "trigger": "ofAppBaseWindow::setFullscreen \t(bool)"                          ,"contents": "${1:ofAppBaseWindow}.setFullscreen(${2:bool fullscreen})"},
        { "trigger": "ofAppBaseWindow::setOrientation \t(ofOrientation)"                ,"contents": "${1:ofAppBaseWindow}.setOrientation(${2:ofOrientation orientation})"},
        { "trigger": "ofAppBaseWindow::setWindowPosition \t(int, int)"                  ,"contents": "${1:ofAppBaseWindow}.setWindowPosition(${2:int x}, ${3:int y})"},
        { "trigger": "ofAppBaseWindow::setWindowShape \t(int, int)"                     ,"contents": "${1:ofAppBaseWindow}.setWindowShape(${2:int w}, ${3:int h})"},
        { "trigger": "ofAppBaseWindow::setWindowTitle \t(string)"                       ,"contents": "${1:ofAppBaseWindow}.setWindowTitle(${2:string title})"},
        { "trigger": "ofAppBaseWindow::setupOpenGL \t(int, int, int)"                   ,"contents": "${1:ofAppBaseWindow}.setupOpenGL(${2:int w}, ${3:int h}, ${4:int screenMode})"},
        { "trigger": "ofAppBaseWindow::showCursor"                                      ,"contents": "${1:ofAppBaseWindow}.showCursor()"},
        { "trigger": "ofAppBaseWindow::toggleFullscreen"                                ,"contents": "${1:ofAppBaseWindow}.toggleFullscreen()"},


        ////////////////////////////////////
        // ofAppRunner

        { "trigger" : "ofDoesHWOrientation"                                             ,"contents": "ofDoesHWOrientation()"},
        { "trigger" : "ofExit(int)"                                                     ,"contents": "ofExit(${1:int status=0})"},
        { "trigger" : "ofGetAppPtr"                                                     ,"contents": "ofGetAppPtr()"},
        { "trigger" : "ofGetFrameNum"                                                   ,"contents": "ofGetFrameNum()"},
        { "trigger" : "ofGetFrameRate"                                                  ,"contents": "ofGetFrameRate()"},
        { "trigger" : "ofGetHeight"                                                     ,"contents": "ofGetHeight()"},
        { "trigger" : "ofGetLastFrameTime"                                              ,"contents": "ofGetLastFrameTime()"},
        { "trigger" : "ofGetOrientation"                                                ,"contents": "ofGetOrientation()"},
        { "trigger" : "ofGetScreenHeight"                                               ,"contents": "ofGetScreenHeight()"},
        { "trigger" : "ofGetScreenWidth"                                                ,"contents": "ofGetScreenWidth()"},
        { "trigger" : "ofGetWidth"                                                      ,"contents": "ofGetWidth()"},
        { "trigger" : "ofGetWindowHeight"                                               ,"contents": "ofGetWindowHeight()"},
        { "trigger" : "ofGetWindowMode"                                                 ,"contents": "ofGetWindowMode()"},
        { "trigger" : "ofGetWindowPositionX"                                            ,"contents": "ofGetWindowPositionX()"},
        { "trigger" : "ofGetWindowPositionY"                                            ,"contents": "ofGetWindowPositionY()"},
        { "trigger" : "ofGetWindowRect"                                                 ,"contents": "ofGetWindowRect()"},
        { "trigger" : "ofGetWindowSize"                                                 ,"contents": "ofGetWindowSize()"},
        { "trigger" : "ofGetWindowWidth"                                                ,"contents": "ofGetWindowWidth()"},
        { "trigger" : "ofHideCursor"                                                    ,"contents": "ofHideCursor()"},
        { "trigger" : "ofRunApp \t(ofBaseApp)"                                          ,"contents": "ofRunApp(${1:ofBaseApp * app})"},
        { "trigger" : "ofRunApp \t(ofPtr< ofBaseApp >)"                                 ,"contents": "ofRunApp(${1:ofPtr< ofBaseApp > OFSA})"},
        { "trigger" : "ofRunApp \t(ofBaseApp)"                                          ,"contents": "ofRunApp(${1:ofBaseApp *OFSA=NULL})"},
        { "trigger" : "ofSetAppPtr \t(ofPtr< ofBaseApp >)"                              ,"contents": "ofSetAppPtr(${1:ofPtr< ofBaseApp > appPtr})"},
        { "trigger" : "ofSetFrameRate \t(int)"                                          ,"contents": "ofSetFrameRate(${1:int targetRate})"},
        { "trigger" : "ofSetFrameRate \t(int)"                                          ,"contents": "ofSetFrameRate(${1:int targetRate})"},
        { "trigger" : "ofSetFullscreen \t(bool fullscreen)"                             ,"contents": "ofSetFullscreen(${1:bool fullscreen})"},
        { "trigger" : "ofSetOrientation \t(ofOrientation)"                              ,"contents": "ofSetOrientation(${1:ofOrientation orientation})"},
        { "trigger" : "ofSetVerticalSync \t(bool)"                                      ,"contents": "ofSetVerticalSync(${1:bool bSync})"},
        { "trigger" : "ofSetWindowPosition \t(int)"                                     ,"contents": "ofSetWindowPosition(${1:int x})"},
        { "trigger" : "ofSetWindowPosition \t(int, int)"                                ,"contents": "ofSetWindowPosition(${1:int x}, ${2:int y})"},
        { "trigger" : "ofSetWindowShape \t(int)"                                        ,"contents": "ofSetWindowShape(${1:int width})"},
        { "trigger" : "ofSetWindowShape \t(int, int)"                                   ,"contents": "ofSetWindowShape(${1:int width}, ${2:int height})"},
        { "trigger" : "ofSetWindowTitle"                                                ,"contents": "ofSetWindowTitle()"},
        { "trigger" : "ofSetWindowTitle \t(string)"                                     ,"contents": "ofSetWindowTitle(${1:string title})"},
        { "trigger" : "ofSetupOpenGL \t(ofAppBaseWindow, int, int, int)"                ,"contents": "ofSetupOpenGL(${1:ofAppBaseWindow * windowPtr}, ${2:int w}, ${3:int h}, ${4:int screenMode})"},
        { "trigger" : "ofSetupOpenGL \t(int w, int h, int screenMode)"                  ,"contents": "ofSetupOpenGL(${1:int w}, ${2:int h}, ${3:int screenMode})"},
        { "trigger" : "ofSetupOpenGL \t(ofAppBaseWindow, int, int, int)"                ,"contents": "ofSetupOpenGL(${1:ofAppBaseWindow *windowPtr}, ${2:int w}, ${3:int h}, ${4:int screenMode})"},
        { "trigger" : "ofShowCursor"                                                    ,"contents": "ofShowCursor()"},
        { "trigger" : "ofSleepMillis \t(int)"                                           ,"contents": "ofSleepMillis(${1:int millis})"},
        { "trigger" : "ofToggleFullscreen"                                              ,"contents": "ofToggleFullscreen()"},

        ////////////////////////////
        // screenMode
        { "trigger": "OF_WINDOW \tscreenMode"                ,"contents": "OF_WINDOW"},
        { "trigger": "OF_FULLSCREEN \tscreenMode"            ,"contents": "OF_FULLSCREEN"},
        { "trigger": "OF_GAME_MODE \tscreenMode"             ,"contents": "OF_GAME_MODE"},




        ////////////////////////////////////
        // ofBaseApp
        //
        // TODO docs site down, when I was doing the rest of apps [martin]

        ////////////////////////////////////
        // ofDragInfo
        //
        // TODO docs site down [martin]




        ///////////// Events //////////////

        //////////////////////////////////
        // ofAudioEventArgs
        { "trigger": "ofAudioEventArgs::buffer"                         ,"contents": "${1:ofAudioEventArgs}.buffer()"},
        { "trigger": "ofAudioEventArgs::bufferSize"                     ,"contents": "${1:ofAudioEventArgs}.bufferSize()"},


        //////////////////////////////////
        // ofCoreEvents
        //
        // I don't thin they should be in auto-complete, it's oF internals [martin]

        //////////////////////////////////
        // ofEvent
        { "trigger": "ofEvent"                                                      ,"contents": "ofEvent<${2:float}> ${1:onVolumeChange}"},
        { "trigger": "ofNotifyEvent"                                                ,"contents": "ofNotifyEvent(${1:onVolumeChange}, ${2:10.0})"},
        { "trigger": "ofAddListener \t(ofEvent,this, &testApp:onVolumeChange)"      ,"contents": "ofAddListener(${1:mySoundObject.onVolumeChange},${2:this}, ${3:&testApp:onVolumeChange})"},

        //////////////////////////////////
        // ofEvents functions
        { "trigger": "ofGetKeyPressed \t(int)"                              ,"contents": "ofGetKeyPressed(${1:int key=-1})"},
        { "trigger": "ofGetMousePressed \t(int)"                            ,"contents": "ofGetMousePressed(${1:int button=-1})"},
        { "trigger": "ofGetMouseX"                                          ,"contents": "ofGetMouseX()"},
        { "trigger": "ofGetMouseY"                                          ,"contents": "ofGetMouseY()"},
        { "trigger": "ofGetPreviousMouseX"                                  ,"contents": "ofGetPreviousMouseX()"},
        { "trigger": "ofGetPreviousMouseY"                                  ,"contents": "ofGetPreviousMouseY()"},
        { "trigger": "ofSetEscapeQuitsApp \t(bool)"                         ,"contents": "ofSetEscapeQuitsApp(${1:bool bQuitOnEsc})"},



        //////////////// ofxXmlSettings /////////////
        // ofXmlSettings is a exceptions, it's so widly usedin ofApps. [martin]
        ////////////////////////////////////////////
        // ofxXmlSettings methods
        { "trigger": "ofxXmlSettings::addAttribute \t(const string, const string, int, int)"                ,"contents": "${1:ofxXmlSettings}.addAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:int value}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::addAttribute \t(const string, const string, double, int)"             ,"contents": "${1:ofxXmlSettings}.addAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:double value}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::addAttribute \t(const string, const string, const string, int)"       ,"contents": "${1:ofxXmlSettings}.addAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:const string &value}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::addAttribute \t(const string, const string, int)"                     ,"contents": "${1:ofxXmlSettings}.addAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:int value})"},
        { "trigger": "ofxXmlSettings::addAttribute \t(const string, const string, double)"                  ,"contents": "${1:ofxXmlSettings}.addAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:double value})"},
        { "trigger": "ofxXmlSettings::addAttribute \t(const string, const string, const string)"            ,"contents": "${1:ofxXmlSettings}.addAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:const string &value})"},
        { "trigger": "ofxXmlSettings::addTag \t(const string)"                                              ,"contents": "${1:ofxXmlSettings}.addTag(${2:const string &tag})"},
        { "trigger": "ofxXmlSettings::addValue \t(const string, int)"                                       ,"contents": "${1:ofxXmlSettings}.addValue(${2:const string &tag}, ${3:int value})"},
        { "trigger": "ofxXmlSettings::addValue \t(const string, double)"                                    ,"contents": "${1:ofxXmlSettings}.addValue(${2:const string &tag}, ${3:double value})"},
        { "trigger": "ofxXmlSettings::addValue \t(const string, const string)"                              ,"contents": "${1:ofxXmlSettings}.addValue(${2:const string &tag}, ${3:const string &value})"},
        { "trigger": "ofxXmlSettings::attributeExists \t(const string, const string, int)"                  ,"contents": "${1:ofxXmlSettings}.attributeExists(${2:const string &tag}, ${3:const string &attribute}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::clear"                                                                ,"contents": "${1:ofxXmlSettings}.clear()"},
        { "trigger": "ofxXmlSettings::clearTagAttributes \t(const string, int)"                             ,"contents": "${1:ofxXmlSettings}.clearTagAttributes(${2:const string &tag}, ${3:int which=0})"},
        { "trigger": "ofxXmlSettings::clearTagContents \t(const string, int)"                               ,"contents": "${1:ofxXmlSettings}.clearTagContents(${2:const string &tag}, ${3:int which=0})"},
        { "trigger": "ofxXmlSettings::copyXmlToString \t(string)"                                           ,"contents": "${1:ofxXmlSettings}.copyXmlToString(${2:string &str})"},
        { "trigger": "ofxXmlSettings::getAttribute \t(const string, const string, int, int)"                ,"contents": "${1:ofxXmlSettings}.getAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:int defaultValue}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::getAttribute \t(const string, const string, double, int)"             ,"contents": "${1:ofxXmlSettings}.getAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:double defaultValue}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::getAttribute \t(const string, const string, const string, int)"       ,"contents": "${1:ofxXmlSettings}.getAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:const string &defaultValue}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::getAttributeNames \t(const string, vector< string >, int)"            ,"contents": "${1:ofxXmlSettings}.getAttributeNames(${2:const string &tag}, ${3:vector< string > &outNames}, ${:4int which=0})"},
        { "trigger": "ofxXmlSettings::getNumAttributes \t(const string, int)"                               ,"contents": "${1:ofxXmlSettings}.getNumAttributes(${2:const string &tag}, ${3:int which=0})"},
        { "trigger": "ofxXmlSettings::getNumTags \t(const string)"                                          ,"contents": "${1:ofxXmlSettings}.getNumTags(${2:const string &tag})"},
        { "trigger": "ofxXmlSettings::getPushLevel"                                                         ,"contents": "${1:ofxXmlSettings}.getPushLevel()"},
        { "trigger": "ofxXmlSettings::getValue \t(const string, int , int)"                                 ,"contents": "${1:ofxXmlSettings}.getValue(${2:const string &tag}, ${3:int defaultValue}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::getValue \t(const string, double, int)"                               ,"contents": "${1:ofxXmlSettings}.getValue(${2:const string &tag}, ${3:double defaultValue}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::getValue \t(const string, const string, int)"                         ,"contents": "${1:ofxXmlSettings}.getValue(${2:const string &tag}, ${3:const string &defaultValue}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::loadFile \t(const string)"                                            ,"contents": "${1:ofxXmlSettings}.loadFile(${2:const string &xmlFile})"},
        { "trigger": "ofxXmlSettings::loadFromBuffer \t(string)"                                            ,"contents": "${1:ofxXmlSettings}.loadFromBuffer({$2:string buffer})"},
        { "trigger": "ofxXmlSettings::popTag"                                                               ,"contents": "${1:ofxXmlSettings}.popTag()"},
        { "trigger": "ofxXmlSettings::pushTag \t(const string, int)"                                        ,"contents": "${1:ofxXmlSettings}.pushTag(${2:const string &tag}, ${3:int which=0})"},
        { "trigger": "ofxXmlSettings::removeAttribute \t(const string, const string, int)"                  ,"contents": "${1:ofxXmlSettings}.removeAttribute(${2:const string &tag}, ${3:const string &attribute}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::removeTag \t(const string, int)"                                      ,"contents": "${1:ofxXmlSettings}.removeTag(${2:const string &tag}, ${3:int which=0})"},
        { "trigger": "ofxXmlSettings::saveFile \t(const string)"                                            ,"contents": "${1:ofxXmlSettings}.saveFile(${2:const string &xmlFile})"},
        { "trigger": "ofxXmlSettings::saveFile"                                                             ,"contents": "${1:ofxXmlSettings}.saveFile()"},
        { "trigger": "ofxXmlSettings::setAttribute \t(const string, const string, int, int)"                ,"contents": "${1:ofxXmlSettings}.setAttribute($2{:const string &tag}, ${3:const string &attribute}, ${4:int value}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::setAttribute \t(const string, const string, double, int)"             ,"contents": "${1:ofxXmlSettings}.setAttribute($2{:const string &tag}, ${3:const string &attribute}, ${4:double value}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::setAttribute \t(const string, const string, const string, int)"       ,"contents": "${1:ofxXmlSettings}.setAttribute($2{:const string &tag}, ${3:const string &attribute}, ${4:const string &value}, ${5:int which=0})"},
        { "trigger": "ofxXmlSettings::setAttribute \t(const string, const string, int)"                     ,"contents": "${1:ofxXmlSettings}.setAttribute($2{:const string &tag}, ${3:const string &attribute}, ${4:int value})"},
        { "trigger": "ofxXmlSettings::setAttribute \t(const string, const string, double)"                  ,"contents": "${1:ofxXmlSettings}.setAttribute($2{:const string &tag}, ${3:const string &attribute}, ${4:double value})"},
        { "trigger": "ofxXmlSettings::setAttribute \t(const string, const string, const string)"            ,"contents": "${1:ofxXmlSettings}.setAttribute($2{:const string &tag}, ${3:const string &attribute}, ${4:const string &value})"},
        { "trigger": "ofxXmlSettings::setValue \t(const string, int, int)"                                  ,"contents": "${1:ofxXmlSettings}.setValue(${2:const string &tag}, ${3:int value}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::setValue \t(const string, double, int)"                               ,"contents": "${1:ofxXmlSettings}.setValue(${2:const string &tag}, ${3:double value}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::setValue \t(const string, const string, int)"                         ,"contents": "${1:ofxXmlSettings}.setValue(${2:const string &tag}, ${3:const string &value}, ${4:int which=0})"},
        { "trigger": "ofxXmlSettings::tagExists \t(const string, int)"                                      ,"contents": "${1:ofxXmlSettings}.tagExists(${2:const string &tag}, ${3:int which=0})"},
        { "trigger": "ofxXmlSettings::bDocLoaded"                                                           ,"contents": "${1:ofxXmlSettings}.bDocLoaded"},
        { "trigger": "ofxXmlSettings::doc"                                                                  ,"contents": "${1:ofxXmlSettings}.doc"},








        //////////////////////////////
        // ofMath
        { "trigger": "ofAngleDifferenceDegrees \t(float, float)"                                      ,"contents": "ofAngleDifferenceDegrees(${1:float currentAngle}, ${2:float targetAngle})"},
        { "trigger": "ofAngleDifferenceRadians \t(float, float)"                                      ,"contents": "ofAngleDifferenceRadians(${1:float currentAngle}, ${2:float targetAngle})"},
        { "trigger": "ofAngleSumRadians \t(float, float)"                                             ,"contents": "ofAngleSumRadians(${1:float currentAngle}, ${2:float targetAngle})"},
        { "trigger": "ofBezierPoint \t(ofPoint, ofPoint, ofPoint, ofPoint, float)"                    ,"contents": "ofBezierPoint(${1:ofPoint a}, ${2:ofPoint b}, ${3:ofPoint c}, ${4:ofPoint d}, ${5:float t})"},
        { "trigger": "ofBezierTangent \t(ofPoint, ofPoint, ofPoint, ofPoint, float)"                  ,"contents": "ofBezierTangent(${1:ofPoint a}, ${2:ofPoint b}, ${3:ofPoint c}, ${4:ofPoint d}, ${5:float t})"},
        { "trigger": "ofClamp \t(float, float, float)"                                                ,"contents": "ofClamp(${1:float value}, ${2:float min}, ${3:float max})"},
        { "trigger": "ofCurvePoint \t(ofPoint, ofPoint, ofPoint, ofPoint, float)"                     ,"contents": "ofCurvePoint(${1:ofPoint a}, ${2:ofPoint b}, ${3:ofPoint c}, ${4:ofPoint d}, ${5:float t})"},
        { "trigger": "ofCurveTangent \t(ofPoint, ofPoint, ofPoint, ofPoint, float)"                   ,"contents": "ofCurveTangent(${1:ofPoint a}, ${2:ofPoint b}, ${3:ofPoint c}, ${4:ofPoint d}, ${5:float t})"},
        { "trigger": "ofDegToRad \t(float)"                                                           ,"contents": "ofDegToRad(${1:float degrees})"},
        { "trigger": "ofDist \t(float, float, float, float)"                                          ,"contents": "ofDist(${1:float x1}, ${2:float y1}, ${3:float x2}, ${4:float y2})"},
        { "trigger": "ofDistSquared \t(float, float, float, float)"                                   ,"contents": "ofDistSquared(${1:float x1}, ${2:float y1}, ${3:float x2}, ${4:float y2})"},
        { "trigger": "ofInRange \t(float, float, float)"                                              ,"contents": "ofInRange(${1:float t}, ${2:float min}, ${3:float max})"},
        { "trigger": "ofInsidePoly \t(float, float, const vector< ofPoint >)"                         ,"contents": "ofInsidePoly(${1:float x}, ${2:float y}, ${3:const vector< ofPoint > &poly})"},
        { "trigger": "ofInsidePoly \t(const ofPoint, const vector< ofPoint >)"                        ,"contents": "ofInsidePoly(${1:const ofPoint &p}, ${2:const vector< ofPoint > &poly})"},
        { "trigger": "ofLerp \t(float, float, float)"                                                 ,"contents": "ofLerp(${1:float start}, ${2:float stop}, ${3:float amt})"},
        { "trigger": "ofLerpDegrees \t(float, float, float)"                                          ,"contents": "ofLerpDegrees(${1:float currentAngle}, ${2:float targetAngle}, ${3:float pct})"},
        { "trigger": "ofLerpRadians \t(float, float, float)"                                          ,"contents": "ofLerpRadians(${1:float currentAngle}, ${2:float targetAngle}, ${3:float pct})"},
        { "trigger": "ofLineSegmentIntersection \t(ofPoint, ofPoint, ofPoint, ofPoint, ofPoint)"      ,"contents": "ofLineSegmentIntersection(${1:ofPoint line1Start}, ${2:ofPoint line1End}, ${3:ofPoint line2Start}, ${4:ofPoint line2End}, ${5:ofPoint &intersection})"},
        { "trigger": "ofMap \t(float, float, float, float, float)"                                    ,"contents": "ofMap(${1:float value}, ${2:float inputMin}, ${3:float inputMax}, ${4:float outputMin}, ${5:float outputMax})"},
        { "trigger": "ofMap \t(float, float, float, float, float, bool)"                              ,"contents": "ofMap(${1:float value}, ${2:float inputMin}, ${3:float inputMax}, ${4:float outputMin}, ${5:float outputMax}, ${6:bool clamp=false})"},
        { "trigger": "ofNextPow2 \t(int)"                                                             ,"contents": "ofNextPow2(${1:int a})"},
        { "trigger": "ofNoise \t(float)"                                                              ,"contents": "ofNoise(${1:float x})"},
        { "trigger": "ofNoise \t(float, float)"                                                       ,"contents": "ofNoise(${1:float x}, ${2:float y})"},
        { "trigger": "ofNoise \t(float, float, float)"                                                ,"contents": "ofNoise(${1:float x}, ${2:float y}, ${3:float z})"},
        { "trigger": "ofNoise \t(float, float, float, float)"                                         ,"contents": "ofNoise(${1:float x}, ${2:float y}, ${3:float z}, ${4:float w})"},
        { "trigger": "ofNormalize \t(float, float, float)"                                            ,"contents": "ofNormalize(${1:float value}, ${2:float min}, ${3:float max})"},
        { "trigger": "ofRadToDeg \t(float)"                                                           ,"contents": "ofRadToDeg(${1:float radians})"},
        { "trigger": "ofRandom \t(float, float)"                                                      ,"contents": "ofRandom(${1:float val0}, ${2:float val1})"},
        { "trigger": "ofRandom \t(float)"                                                             ,"contents": "ofRandom(${1:float max})"},
        { "trigger": "ofRandomHeight"                                                                 ,"contents": "ofRandomHeight()"},
        { "trigger": "ofRandomWidth"                                                                  ,"contents": "ofRandomWidth()"},
        { "trigger": "ofRandomf"                                                                      ,"contents": "ofRandomf()"},
        { "trigger": "ofRandomuf"                                                                     ,"contents": "ofRandomuf()"},
        { "trigger": "ofSeedRandom"                                                                   ,"contents": "ofSeedRandom()"},
        { "trigger": "ofSeedRandom \t(int)"                                                           ,"contents": "ofSeedRandom(${1:int val})"},
        { "trigger": "ofSign \t(float)"                                                               ,"contents": "ofSign(${1:float n})"},
        { "trigger": "ofSignedNoise \t(float)"                                                        ,"contents": "ofSignedNoise(${1:float x})"},
        { "trigger": "ofSignedNoise \t(float, float)"                                                 ,"contents": "ofSignedNoise(${1:float x}, ${2:float y})"},
        { "trigger": "ofSignedNoise \t(float, float, float)"                                          ,"contents": "ofSignedNoise(${1:float x}, ${2:float y}, ${3:float z})"},
        { "trigger": "ofSignedNoise \t(float, float, float, float)"                                   ,"contents": "ofSignedNoise(${1:float x}, ${2:float y}, ${3:float z}, ${4:float w})"},
        { "trigger": "ofWrapDegrees \t(float, float, float)"                                          ,"contents": "ofWrapDegrees(${1:float angle}, ${2:float from=-180}, ${3:float to=+180})"},
        { "trigger": "ofWrapRadians \t(float, float, float)"                                          ,"contents": "ofWrapRadians(${1:float angle}, ${2:float from=-PI}, ${3:float to=+PI})"},



        //////////////////// utils ///////////////////
        
        /////////////////////////////////////
        // ofBuffer

        /////////////////////////////////////
        // ofDirectory

        /////////////////////////////////////
        // ofFile

        /////////////////////////////////////
        // ofFileDialogResult

        /////////////////////////////////////
        // ofFilePath

        /////////////////////////////////////
        // ofFileUtils

        /////////////////////////////////////
        // ofHttpRequest

        /////////////////////////////////////
        // ofHttpResponse

        /////////////////////////////////////
        // ofLog

        /////////////////////////////////////
        // ofSystemUtils

        /////////////////////////////////////
        // ofThread

        /////////////////////////////////////
        // ofURLFileLoader

        /////////////////////////////////////
        // ofUtils
        { "trigger": "ofBinaryToChar \t(const string)"                                    ,"contents": "ofBinaryToChar(${1:const string &value})"},
        { "trigger": "ofBinaryToFloat \t(const string)"                                   ,"contents": "ofBinaryToFloat(${1:const string &value})"},
        { "trigger": "ofBinaryToInt \t(const string)"                                     ,"contents": "ofBinaryToInt(${1:const string &value})"},
        { "trigger": "ofBinaryToString \t(const string)"                                  ,"contents": "ofBinaryToString(${1:const string &value})"},
        { "trigger": "ofContains \t(const vector< T >, const T)"                          ,"contents": "ofContains(${1:const vector< T > &values}, ${2:const T &target})"},
        { "trigger": "ofFind \t(const vector< T >, const T)"                              ,"contents": "ofFind(${1:const vector< T > &values}, ${2:const T &target})"},
        { "trigger": "ofGetDay"                                                           ,"contents": "ofGetDay()"},
        { "trigger": "ofGetElapsedTimeMicros"                                             ,"contents": "ofGetElapsedTimeMicros()"},
        { "trigger": "ofGetElapsedTimeMillis"                                             ,"contents": "ofGetElapsedTimeMillis()"},
        { "trigger": "ofGetElapsedTimef"                                                  ,"contents": "ofGetElapsedTimef()"},
        { "trigger": "ofGetFrameNum"                                                      ,"contents": "ofGetFrameNum()"},
        { "trigger": "ofGetHours"                                                         ,"contents": "ofGetHours()"},
        { "trigger": "ofGetMinutes"                                                       ,"contents": "ofGetMinutes()"},
        { "trigger": "ofGetMonth"                                                         ,"contents": "ofGetMonth()"},
        { "trigger": "ofGetSeconds"                                                       ,"contents": "ofGetSeconds()"},
        { "trigger": "ofGetSystemTimeMicros"                                              ,"contents": "ofGetSystemTimeMicros()"},
        { "trigger": "ofGetTargetPlatform"                                                ,"contents": "ofGetTargetPlatform()"},
        { "trigger": "ofGetTimestampString"                                               ,"contents": "ofGetTimestampString()"},
        { "trigger": "ofGetTimestampString \t(string)"                                    ,"contents": "ofGetTimestampString(${1:string timestampFormat})"},
        { "trigger": "ofGetUnixTime"                                                      ,"contents": "ofGetUnixTime()"},
        { "trigger": "ofGetVersionInfo"                                                   ,"contents": "ofGetVersionInfo()"},
        { "trigger": "ofGetWeekday"                                                       ,"contents": "ofGetWeekday()"},
        { "trigger": "ofGetYear"                                                          ,"contents": "ofGetYear()"},
        { "trigger": "ofHexToChar \t(const string)"                                       ,"contents": "ofHexToChar(${1:const string &charHexString})"},
        { "trigger": "ofHexToFloat \t(const string)"                                      ,"contents": "ofHexToFloat(${1:const string &floatHexString})"},
        { "trigger": "ofHexToInt \t(const string)"                                        ,"contents": "ofHexToInt(${1:const string &intHexString})"},
        { "trigger": "ofHexToString \t(const string)"                                     ,"contents": "ofHexToString(${1:const string &stringHexString})"},
        { "trigger": "ofIsStringInString \t(string, string)"                              ,"contents": "ofIsStringInString(${1:string haystack}, ${2:string needle})"},
        { "trigger": "ofJoinString \t(vector< string >, const string)"                    ,"contents": "ofJoinString(${1:vector< string > stringElements}, ${2:const string &delimiter})"},
        { "trigger": "ofLaunchBrowser \t(string)"                                         ,"contents": "ofLaunchBrowser(${1:string url})"},
        { "trigger": "ofNextPow2 \t(int)"                                                 ,"contents": "ofNextPow2(${1:int input})"},
        { "trigger": "ofRandomize \t(vector< T >)"                                        ,"contents": "ofRandomize(${1:vector< T > &values})"},
        { "trigger": "ofRemove \t(vector< T >, BoolFunction)"                             ,"contents": "ofRemove(${1:vector< T > &values}, ${2:BoolFunction shouldErase})"},
        { "trigger": "ofResetElapsedTimeCounter"                                          ,"contents": "ofResetElapsedTimeCounter()"},
        { "trigger": "ofSaveFrame"                                                        ,"contents": "ofSaveFrame()"},
        { "trigger": "ofSaveFrame \t(bool)"                                               ,"contents": "ofSaveFrame(${1:bool bUseViewport=false})"},
        { "trigger": "ofSaveScreen \t(string)"                                            ,"contents": "ofSaveScreen(${1:string filename})"},
        { "trigger": "ofSaveViewport \t(string)"                                          ,"contents": "ofSaveViewport(${1:string filename})"},
        { "trigger": "ofSetDataPathRoot \t(string)"                                       ,"contents": "ofSetDataPathRoot(${1:string root})"},
        { "trigger": "ofSort \t(vector< T >)"                                             ,"contents": "ofSort(${1:vector< T > &values})"},
        { "trigger": "ofSort \t(vector< T >, BoolFunction)"                               ,"contents": "ofSort(${1:vector< T > &values}, ${2:BoolFunction compare})"},
        { "trigger": "ofSplitString \t(const string&, const string&)"                     ,"contents": "ofSplitString(${1:const string& str}, ${2:const string& delimiter = " "})"},
        { "trigger": "ofSplitString \t(const string, const string, bool, bool)"           ,"contents": "ofSplitString(${1:const string &source}, ${2:const string &delimiter}, ${3:bool ignoreEmpty=false}, ${4:bool trim=false})"},
        { "trigger": "ofStringReplace \t(string, string, string)"                         ,"contents": "ofStringReplace(${1:string &input}, ${2:string searchStr}, ${3:string replaceStr})"},
        { "trigger": "ofSystem \t(string)"                                                ,"contents": "ofSystem(${1:string command})"},
        { "trigger": "ofToBinary \t(const T)"                                             ,"contents": "ofToBinary(${1:const T &value})"},
        { "trigger": "ofToBinary \t(const string)"                                        ,"contents": "ofToBinary(${1:const string &value})"},
        { "trigger": "ofToBinary \t(const char)"                                          ,"contents": "ofToBinary(${1:const char *value})"},
        { "trigger": "ofToBool \t(const string)"                                          ,"contents": "ofToBool(${1:const string &boolString})"},
        { "trigger": "ofToChar \t(const string)"                                          ,"contents": "ofToChar(${1:const string &charString})"},
        { "trigger": "ofToDataPath \t(string, bool)"                                      ,"contents": "ofToDataPath(${1:string path}, ${2:bool absolute=false})"},
        { "trigger": "ofToFloat \t(const string&)"                                        ,"contents": "ofToFloat(${1:const string& floatString})"},
        { "trigger": "ofToFloat \t(const string)"                                         ,"contents": "ofToFloat(${1:const string &floatString})"},
        { "trigger": "ofToHex \t(const T)"                                                ,"contents": "ofToHex(${1:const T &value})"},
        { "trigger": "ofToHex \t(const string)"                                           ,"contents": "ofToHex(${1:const string &value})"},
        { "trigger": "ofToHex \t(const char)"                                             ,"contents": "ofToHex(${1:const char *value})"},
        { "trigger": "ofToInt \t(const string&)"                                          ,"contents": "ofToInt(${1:const string& intString})"},
        { "trigger": "ofToInt \t(const string)"                                           ,"contents": "ofToInt(${1:const string &intString})"},
        { "trigger": "ofToLower \t(const string)"                                         ,"contents": "ofToLower(${1:const string &src})"},
        { "trigger": "ofToString \t(int)"                                                 ,"contents": "ofToString({int value})"},
        { "trigger": "ofToString \t(const T)"                                             ,"contents": "ofToString(${1:const T &value})"},
        { "trigger": "ofToString \t(const T, int)"                                        ,"contents": "ofToString(${1:const T &value, int precision})"},
        { "trigger": "ofToString \t(const vector< T >)"                                   ,"contents": "ofToString(${1:const vector< T > &values})"},
        { "trigger": "ofToString \t(const T, int, char)"                                  ,"contents": "ofToString(${1:const T &value}, ${2:int width}, ${3:char fill})"},
        { "trigger": "ofToString \t(const T, int, int, char)"                             ,"contents": "ofToString(${1:const T &value}, ${2:int precision}, ${3:int width}, ${4:char fill})"},
        { "trigger": "ofToUpper \t(const string)"                                         ,"contents": "ofToUpper(${1:const string &src})"},
        { "trigger": "ofVAArgsToString \t(const char, ...)"                               ,"contents": "ofVAArgsToString(${1:const char *format},${2:...})"},
        { "trigger": "ofVAArgsToString \t(const char, va_list)"                           ,"contents": "ofVAArgsToString(${1:const char *format}, ${2:va_list args})"},





        ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        // EMPTY - Kept so that all JSON objects above can keep the trailing ","
        {}
    ]
}