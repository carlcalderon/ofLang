// openFrameworks - completions
//
// syntax:
//
// {
//  "trigger": "namespace::method \t(variation)",
//  "contents": "namespace::method()"
// }
//
// example:
// { "trigger": "ofBackground \t(ofColor)"                                           ,"contents": "ofBackground(${1:const ofColor &c})" },
//
{
    "scope": "source.c++",

    "completions":
    [

        //////////////////////////////
        // types
        { "trigger": "ofColor"                                                      ,"contents": "ofColor ${1:color}"},
        // TODO

        { "trigger": "ofPoint"                                                      ,"contents": "ofPoint ${1:point}"},
        { "trigger": "ofPoint::set \t(float, float, float)"                         ,"contents": "set(${1:float _x}, ${2:float _y}, ${3:float _z})"},
        // TODO, so many operators, should they even be here?

        { "trigger": "ofPtr"                                                        ,"contents": "ofPtr< ${1:instance} > ptr(new ${1:instance}());"},
        // DONE

        { "trigger": "ofRectangle"                                                  ,"contents": "ofRectangle ${1:rectangle}"},
        { "trigger": "ofRectangle::set \t(float px, float py, float w, float h)"    ,"contents": "set(float px, float py, float w, float h)"},
        { "trigger": "ofRectangle::set \t(const ofPoint &p, float w, float h)"      ,"contents": "set(const ofPoint &p, float w, float h)"},
        { "trigger": "ofRectangle::set \t(const ofRectangle &rect)"                 ,"contents": "set(const ofRectangle &rect)"},
        { "trigger": "ofRectangle::set \t(const ofPoint &p0, const ofPoint &p1)"    ,"contents": "set(const ofPoint &p0, const ofPoint &p1)"},

        // hows this for access of types variables? [martin]
        { "trigger": "ofRectangle \theight"                                          ,"contents": "height"},
        { "trigger": "ofRectangle \tposition"                                        ,"contents": "position"},
        { "trigger": "ofRectangle \twidth"                                           ,"contents": "width"},
        { "trigger": "ofRectangle \tx"                                               ,"contents": "x"},
        { "trigger": "ofRectangle \ty"                                               ,"contents": "y"},
        // TODO

        { "trigger": "ofStyle"                                                      ,"contents": "ofStyle"},
        // TODO


        ////////////////////////////////////
        // ofGraphics

        // ofBackground
        { "trigger": "ofBackground \t(rgb)"                                          ,"contents": "ofBackground(${1:int r}, ${2:int g}, ${3:int b})"},
        { "trigger": "ofBackground \t(rgba)"                                         ,"contents": "ofBackground(${1:int r}, ${2:int g}, ${3:int b}, ${4:int a})" },
        { "trigger": "ofBackground \t(brightness, alpha)"                            ,"contents": "ofBackground(${1:int brightness}, ${2:int alpha=255})" },
        { "trigger": "ofBackground \t(ofColor)"                                      ,"contents": "ofBackground(${1:const ofColor &c})" },

        // ofBackgroundGradient
        { "trigger": "ofBackgroundGradient"                                          ,"contents": "ofBackgroundGradient(${1:const ofColor &start}, ${2:const ofColor &end}, ${2:ofGradientMode mode=OF_GRADIENT_CIRCULAR})" },

        // ofBackgroundHex
        { "trigger": "ofBackgroundHex"                                               ,"contents": "ofBackgroundHex(${1:int hexColor}, ${2:int alpha=255})" },

        // ofBeginSaveScreenAsPDF
        { "trigger": "ofBeginSaveScreenAsPDF"                                        ,"contents": "ofBeginSaveScreenAsPDF(${1:string filename}, ${2:bool bMultipage=false}, ${3:bool b3D=false}, ${4:ofRectangle viewport=ofRectangle(0, 0, 0, 0)})" },

        // ofBeginShape
        { "trigger": "ofBeginShape"                                                  ,"contents": "ofBeginShape()" },

        // ofBezier
        { "trigger": "ofBezier \t(xy)"                                               ,"contents": "ofBezier(${1:float x0}, ${2:float y0}, ${3:float x1}, ${4:float y1}, ${5:float x2}, ${6:float y2}, ${7:float x3}, ${8:float y3})" },
        { "trigger": "ofBezier \t(xyz)"                                              ,"contents": "ofBezier(${1:float x0}, ${2:float y0}, ${3:float z0}, ${4:float x1}, ${5:float y1}, ${6:float z1}, ${7:float x2}, ${8:float y2}, ${9:float z2}, ${10:float x3}, ${11:float y3}, ${12:float z3})" },

        // ofBezierVertex
        { "trigger": "ofBezierVertex \t(xy)"                                         ,"contents": "ofBezierVertex(${1:float x1}, ${2:float y1}, ${3:float x2}, ${4:float y2}, ${5:float x3}, ${6:float y3})" },
        { "trigger": "ofBezierVertex \t(xyz)"                                        ,"contents": "ofBezierVertex(${1:float x1}, ${2:float y1}, ${3:float z1}, ${4:float x2}, ${5:float y2}, ${6:float z2}, ${7:float x3}, ${8:float y3}, ${9:float z3})" },
        { "trigger": "ofBezierVertex \t(ofPoint)"                                    ,"contents": "ofBezierVertex(${1:const ofPoint &p1}, ${2:const ofPoint &p2}, ${3:const ofPoint &p3})" },

        // ofBgColorPtr
        { "trigger": "ofBgColorPtr"                                                  ,"contents": "ofBgColorPtr()" },

        // ofBox
        { "trigger": "ofBox"                                                         ,"contents": "ofBox(${1:float size})" },
        { "trigger": "ofBox \t(xy)"                                                  ,"contents": "ofBox(${1:float x}, ${2:float y}, ${3:float size})" },
        { "trigger": "ofBox \t(xyz)"                                                 ,"contents": "ofBox(${1:float x}, ${2:float y}, ${3:float z}, ${4:float size})" },
        { "trigger": "ofBox \t(ofPoint)"                                             ,"contents": "ofBox(${1:const ofPoint &position}, ${2:float size})" },

        // ofCircle
        { "trigger": "ofCircle \t(xy)"                                               ,"contents": "ofCircle(${1:float x}, ${2:float y}, ${3:float radius})" },
        { "trigger": "ofCircle \t(xyz)"                                              ,"contents": "ofCircle(${1:float x}, ${2:float y}, ${3:float z}, ${4:float radius})" },
        { "trigger": "ofCircle \t(ofPoint)"                                          ,"contents": "ofCircle(${1:const ofPoint &p}, ${2:float radius})" },

        // ofClear
        { "trigger": "ofClear \t(rgba)"                                              ,"contents": "ofClear(${1:float r}, ${2:float g}, ${3:float b}, ${4:float a=0})" },
        { "trigger": "ofClear \t(brightness, alpha)"                                 ,"contents": "ofClear(${1:float brightness}, ${2:float a=0})" },
        { "trigger": "ofClear \t(ofColor)"                                           ,"contents": "ofClear(${1:const ofColor &c})" },

        // ofClearAlpha
        { "trigger": "ofClearAlpha"                                                  ,"contents": "ofClearAlpha()" },

        // ofCone
        { "trigger": "ofCone \t(size)"                                               ,"contents": "ofCone(${1:float size})" },
        { "trigger": "ofCone \t(radius size)"                                        ,"contents": "ofCone(${1:float radius}, ${2:float height})" },
        { "trigger": "ofCone \t(xy)"                                                 ,"contents": "ofCone(${1:float x}, ${2:float y}, ${3:float radius}, ${4:float height})" },
        { "trigger": "ofCone \t(xyz)"                                                ,"contents": "ofCone(${1:float x}, ${2:float y}, ${3:float z}, ${4:float radius}, ${5:float height})" },
        { "trigger": "ofCone \t(ofPoint)"                                            ,"contents": "ofCone(${1:const ofPoint &position}, ${2:float radius}, ${3:float height})" },

        // ofCurve
        { "trigger": "ofCurve \t(xy)"                                                ,"contents": "ofCurve(${1:float x0}, ${2:float y0}, ${3:float x1}, ${4:float y1}, ${5:float x2}, ${6:float y2}, ${7:float x3}, ${8:float y3})" },
        { "trigger": "ofCurve \t(xyz)"                                               ,"contents": "ofCurve(${1:float x0}, ${2:float y0}, ${3:float z0}, ${4:float x1}, ${5:float y1}, ${6:float z1}, ${7:float x2}, ${8:float y2}, ${9:float z2}, ${10:float x3}, ${11:float y3}, ${12:float z3})" },

        // ofCurveVertex
        { "trigger": "ofCurveVertex \t(xy)"                                          ,"contents": "ofCurveVertex(${1:float x}, ${2:float y})" },
        { "trigger": "ofCurveVertex \t(ofPoint)"                                     ,"contents": "ofCurveVertex(${1:ofPoint &p})" },

        // ofCurveVertices
        { "trigger": "ofCurveVertices"                                               ,"contents": "ofCurveVertices(${1:const vector< ofPoint > &curvePoints})" },

        // ofDisableAlphaBlending
        { "trigger": "ofDisableAlphaBlending"                                        ,"contents": "ofDisableAlphaBlending()" },

        // ofDisableBlendMode
        { "trigger": "ofDisableBlendMode"                                            ,"contents": "ofDisableBlendMode()" },

        // ofDisablePointSprites
        { "trigger": "ofDisablePointSprites"                                         ,"contents": "ofDisablePointSprites()" },

        // ofDisableSmoothing
        { "trigger": "ofDisableSmoothing"                                            ,"contents": "ofDisableSmoothing()" },

        // ofDrawBitmapString
        { "trigger": "ofDrawBitmapString \t(xy)"                                     ,"contents": "ofDrawBitmapString(${1:string textString}, ${2:float x}, ${3:float y}})" },
        { "trigger": "ofDrawBitmapString \t(xyz)"                                    ,"contents": "ofDrawBitmapString(${1:string textString}, ${2:float x}, ${3:float y}, ${4:float z})" },
        { "trigger": "ofDrawBitmapString \t(ofPoint)"                                ,"contents": "ofDrawBitmapString(${1:string textString}, ${2:const ofPoint &p})" },

        // ofDrawBitmapStringHighlight
        { "trigger": "ofDrawBitmapStringHighlight \t(xy)"                            ,"contents": "ofDrawBitmapStringHighlight(${1:string text}, ${2:int x}, ${3:int x}, ${4:const ofColor &background=ofColor::black}, ${5:const ofColor &foreground=ofColor::white})" },
        { "trigger": "ofDrawBitmapStringHighlight \t(ofPoint)"                       ,"contents": "ofDrawBitmapStringHighlight(${1:string text}, ${2:const ofPoint &position}, ${3:const ofColor &background=ofColor::black}, ${4:const ofColor &foreground=ofColor::white})" },

        // ofEllipse
        { "trigger": "ofEllipse \t(xy)"                                              ,"contents": "ofEllipse(${1:float x}, ${2:float y}, ${3:float width}, ${4:float height})" },
        { "trigger": "ofEllipse \t(xyz)"                                             ,"contents": "ofEllipse(${1:float x}, ${2:float y}, ${3:float z}, ${4:float width}, ${5:float height})" },
        { "trigger": "ofEllipse \t(ofPoint)"                                         ,"contents": "ofEllipse(${1:const ofPoint &p}, ${2:float width}, ${3:float height})" },

        // ofEnableAlphaBlending
        { "trigger": "ofEnableAlphaBlending"                                         ,"contents": "ofEnableAlphaBlending()" },

        // ofEnableBlendMode
        { "trigger": "ofEnableBlendMode"                                             ,"contents": "ofEnableBlendMode(${1:ofBlendMode blendMode})" },

        // ofEnablePointSprites
        { "trigger": "ofEnablePointSprites"                                          ,"contents": "ofEnablePointSprites()" },

        // ofEnableSmoothing
        { "trigger": "ofEnableSmoothing"                                             ,"contents": "ofEnableSmoothing()" },

        // ofEndSaveScreenAsPDF
        { "trigger": "ofEndSaveScreenAsPDF"                                          ,"contents": "ofEndSaveScreenAsPDF()" },

        // ofEndShape
        { "trigger": "ofEndShape"                                                    ,"contents": "ofEndShape(${1:bool bClose=false)}" },

        // ofFill
        { "trigger": "ofFill"                                                        ,"contents": "ofFill()" },

        // ofGetCoordHandedness
        { "trigger": "ofGetCoordHandedness"                                          ,"contents": "ofGetCoordHandedness()" },

        // ofGetCurrentRenderer
        { "trigger": "ofGetCurrentRenderer"                                          ,"contents": "ofGetCurrentRenderer()" },

        // ofGetCurrentViewport
        { "trigger": "ofGetCurrentViewport"                                          ,"contents": "ofGetCurrentViewport()" },

        // ofGetFill
        { "trigger": "ofGetFill"                                                     ,"contents": "ofGetFill()" },

        // ofGetGLRenderer
        { "trigger": "ofGetGLRenderer"                                               ,"contents": "ofGetGLRenderer()" },

        // ofGetRectMode
        { "trigger": "ofGetRectMode"                                                 ,"contents": "ofGetRectMode()" },

        // ofGetStyle
        { "trigger": "ofGetStyle"                                                    ,"contents": "ofGetStyle()" },

        // ofGetViewportHeight
        { "trigger": "ofGetViewportHeight"                                           ,"contents": "ofGetViewportHeight()" },

        // ofGetViewportWidth
        { "trigger": "ofGetViewportWidth"                                            ,"contents": "ofGetViewportWidth()" },

        // ofLine
        { "trigger": "ofLine \t(xy)"                                                 ,"contents": "ofLine(${1:float x1}, ${2:float y1}, ${3:float x2}, ${4:float y2})" },
        { "trigger": "ofLine \t(xyz)"                                                ,"contents": "ofLine(${1:float x1}, ${2:float y1}, ${3:float z1}, ${4:float x2}, ${5:float y2}, ${6:float z2})" },
        { "trigger": "ofLine \t(ofPoint)"                                            ,"contents": "ofLine(${1:const ofPoint &p1}, ${2:const ofPoint &p2})" },

        // ofLoadIdentityMatrix
        { "trigger": "ofLoadIdentityMatrix"                                          ,"contents": "ofLoadIdentityMatrix()" },

        // ofLoadMatrix
        { "trigger": "ofLoadMatrix \t(ofMatrix4x4)"                                  ,"contents": "ofLoadMatrix(${1:const ofMatrix4x4 &m})" },
        { "trigger": "ofLoadMatrix \t(float)"                                        ,"contents": "ofLoadMatrix(${1:const float *m})" },

        // ofMultMatrix
        { "trigger": "ofMultMatrix \t(ofMatrix4x4)"                                  ,"contents": "ofMultMatrix(${1:const ofMatrix4x4 &m})" },
        { "trigger": "ofMultMatrix \t(float)"                                        ,"contents": "ofMultMatrix(${1:const float *m})" },

        // ofNextContour
        { "trigger": "ofNextContour"                                                 ,"contents": "ofNextContour(${1:bool bClose=false})" },

        // ofNoFill
        { "trigger": "ofNoFill"                                                      ,"contents": "ofNoFill()" },

        // ofOrientationToDegrees
        { "trigger": "ofOrientationToDegrees"                                        ,"contents": "ofOrientationToDegrees(${1:ofOrientation orientation})" },

        // ofPopMatrix
        { "trigger": "ofPopMatrix"                                                   ,"contents": "ofPopMatrix()" },

        // ofPopStyle
        { "trigger": "ofPopStyle"                                                    ,"contents": "ofPopStyle()" },

        // ofPopView
        { "trigger": "ofPopView"                                                     ,"contents": "ofPopView()" },

        // ofPushMatrix
        { "trigger": "ofPushMatrix"                                                  ,"contents": "ofPushMatrix()" },

        // ofPushStyle
        { "trigger": "ofPushStyle"                                                   ,"contents": "ofPushStyle()" },

        // ofPushView
        { "trigger": "ofPushView"                                                    ,"contents": "ofPushView()" },

        // ofRect
        { "trigger": "ofRect \t(xywh)"                                               ,"contents": "ofRect(${1:float x}, ${2:float y}, ${3:float w}, ${4:float h})" },
        { "trigger": "ofRect \t(xyzwh)"                                              ,"contents": "ofRect(${1:float x}, ${2:float y}, ${3:float z}, ${4:float w}, ${5:float h})" },
        { "trigger": "ofRect \t(ofPoint)"                                            ,"contents": "ofRect(${1:const ofPoint &p}, ${2:float w}, ${3:float h})" },
        { "trigger": "ofRect \t(ofRectangle)"                                        ,"contents": "ofRect(${1:const ofRectangle &r})" },

        // ofRectRounded
        { "trigger": "ofRectRounded \t(xy)"                                          ,"contents": "ofRectRounded(${1:float x}, ${2:float y}, ${3:float w}, ${4:float h}, ${5:float r})" },
        { "trigger": "ofRectRounded \t(xyz)"                                         ,"contents": "ofRectRounded(${1:float x}, ${2:float y}, ${3:float z}, ${4:float w}, ${5:float h}, ${6:float r})" },
        { "trigger": "ofRectRounded \t(ofPoint)"                                     ,"contents": "ofRectRounded(${1:const ofPoint &p}, ${2:float w}, ${3:float h}, ${4:float r})" },
        { "trigger": "ofRectRounded \t(ofRectangle)"                                 ,"contents": "ofRectRounded(${1:const ofRectangle &b}, ${2:float r})" },

        // ofRotate
        { "trigger": "ofRotate"                                                      ,"contents": "ofRotate(${1:float degrees})" },
        { "trigger": "ofRotate \t(xyz)"                                              ,"contents": "ofRotate(${1:float degrees}, ${2:float vecX}, ${3:float vecY}, ${4:float vecZ})" },

        // ofRotateX
        { "trigger": "ofRotateX"                                                     ,"contents": "ofRotateX(${1:float degrees})" },

        // ofRotateY
        { "trigger": "ofRotateY"                                                     ,"contents": "ofRotateY(${1:float degrees})" },

        // ofRotateZ
        { "trigger": "ofRotateZ"                                                     ,"contents": "ofRotateZ(${1:float degrees})" },

        // ofScale
        { "trigger": "ofScale"                                                       ,"contents": "ofScale(${1:float xAmnt}, ${2:float yAmnt}, ${3:float zAmnt=1})" },

        // ofSetBackgroundAuto
        { "trigger": "ofSetBackgroundAuto"                                           ,"contents": "ofSetBackgroundAuto(${1:bool bManual})" },

        // ofSetBackgroundColor
        { "trigger": "ofSetBackgroundColor \t(rgba)"                                 ,"contents": "ofSetBackgroundColor(${1:int r}, ${2:int g}, ${3:int b)}, ${4:int a=255})" },
        { "trigger": "ofSetBackgroundColor \t(brightness, alpha)"                    ,"contents": "ofSetBackgroundColor(${1:int brightness}, ${2:int alpha=255})" },
        { "trigger": "ofSetBackgroundColor \t(ofColor)"                              ,"contents": "ofSetBackgroundColor(${1:const ofColor &c})" },

        // ofSetBackgroundColorHex
        { "trigger": "ofSetBackgroundColorHex"                                       ,"contents": "ofSetBackgroundColorHex(${1:int hexColor}, ${2:int alpha=255})" },

        // ofSetCircleResolution
        { "trigger": "ofSetCircleResolution"                                         ,"contents": "ofSetCircleResolution(${1:int res})" },

        // ofSetColor
        { "trigger": "ofSetColor \t(rgb)"                                            ,"contents": "ofSetColor(${1:int r}, ${2:int g}, ${3:int b})" },
        { "trigger": "ofSetColor \t(rgba)"                                           ,"contents": "ofSetColor(${1:int r}, ${2:int g}, ${3:int b}, ${4:int a})" },
        { "trigger": "ofSetColor \t(gray)"                                           ,"contents": "ofSetColor(${1:int gray})" },
        { "trigger": "ofSetColor \t(ofColor)"                                        ,"contents": "ofSetColor(${1:const ofColor &color})" },
        { "trigger": "ofSetColor \t(ofColor, alpha)"                                 ,"contents": "ofSetColor(${1:const ofColor &color}, ${2:int _a})" },

        // ofSetCoordHandedness
        { "trigger": "ofSetCoordHandedness"                                          ,"contents": "ofSetCoordHandedness(${1:ofHandednessType handedness})" },

        // ofSetCurrentRenderer
        { "trigger": "ofSetCurrentRenderer"                                          ,"contents": "ofSetCurrentRenderer(${1:ofPtr< ofBaseRenderer > renderer})" },

        // ofSetCurveResolution
        { "trigger": "ofSetCurveResolution"                                          ,"contents": "ofSetCurveResolution(${1:int res})" },

        // ofSetDrawBitmapMode
        { "trigger": "ofSetDrawBitmapMode"                                           ,"contents": "ofSetDrawBitmapMode(${1:ofDrawBitmapMode mode})" },

        // ofSetHexColor
        { "trigger": "ofSetHexColor"                                                 ,"contents": "ofSetHexColor(${1:int hexColor})" },

        // ofSetLineWidth
        { "trigger": "ofSetLineWidth"                                                ,"contents": "ofSetLineWidth(${1:float lineWidth})" },

        // ofSetPolyMode
        { "trigger": "ofSetPolyMode"                                                 ,"contents": "ofSetPolyMode(${1:int mode})" },
        { "trigger": "ofSetPolyMode \t(ofPolyWindingMode)"                           ,"contents": "ofSetPolyMode(${1:ofPolyWindingMode mode})" },

        // ofSetRectMode
        { "trigger": "ofSetRectMode"                                                 ,"contents": "ofSetRectMode(${1:int mode})" },
        { "trigger": "ofSetRectMode \t(ofRectMode)"                                  ,"contents": "ofSetRectMode(${1:ofRectMode mode})" },

        // ofSetSphereResolution
        { "trigger": "ofSetSphereResolution"                                         ,"contents": "ofSetSphereResolution(${1:int res})" },

        // ofSetStyle
        { "trigger": "ofSetStyle"                                                    ,"contents": "ofSetStyle(${1:ofStyle style})" },

        // ofSetupScreen
        { "trigger": "ofSetupScreen"                                                 ,"contents": "ofSetupScreen()" },

        // ofSetupScreenOrtho
        { "trigger": "ofSetupScreenOrtho"                                            ,"contents": "ofSetupScreenOrtho(${1:float width=0}, ${2:float height=0}, ${3:ofOrientation orientation=OF_ORIENTATION_UNKNOWN}, ${4:bool vFlip=true}, ${5:float nearDist=-1}, ${6:float farDist=-1})" },

        // ofSetupScreenPerspective
        { "trigger": "ofSetupScreenPerspective"                                      ,"contents": "ofSetupScreenPerspective(${1:float width=0}, ${2:float height=0}, ${3:ofOrientation orientation=OF_ORIENTATION_UNKNOWN}, ${4:bool vFlip=true}, ${5:float fov=60}, ${6:float nearDist=0}, ${7:float farDist=0})" },

        // ofSphere
        { "trigger": "ofSphere"                                                      ,"contents": "ofSphere(${1:float radius})" },
        { "trigger": "ofSphere \t(xy)"                                               ,"contents": "ofSphere(${1:float x}, ${2:float y}, ${3:float radius})" },
        { "trigger": "ofSphere \t(xyz)"                                              ,"contents": "ofSphere(${1:float x}, ${2:float y}, ${3:float z}, ${4:float radius})" },
        { "trigger": "ofSphere \t(ofPoint)"                                          ,"contents": "ofSphere(${1:const ofPoint &position}, ${2:float radius})" },

        // ofTranslate
        { "trigger": "ofTranslate \t(xyz)"                                           ,"contents": "ofTranslate(${1:float x}, ${2:float y}, ${3:float z=0})" },
        { "trigger": "ofTranslate \t(ofPoint)"                                       ,"contents": "ofTranslate(${1:const ofPoint &p})" },

        // ofTriangle
        { "trigger": "ofTriangle \t(xy)"                                             ,"contents": "ofTriangle(${1:float x1}, ${2:float y1}, ${3:float x2}, ${4:float y2}, ${5:float x3}, ${6:float y3})" },
        { "trigger": "ofTriangle \t(xyz)"                                            ,"contents": "ofTriangle(${1:float x1}, ${2:float y1}, ${3:float z1}, ${4:float x2}, ${5:float y2}, ${6:float z2}, ${7:float x3}, ${8:float y3}, ${9:float z3})" },
        { "trigger": "ofTriangle \t(ofPoint, ofPoint, ofPoint)"                      ,"contents": "ofTriangle(${1:const ofPoint &p1}, ${2:const ofPoint &p2}, ${3:const ofPoint &p3})" },

        // ofVertex
        { "trigger": "ofVertex \t(xy)"                                               ,"contents": "ofVertex(${1:float x}, ${2:float y})" },
        { "trigger": "ofVertex \t(xyz)"                                              ,"contents": "ofVertex(${1:float x}, ${2:float y}, ${3:float z})" },
        { "trigger": "ofVertex \t(ofPoint)"                                          ,"contents": "ofVertex(${1:ofPoint &p})" },

        // ofVertices
        { "trigger": "ofVertices"                                                    ,"contents": "ofVertices(${1:const vector< ofPoint > &polyPoints})" },

        // ofViewport
        { "trigger": "ofViewport"                                                    ,"contents": "ofViewport(${1:float x=0}, ${2:float y=0}, ${3:float width=0}, ${4:float height=0}, ${5:bool invertY=true})" },
        { "trigger": "ofViewport \t(ofRectangle)"                                    ,"contents": "ofViewport(${1:ofRectangle viewport})" },

        // ofbClearBg
        { "trigger": "ofbClearBg"                                                    ,"contents": "ofbClearBg()" },

        /////////////////////////////////////////////
        // ofImage
        { "trigger": "ofImage::allocate"                                             ,"contents": "${1:ofImage}.allocate(${2:int w}, ${3:int h}, ${4:ofImageType type})" },
        { "trigger": "ofImage::bAllocated"                                           ,"contents": "${1:ofImage}.bAllocated()" },
        { "trigger": "ofImage::bind"                                                 ,"contents": "${1:ofImage}.bind()" },
        { "trigger": "ofImage::clear"                                                ,"contents": "${1:ofImage}.clear()" },
        { "trigger": "ofImage::clone"                                                ,"contents": "${1:ofImage}.clone(${2:const ofImage_< SrcType > &mom})" },
        { "trigger": "ofImage::crop"                                                 ,"contents": "${1:ofImage}.crop(${2:int x}, ${3:int y}, ${4:int w}, ${5:int h})" },
        { "trigger": "ofImage::cropFrom"                                             ,"contents": "${1:ofImage}.cropFrom(${2:ofImage_< PixelType > &otherImage}, ${3:int x}, ${4:int y}, ${5:int w}, ${6:int h})" },
        { "trigger": "ofImage::draw \t(ofRectangle)"                                 ,"contents": "${1:ofImage}.draw(${2:const ofRectangle &r})" },
        { "trigger": "ofImage::draw \t(ofPoint)"                                     ,"contents": "${1:ofImage}.draw(${2:const ofPoint &p}, ${3:float w}, ${4:float h})" },
        { "trigger": "ofImage::draw \t(xy)"                                          ,"contents": "${1:ofImage}.draw(${2:float x}, ${3:float y})" },
        { "trigger": "ofImage::draw \t(xyz)"                                         ,"contents": "${1:ofImage}.draw(${2:float x}, ${3:float y}, ${4:float z})" },
        { "trigger": "ofImage::draw \t(xywh)"                                        ,"contents": "${1:ofImage}.draw(${2:float x}, ${3:float y}, ${4:float w}, ${5:float h})" },
        { "trigger": "ofImage::draw \t(xyzwh)"                                       ,"contents": "${1:ofImage}.draw(${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h})" },
        { "trigger": "ofImage::draw \t(ofPoint)"                                     ,"contents": "${1:ofImage}.draw(${2:const ofPoint &p})" },
        { "trigger": "ofImage::drawSubsection \t(xywhsxsy)"                          ,"contents": "${1:ofImage}.drawSubsection(${2:float x}, ${3:float y}, ${4:float w}, ${5:float h}, ${6:float sx}, ${7:float sy})" },
        { "trigger": "ofImage::drawSubsection \t(xyzwhsxsy)"                         ,"contents": "${1:ofImage}.drawSubsection(${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h}, ${7:float sx}, ${8:float sy})" },
        { "trigger": "ofImage::drawSubsection \t(xywhsxsyswsh)"                      ,"contents": "${1:ofImage}.drawSubsection(${2:float x}, ${3:float y}, ${4:float w}, ${5:float h}, ${6:float sx}, ${7:float sy}, ${8:float sw}, ${9:float sh})" },
        { "trigger": "ofImage::drawSubsection \t(xyzwhsxsyswsh)"                     ,"contents": "${1:ofImage}.drawSubsection(${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h}, ${7:float sx}, ${8:float sy}, ${9:float sw}, ${10:float sh})" },
        { "trigger": "ofImage::getColor"                                             ,"contents": "${1:ofImage}.getColor(${2:int x}, ${3:int y})" },
        { "trigger": "ofImage::getHeight"                                            ,"contents": "${1:ofImage}.getHeight()" },
        { "trigger": "ofImage::getPixels"                                            ,"contents": "${1:ofImage}.getPixels()" },
        { "trigger": "ofImage::getPixelsRef"                                         ,"contents": "${1:ofImage}.getPixelsRef()" },
        { "trigger": "ofImage::getTextureReference"                                  ,"contents": "${1:ofImage}.getTextureReference()" },
        { "trigger": "ofImage::getWidth"                                             ,"contents": "${1:ofImage}.getWidth()" },
        { "trigger": "ofImage::grabScreen"                                           ,"contents": "${1:ofImage}.grabScreen(${2:int x}, ${3:int y}, ${4:int w}, ${5:int h})" },
        { "trigger": "ofImage::isAllocated"                                          ,"contents": "${1:ofImage}.isAllocated()" },
        { "trigger": "ofImage::isUsingTexture"                                       ,"contents": "${1:ofImage}.isUsingTexture()" },
        { "trigger": "ofImage::loadImage \t(string)"                                 ,"contents": "${1:ofImage}.loadImage(${2:string fileName})" },
        { "trigger": "ofImage::loadImage \t(ofBuffer)"                               ,"contents": "${1:ofImage}.loadImage(${2:const ofBuffer &buffer})" },
        { "trigger": "ofImage::loadImage \t(ofFile)"                                 ,"contents": "${1:ofImage}.loadImage(${2:const ofFile &file})" },
        { "trigger": "ofImage::mirror"                                               ,"contents": "${1:ofImage}.mirror(${2:bool vertical}, ${3:bool horizontal})" },
        { "trigger": "ofImage::reloadTexture"                                        ,"contents": "${1:ofImage}.reloadTexture()" },
        { "trigger": "ofImage::resetAnchor"                                          ,"contents": "${1:ofImage}.resetAnchor()" },
        { "trigger": "ofImage::resize"                                               ,"contents": "${1:ofImage}.resize(${2:int newWidth}, ${3:int newHeight})" },
        { "trigger": "ofImage::rotate90"                                             ,"contents": "${1:ofImage}.rotate90(${2:int rotation})" },
        { "trigger": "ofImage::saveImage \t(string)"                                 ,"contents": "${1:ofImage}.saveImage(${2:string fileName}, ${3:ofImageQualityType compressionLevel=OF_IMAGE_QUALITY_BEST})" },
        { "trigger": "ofImage::saveImage \t(ofBuffer)"                               ,"contents": "${1:ofImage}.saveImage(${2:ofBuffer &buffer}, ${3:ofImageQualityType compressionLevel=OF_IMAGE_QUALITY_BEST})" },
        { "trigger": "ofImage::saveImage \t(ofFile)"                                 ,"contents": "${1:ofImage}.saveImage(${2:const ofFile &file}, ${3:ofImageQualityType compressionLevel=OF_IMAGE_QUALITY_BEST})" },
        { "trigger": "ofImage::setAnchorPercent"                                     ,"contents": "${1:ofImage}.setAnchorPercent(${2:float xPct}, ${3:float yPct})" },
        { "trigger": "ofImage::setAnchorPoint"                                       ,"contents": "${1:ofImage}.setAnchorPoint(${2:float x}, ${3:float y})" },
        { "trigger": "ofImage::setColor"                                             ,"contents": "${1:ofImage}.setColor(${2:int x}, ${3:int y}, ${4:ofColor_< PixelType > color})" },
        { "trigger": "ofImage::setCompression"                                       ,"contents": "${1:ofImage}.setCompression(${2:ofTexCompression compression})" },
        { "trigger": "ofImage::setFromPixels \t(pixels, wh)"                         ,"contents": "${1:ofImage}.setFromPixels(${2:const PixelType *pixels}, ${3:int w}, ${4:int h}, ${5:ofImageType type}, ${6:bool bOrderIsRGB=true})" },
        { "trigger": "ofImage::setFromPixels \t(PixelsType)"                         ,"contents": "${1:ofImage}.setFromPixels(${2:const ofPixels_< PixelType > &pixels})" },
        { "trigger": "ofImage::setImageType"                                         ,"contents": "${1:ofImage}.setImageType(${2:ofImageType type})" },
        { "trigger": "ofImage::setUseTexture"                                        ,"contents": "${1:ofImage}.setUseTexture(${2:bool bUse})" },
        { "trigger": "ofImage::unbind"                                               ,"contents": "${1:ofImage}.unbind()" },
        { "trigger": "ofImage::update"                                               ,"contents": "${1:ofImage}.update()" },
        { "trigger": "ofImage::bpp"                                                  ,"contents": "${1:ofImage}.bpp" },
        { "trigger": "ofImage::height"                                               ,"contents": "${1:ofImage}.height" },
        { "trigger": "ofImage::type"                                                 ,"contents": "${1:ofImage}.type" },
        { "trigger": "ofImage::width"                                                ,"contents": "${1:ofImage}.width" },
        { "trigger": "ofImage::width"                                                ,"contents": "${1:ofImage}.width" },
        { "trigger": "ofLoadImage \t(ofPixels, string)"                              ,"contents": "ofLoadImage(${1:ofPixels &pix}, ${2:string path})" },
        { "trigger": "ofLoadImage \t(ofPixels, ofBuffer)"                            ,"contents": "ofLoadImage(${1:ofPixels &pix}, ${2:const ofBuffer &buffer})" },
        { "trigger": "ofLoadImage \t(ofTexture, string)"                             ,"contents": "ofLoadImage(${1:ofTexture &tex}, ${2:string path})" },
        { "trigger": "ofLoadImage \t(ofTexture, ofBuffer)"                           ,"contents": "ofLoadImage(${1:ofTexture &tex}, ${2:const ofBuffer &buffer})" },
        { "trigger": "ofSaveImage \t(ofPixels, string)"                              ,"contents": "ofSaveImage(${1:ofPixels &pix}, ${2:string path}, ${3:ofImageQualityType qualityLevel=OF_IMAGE_QUALITY_BEST})" },
        { "trigger": "ofSaveImage \t(ofPixels, ofBuffer)"                            ,"contents": "ofSaveImage(${1:ofPixels &pix}, ${2:ofBuffer &buffer}, ${3:ofImageFormat format=OF_IMAGE_FORMAT_PNG}, ${4:ofImageQualityType qualityLevel=OF_IMAGE_QUALITY_BEST})" },

        { "trigger": "OF_IMAGE_COLOR"                                                ,"contents": "OF_IMAGE_COLOR" },
        { "trigger": "OF_IMAGE_COLOR_ALPHA"                                          ,"contents": "OF_IMAGE_COLOR_ALPHA" },
        { "trigger": "OF_IMAGE_GRAYSCALE"                                            ,"contents": "OF_IMAGE_GRAYSCALE" },
        { "trigger": "OF_COLOR_IMAGE"                                                ,"contents": "OF_COLOR_IMAGE" },
        { "trigger": "OF_COMPRESS_NONE"                                              ,"contents": "OF_COMPRESS_NONE" },
        { "trigger": "OF_COMPRESS_SRGB"                                              ,"contents": "OF_COMPRESS_SRGB" },
        { "trigger": "OF_COMPRESS_ARB"                                               ,"contents": "OF_COMPRESS_ARB" },
        { "trigger": "OF_IMAGE_QUALITY_BEST"                                         ,"contents": "OF_IMAGE_QUALITY_BEST" },
        { "trigger": "OF_IMAGE_QUALITY_HIGH"                                         ,"contents": "OF_IMAGE_QUALITY_HIGH" },
        { "trigger": "OF_IMAGE_QUALITY_MEDIUM"                                       ,"contents": "OF_IMAGE_QUALITY_MEDIUM" },
        { "trigger": "OF_IMAGE_QUALITY_LOW"                                          ,"contents": "OF_IMAGE_QUALITY_LOW" },
        { "trigger": "OF_IMAGE_QUALITY_WORST"                                        ,"contents": "OF_IMAGE_QUALITY_WORST" },

        ///////////////////////////////////////////
        // ofCamera
        { "trigger": "ofCamera::begin \t(ofRectangle)"                               ,"contents": "begin(${1:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::cacheMatrices \t(bool)"                              ,"contents": "cacheMatrices(${1:bool cache=true})"},
        { "trigger": "ofCamera::cameraToWorld \t(ofVec3f, ofRectangle)"              ,"contents": "cameraToWorld(${1:ofVec3f CameraXYZ}, ${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::disableOrtho"                                        ,"contents": "disableOrtho()"},
        { "trigger": "ofCamera::enableOrtho"                                         ,"contents": "enableOrtho()"},
        { "trigger": "ofCamera::end"                                                 ,"contents": "end()"},
        { "trigger": "ofCamera::getFarClip"                                          ,"contents": "getFarClip()"},
        { "trigger": "ofCamera::getImagePlaneDistance \t(ofRectangle)"               ,"contents": "getImagePlaneDistance(${1:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::getModelViewMatrix"                                  ,"contents": "getModelViewMatrix()"},
        { "trigger": "ofCamera::getModelViewProjectionMatrix \t(ofRectangle)"        ,"contents": "getModelViewProjectionMatrix(${1:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::getNearClip"                                         ,"contents": "getNearClip()"},
        { "trigger": "ofCamera::getOrtho"                                            ,"contents": "getOrtho()"},
        { "trigger": "ofCamera::getProjectionMatrix"                                 ,"contents": "getProjectionMatrix(${1:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::screenToWorld \t(ofVec3f, ofRectangle)"              ,"contents": "screenToWorld(${1:ofVec3f ScreenXYZ, ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::setFarClip \t(float)"                                ,"contents": "setFarClip(${1:float f})"},
        { "trigger": "ofCamera::setFov \t(float)"                                    ,"contents": "setFov(${1:float f})"},
        { "trigger": "ofCamera::setNearClip \t(float)"                               ,"contents": "setNearClip(${1:float f})"},
        { "trigger": "ofCamera::setupPerspective"                                    ,"contents": "setupPerspective(${1:bool vFlip=true}, ${2:float fov=60}, ${3:float nearDist=0}, ${4:float farDist=0})"},
        { "trigger": "ofCamera::worldToCamera \t(ofVec3f, ofRectangle)"              ,"contents": "worldToCamera(${1:ofVec3f WorldXYZ}, ${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofCamera::worldToScreen"                                       ,"contents": "worldToScreen(${1:ofVec3f WorldXYZ}, ${2:ofRectangle viewport=ofGetCurrentViewport()})"},
        ////////////////////////////////////
        // ofEasyCam
        { "trigger": "ofEasyCam::begin \t(ofRectangle)"                              ,"contents": "begin(${1:ofRectangle viewport=ofGetCurrentViewport()})"},
        { "trigger": "ofEasyCam::disableMouseInput"                                  ,"contents": "disableMouseInput()"},
        { "trigger": "ofEasyCam::disableMouseMiddleButton"                           ,"contents": "disableMouseMiddleButton()"},
        { "trigger": "ofEasyCam::enableMouseInput"                                   ,"contents": "enableMouseInput()"},
        { "trigger": "ofEasyCam::enableMouseMiddleButton"                            ,"contents": "enableMouseMiddleButton()"},
        { "trigger": "ofEasyCam::getDistance"                                        ,"contents": "getDistance()"},
        { "trigger": "ofEasyCam::getDrag"                                            ,"contents": "getDrag()"},
        { "trigger": "ofEasyCam::getMouseInputEnabled"                               ,"contents": "getMouseInputEnabled()"},
        { "trigger": "ofEasyCam::getMouseMiddleButtonEnabled"                        ,"contents": "getMouseMiddleButtonEnabled()"},
        { "trigger": "ofEasyCam::getTarget"                                          ,"contents": "getTarget()"},
        { "trigger": "ofEasyCam::getTranslationKey"                                  ,"contents": "getTranslationKey()"},
        { "trigger": "ofEasyCam::mouseDragged \t(ofMouseEventArgs)"                  ,"contents": "mouseDragged(${1:ofMouseEventArgs &mouse})"},
        { "trigger": "ofEasyCam::mouseMoved \t(ofMouseEventArgs)"                    ,"contents": "mouseMoved(${1:ofMouseEventArgs &mouse})"},
        { "trigger": "ofEasyCam::mousePressed \t(ofMouseEventArgs)"                  ,"contents": "mousePressed(${1:ofMouseEventArgs &mouse})"},
        { "trigger": "ofEasyCam::mouseReleased \t(ofMouseEventArgs)"                 ,"contents": "mouseReleased(${1:ofMouseEventArgs &mouse})"},
        { "trigger": "ofEasyCam::reset"                                              ,"contents": "reset()"},
        { "trigger": "ofEasyCam::setDistance \t(float)"                              ,"contents": "setDistance(${1:float distance})"},
        { "trigger": "ofEasyCam::setDrag \t(float)"                                  ,"contents": "setDrag(${1:float drag})"},
        { "trigger": "ofEasyCam::setTarget \t(const ofVec3f)"                        ,"contents": "setTarget(${1:const ofVec3f &target})"},
        { "trigger": "ofEasyCam::setTarget \t(ofNode)"                               ,"contents": "setTarget(${1:ofNode &target})"},
        { "trigger": "ofEasyCam::setTranslationKey \t(char)"                         ,"contents": "setTranslationKey(${1:char key})"},
        /////////////////////////////////
        // ofMesh Primitives Modes
        { "trigger": "OF_PRIMITIVE_TRIANGLES"                                        ,"contents": "OF_PRIMITIVE_TRIANGLES"},
        { "trigger": "OF_PRIMITIVE_TRIANGLE_STRIP"                                   ,"contents": "OF_PRIMITIVE_TRIANGLE_STRIP"},
        { "trigger": "OF_PRIMITIVE_TRIANGLE_FAN"                                     ,"contents": "OF_PRIMITIVE_TRIANGLE_FAN"},
        { "trigger": "OF_PRIMITIVE_LINES"                                            ,"contents": "OF_PRIMITIVE_LINES"},
        { "trigger": "OF_PRIMITIVE_LINE_STRIP"                                       ,"contents": "OF_PRIMITIVE_LINE_STRIP"},
        { "trigger": "OF_PRIMITIVE_LINE_LOOP"                                        ,"contents": "OF_PRIMITIVE_LINE_LOOP"},
        { "trigger": "OF_PRIMITIVE_POINTS"                                           ,"contents": "OF_PRIMITIVE_POINTS"},
        /////////////////////////////////
        // ofMesh
        { "trigger": "ofMesh::addColor \t(const ofFloatColor)"                                  ,"contents": "addColor(${1:const ofFloatColor &c})"},
        { "trigger": "ofMesh::addColors \t(const vector< ofFloatColor >)"                       ,"contents": "addColors(${1:const vector< ofFloatColor > &cols})"},
        { "trigger": "ofMesh::addColors \t(const ofFloatColor, int)"                            ,"contents": "addColors(${1:const ofFloatColor *cols}, ${2:int amt})"},
        { "trigger": "ofMesh::addIndex \t(ofIndexType)"                                         ,"contents": "addIndex(${1:ofIndexType i})"},
        { "trigger": "ofMesh::addIndices \t(const vector< ofIndexType >)"                       ,"contents": "addIndices(${1:const vector< ofIndexType > &inds})"},
        { "trigger": "ofMesh::addIndices \t(const ofIndexType, int)"                            ,"contents": "addIndices(${1:const ofIndexType *inds}, ${2:int amt})"},
        { "trigger": "ofMesh::addNormal \t(const ofVec3f)"                                      ,"contents": "addNormal(${1:const ofVec3f &n})"},
        { "trigger": "ofMesh::addNormals \t(const vector< ofVec3f >)"                           ,"contents": "addNormals(${1:const vector< ofVec3f > &norms})"},
        { "trigger": "ofMesh::addNormals \t(const ofVec3f, int)"                                ,"contents": "addNormals(${1:const ofVec3f *norms}, ${1:int amt})"},
        { "trigger": "ofMesh::addTexCoord \t(const ofVec2f)"                                    ,"contents": "addTexCoord(${1:const ofVec2f &t})"},
        { "trigger": "ofMesh::addTexCoords \t(const vector< ofVec2f >)"                         ,"contents": "addTexCoords(${1:const vector< ofVec2f > &tCoords})"},
        { "trigger": "ofMesh::addTexCoords \t(const ofVec2f, int)"                              ,"contents": "addTexCoords(${1:const ofVec2f *tCoords}, ${1:int amt})"},
        { "trigger": "ofMesh::addTriangle \t(ofIndexType, ofIndexType, ofIndexType)"            ,"contents": "addTriangle(${1:ofIndexType index1}, ${2:ofIndexType index2}, ${3:ofIndexType index3})"},
        { "trigger": "ofMesh::addVertex \t(const ofVec3f)"                                      ,"contents": "addVertex(${1:const ofVec3f &v})"},
        { "trigger": "ofMesh::addVertices \t(const vector< ofVec3f >)"                          ,"contents": "addVertices(${1:const vector< ofVec3f > &verts})"},
        { "trigger": "ofMesh::addVertices \t(const ofVec3f, int)"                               ,"contents": "addVertices(${1:const ofVec3f *verts}, ${2:int amt})"},
        { "trigger": "ofMesh::clear"                                                            ,"contents": "clear()"},
        { "trigger": "ofMesh::clearColors"                                                      ,"contents": "clearColors()"},
        { "trigger": "ofMesh::clearIndices"                                                     ,"contents": "clearIndices()"},
        { "trigger": "ofMesh::clearNormals"                                                     ,"contents": "clearNormals()"},
        { "trigger": "ofMesh::clearTexCoords"                                                   ,"contents": "clearTexCoords()"},
        { "trigger": "ofMesh::clearVertices"                                                    ,"contents": "clearVertices()"},
        { "trigger": "ofMesh::disableColors"                                                    ,"contents": "disableColors()"},
        { "trigger": "ofMesh::disableIndices"                                                   ,"contents": "disableIndices()"},
        { "trigger": "ofMesh::disableNormals"                                                   ,"contents": "disableNormals()"},
        { "trigger": "ofMesh::disableTextures"                                                  ,"contents": "disableTextures()"},
        { "trigger": "ofMesh::draw"                                                             ,"contents": "draw()"},
        { "trigger": "ofMesh::drawFaces"                                                        ,"contents": "drawFaces()"},
        { "trigger": "ofMesh::drawVertices"                                                     ,"contents": "drawVertices()"},
        { "trigger": "ofMesh::drawWireframe"                                                    ,"contents": "drawWireframe()"},
        { "trigger": "ofMesh::enableColors"                                                     ,"contents": "enableColors()"},
        { "trigger": "ofMesh::enableIndices"                                                    ,"contents": "enableIndices()"},
        { "trigger": "ofMesh::enableNormals"                                                    ,"contents": "enableNormals()"},
        { "trigger": "ofMesh::enableTextures"                                                   ,"contents": "enableTextures()"},
        { "trigger": "ofMesh::getCentroid"                                                      ,"contents": "getCentroid()"},
        { "trigger": "ofMesh::getColor \t(int)"                                                 ,"contents": "getColor(${1:int i})"},
        { "trigger": "ofMesh::getColor \t(ofIndexType)"                                         ,"contents": "getColor(${1:ofIndexType i})"},
        { "trigger": "ofMesh::getColors"                                                        ,"contents": "getColors()"},
        { "trigger": "ofMesh::getColorsPointer"                                                 ,"contents": "getColorsPointer()"},
        { "trigger": "ofMesh::getFace (int)"                                                    ,"contents": "getFace(${1:int faceId})"},
        { "trigger": "ofMesh::getIndex \t(int)"                                                 ,"contents": "getIndex(${1:int i})"},
        { "trigger": "ofMesh::getIndex \t(ofIndexType)"                                         ,"contents": "getIndex(${1:ofIndexType i})"},
        { "trigger": "ofMesh::getIndexPointer"                                                  ,"contents": "getIndexPointer()"},
        { "trigger": "ofMesh::getIndices"                                                       ,"contents": "getIndices()"},
        { "trigger": "ofMesh::getMode"                                                          ,"contents": "getMode()"},
        { "trigger": "ofMesh::getNormal \t(int)"                                                ,"contents": "getNormal(${1:int i})"},
        { "trigger": "ofMesh::getNormal \t(ofIndexType)"                                        ,"contents": "getNormal(${1:ofIndexType i})"},
        { "trigger": "ofMesh::getNormals"                                                       ,"contents": "getNormals()"},
        { "trigger": "ofMesh::getNormalsPointer"                                                ,"contents": "getNormalsPointer()"},
        { "trigger": "ofMesh::getNumColors"                                                     ,"contents": "getNumColors()"},
        { "trigger": "ofMesh::getNumIndices"                                                    ,"contents": "getNumIndices()"},
        { "trigger": "ofMesh::getNumNormals"                                                    ,"contents": "getNumNormals()"},
        { "trigger": "ofMesh::getNumTexCoords"                                                  ,"contents": "getNumTexCoords()"},
        { "trigger": "ofMesh::getNumVertices"                                                   ,"contents": "getNumVertices()"},
        { "trigger": "ofMesh::getTexCoord \t(int)"                                              ,"contents": "getTexCoord(${1:int i})"},
        { "trigger": "ofMesh::getTexCoord \t(ofIndexType)"                                      ,"contents": "getTexCoord(${1:ofIndexType i})"},
        { "trigger": "ofMesh::getTexCoords"                                                     ,"contents": "getTexCoords()"},
        { "trigger": "ofMesh::getTexCoordsPointer"                                              ,"contents": "getTexCoordsPointer()"},
        { "trigger": "ofMesh::getVertex \t(int)"                                                ,"contents": "getVertex(${1:int i})"},
        { "trigger": "ofMesh::getVertex \t(ofIndexType)"                                        ,"contents": "getVertex(${1:ofIndexType i})"},
        { "trigger": "ofMesh::getVertices"                                                      ,"contents": "getVertices()"},
        { "trigger": "ofMesh::getVerticesPointer"                                               ,"contents": "getVerticesPointer()"},
        { "trigger": "ofMesh::hasColors"                                                        ,"contents": "hasColors()"},
        { "trigger": "ofMesh::hasIndices"                                                       ,"contents": "hasIndices()"},
        { "trigger": "ofMesh::hasNormals"                                                       ,"contents": "hasNormals()"},
        { "trigger": "ofMesh::hasTexCoords"                                                     ,"contents": "hasTexCoords()"},
        { "trigger": "ofMesh::hasVertices"                                                      ,"contents": "hasVertices()"},
        { "trigger": "ofMesh::haveColorsChanged"                                                ,"contents": "haveColorsChanged()"},
        { "trigger": "ofMesh::haveIndicesChanged"                                               ,"contents": "haveIndicesChanged()"},
        { "trigger": "ofMesh::haveNormalsChanged"                                               ,"contents": "haveNormalsChanged()"},
        { "trigger": "ofMesh::haveTexCoordsChanged"                                             ,"contents": "haveTexCoordsChanged()"},
        { "trigger": "ofMesh::haveVertsChanged"                                                 ,"contents": "haveVertsChanged()"},
        { "trigger": "ofMesh::load \t(string)"                                                  ,"contents": "load(${1:string path})"},
        { "trigger": "ofMesh::removeColor \t(int)"                                              ,"contents": "removeColor(${1:int index})"},
        { "trigger": "ofMesh::removeColor \t(ofIndexType)"                                      ,"contents": "removeColor(${1:ofIndexType index})"},
        { "trigger": "ofMesh::removeIndex \t(int)"                                              ,"contents": "removeIndex(${1:int i})"},
        { "trigger": "ofMesh::removeIndex \t(ofIndexType)"                                      ,"contents": "removeIndex(${1:ofIndexType index})"},
        { "trigger": "ofMesh::removeNormal \t(int)"                                             ,"contents": "removeNormal(${1:int index})"},
        { "trigger": "ofMesh::removeNormal \t(ofIndexType)"                                     ,"contents": "removeNormal(${1:ofIndexType index})"},
        { "trigger": "ofMesh::removeTexCoord \t(int)"                                           ,"contents": "removeTexCoord(${1:int index})"},
        { "trigger": "ofMesh::removeTexCoord \t(ofIndexType)"                                   ,"contents": "removeTexCoord(${1:ofIndexType index})"},
        { "trigger": "ofMesh::removeVertex \t(int)"                                             ,"contents": "removeVertex(${1:int index})"},
        { "trigger": "ofMesh::removeVertex \t(ofIndexType)"                                     ,"contents": "removeVertex(${1:ofIndexType index})"},
        { "trigger": "ofMesh::save \t(string, bool)"                                            ,"contents": "save(${1:string path}, ${2:bool useBinary=false})"},
        { "trigger": "ofMesh::setColor \t(int, const ofFloatColor)"                             ,"contents": "setColor(${1:int index}, ${:2const ofFloatColor &c})"},
        { "trigger": "ofMesh::setColor \t(ofIndexType, const ofFloatColor)"                     ,"contents": "setColor(${1:ofIndexType index}, ${2:const ofFloatColor &c})"},
        { "trigger": "ofMesh::setIndex \t(int, ofIndexType)"                                    ,"contents": "setIndex(${1:int i}, ${2:ofIndexType val})"},
        { "trigger": "ofMesh::setIndex \t(ofIndexType, ofIndexType)"                            ,"contents": "setIndex(${1:ofIndexType index}, ${2:ofIndexType val})"},
        { "trigger": "ofMesh::setMode \t(ofPrimitiveMode)"                                      ,"contents": "setMode(${1:ofPrimitiveMode mode})"},
        { "trigger": "ofMesh::setName     \t(string)"                                           ,"contents": "setName(${1:string name_})"},
        { "trigger": "ofMesh::setNormal \t(int, const ofVec3f)"                                 ,"contents": "setNormal(${1:int index}, ${2:const ofVec3f &n})"},
        { "trigger": "ofMesh::setTexCoord \t(int, const ofVec2f)"                               ,"contents": "setTexCoord(${1:int index}, ${2:const ofVec2f &t})"},
        { "trigger": "ofMesh::setTexCoord \t(ofIndexType, const ofVec2f)"                       ,"contents": "setTexCoord(${1:ofIndexType index}, ${2:const ofVec2f &t})"},
        { "trigger": "ofMesh::setVertex \t(int, const ofVec3f)"                                 ,"contents": "setVertex(${1:int index}, ${2:const ofVec3f &v})"},
        { "trigger": "ofMesh::setVertex \t(ofIndexType, const ofVec3f)"                         ,"contents": "setVertex(${1:ofIndexType index}, ${2:const ofVec3f &v})"},
        { "trigger": "ofMesh::setupIndicesAuto"                                                 ,"contents": "setupIndicesAuto()"},
        { "trigger": "ofMesh::usingColors"                                                      ,"contents": "usingColors()"},
        { "trigger": "ofMesh::usingIndices"                                                     ,"contents": "usingIndices()"},
        { "trigger": "ofMesh::usingNormals"                                                     ,"contents": "usingNormals()"},
        { "trigger": "ofMesh::usingTextures"                                                    ,"contents": "usingTextures()"},
        /////////////////////////////////
        // ofNode
        { "trigger": "ofNode::boom\t(float)"                                         ,"contents": "boom(${1:float amount})"},
        { "trigger": "ofNode::clearParent"                                           ,"contents": "clearParent()"},
        { "trigger": "ofNode::customDraw"                                            ,"contents": "customDraw()"},
        { "trigger": "ofNode::dolly\t(float)"                                        ,"contents": "dolly(${1:float amount})"},
        { "trigger": "ofNode::draw"                                                  ,"contents": "draw()"},
        { "trigger": "ofNode::getGlobalOrientation"                                  ,"contents": "getGlobalOrientation()"},
        { "trigger": "ofNode::getGlobalPosition"                                     ,"contents": "getGlobalPosition()"},
        { "trigger": "ofNode::getGlobalScale"                                        ,"contents": "getGlobalScale()"},
        { "trigger": "ofNode::getGlobalTransformMatrix"                              ,"contents": "getGlobalTransformMatrix()"},
        { "trigger": "ofNode::getHeading"                                            ,"contents": "getHeading()"},
        { "trigger": "ofNode::getLocalTransformMatrix"                               ,"contents": "getLocalTransformMatrix()"},
        { "trigger": "ofNode::getLookAtDir"                                          ,"contents": "getLookAtDir()"},
        { "trigger": "ofNode::getOrientationEuler"                                   ,"contents": "getOrientationEuler()"},
        { "trigger": "ofNode::getOrientationQuat"                                    ,"contents": "getOrientationQuat()"},
        { "trigger": "ofNode::getParent"                                             ,"contents": "getParent()"},
        { "trigger": "ofNode::getPitch"                                              ,"contents": "getPitch()"},
        { "trigger": "ofNode::getPosition"                                           ,"contents": "getPosition()"},
        { "trigger": "ofNode::getRoll"                                               ,"contents": "getRoll()"},
        { "trigger": "ofNode::getScale"                                              ,"contents": "getScale()"},
        { "trigger": "ofNode::getSideDir"                                            ,"contents": "getSideDir()"},
        { "trigger": "ofNode::getUpDir"                                              ,"contents": "getUpDir()"},
        { "trigger": "ofNode::getX"                                                  ,"contents": "getX()"},
        { "trigger": "ofNode::getXAxis"                                              ,"contents": "getXAxis()"},
        { "trigger": "ofNode::getY"                                                  ,"contents": "getY()"},
        { "trigger": "ofNode::getYAxis"                                              ,"contents": "getYAxis()"},
        { "trigger": "ofNode::getZ"                                                  ,"contents": "getZ()"},
        { "trigger": "ofNode::getZAxis"                                              ,"contents": "getZAxis()"},
        { "trigger": "ofNode::lookAt\t(const ofVec3f, ofVec3f)"                      ,"contents": "lookAt(${1:const ofVec3f &lookAtPosition}, ${2:ofVec3f upVector=ofVec3f(0, 1, 0)})"},
        { "trigger": "ofNode::lookAt\t(const ofNode, const ofVec3f)"                 ,"contents": "lookAt(${1:const ofNode &lookAtNode}, ${2:const ofVec3f &upVector=ofVec3f(0, 1, 0)})"},
        { "trigger": "ofNode::move\t(float, float, float)    "                       ,"contents": "move(${1:float x}, ${2:float y}, ${3:float z})"},
        { "trigger": "ofNode::move\t(const ofVec3f)  "                               ,"contents": "move(${1:const ofVec3f &offset})"},
        { "trigger": "ofNode::orbit\t(float, float, float, const ofVec3f"            ,"contents": "orbit(${1:float longitude}, ${2:float latitude}, ${3:float radius}, ${4:const ofVec3f &centerPoint=ofVec3f(0, 0, 0)})"},
        { "trigger": "ofNode::orbit\t(float, float, float, ofNode)   "               ,"contents": "orbit(${1:float longitude}, ${2:float latitude}, ${3:float radius}, ${4:ofNode &centerNode})"},
        { "trigger": "ofNode::pan\t(float)   "                                       ,"contents": "pan(${1:float degrees})"},
        { "trigger": "ofNode::resetTransform"                                        ,"contents": "resetTransform()"},
        { "trigger": "ofNode::restoreTransformGL"                                    ,"contents": "restoreTransformGL()"},
        { "trigger": "ofNode::roll\t(float)"                                         ,"contents": "roll(${1:float degrees})"},
        { "trigger": "ofNode::rotate\t(const)"                                       ,"contents": "rotate(${1:const ofQuaternion &q})"},
        ///////////////////////////////
        // ofFbo
        { "trigger": "ofFbo::allocate \t(int, int, int, int)"                                ,"contents": "allocate(${1:int width}, ${2:int height}, ${3:int internalformat=GL_RGBA}, ${4:int numSamples=0})"},
        { "trigger": "ofFbo::allocate \t(Settings)"                                          ,"contents": "allocate(Settings settings=Settings())"},
        { "trigger": "ofFbo::begin"                                                          ,"contents": "begin()"},
        { "trigger": "ofFbo::begin \t(bool)"                                                 ,"contents": "begin(${1:bool setupScreen=true})"},
        { "trigger": "ofFbo::bind"                                                           ,"contents": "bind()"},
        { "trigger": "ofFbo::checkGLSupport"                                                 ,"contents": "checkGLSupport()"},
        { "trigger": "ofFbo::draw \t(float, float)"                                          ,"contents": "draw(${1:float x}, ${4:float y})"},
        { "trigger": "ofFbo::draw \t(float, float, float, float)"                            ,"contents": "draw(${1:float x}, ${2:float y}, ${3:float width}, ${4:float height})"},
        { "trigger": "ofFbo::end"                                                            ,"contents": "end()"},
        { "trigger": "ofFbo::getDefaultTextureIndex"                                         ,"contents": "getDefaultTextureIndex()"},
        { "trigger": "ofFbo::getDepthBuffer"                                                 ,"contents": "getDepthBuffer()"},
        { "trigger": "ofFbo::getDepthTexture"                                                ,"contents": "getDepthTexture()"},
        { "trigger": "ofFbo::getFbo"                                                         ,"contents": "getFbo()"},
        { "trigger": "ofFbo::getHeight"                                                      ,"contents": "getHeight()"},
        { "trigger": "ofFbo::getNumTextures"                                                 ,"contents": "getNumTextures()"},
        { "trigger": "ofFbo::getStencilBuffer"                                               ,"contents": "getStencilBuffer()"},
        { "trigger": "ofFbo::getTextureReference"                                            ,"contents": "getTextureReference()"},
        { "trigger": "ofFbo::getTextureReference \t(int)"                                    ,"contents": "getTextureReference(${1:int attachmentPoint})"},
        { "trigger": "ofFbo::getWidth"                                                       ,"contents": "getWidth()"},
        { "trigger": "ofFbo::isAllocated"                                                    ,"contents": "isAllocated()"},
        { "trigger": "ofFbo::maxColorAttachments"                                            ,"contents": "maxColorAttachments()"},
        { "trigger": "ofFbo::maxDrawBuffers"                                                 ,"contents": "maxDrawBuffers()"},
        { "trigger": "ofFbo::maxSamples"                                                     ,"contents": "maxSamples()"},
        { "trigger": "ofFbo::operator= \t(const ofFbo)"                                      ,"contents": "operator=(${1:const ofFbo &fbo})"},
        { "trigger": "ofFbo::readToPixels \t(ofPixels, int)"                                 ,"contents": "readToPixels(${1:ofPixels &pixels}, ${2:int attachmentPoint=0})"},
        { "trigger": "ofFbo::readToPixels \t(ofShortPixels, int)"                            ,"contents": "readToPixels(${1:ofShortPixels &pixels}, ${2:int attachmentPoint=0})"},
        { "trigger": "ofFbo::readToPixels \t(ofFloatPixels, int)"                            ,"contents": "readToPixels(${1:ofFloatPixels &pixels}, ${2:int attachmentPoint=0})"},
        { "trigger": "ofFbo::resetAnchor"                                                    ,"contents": "resetAnchor()"},
        { "trigger": "ofFbo::setActiveDrawBuffer \t(int)"                                    ,"contents": "setActiveDrawBuffer(${1:int i})"},
        { "trigger": "ofFbo::setActiveDrawBuffers \t(const vector< int >)"                   ,"contents": "setActiveDrawBuffers(${1:const vector< int > &i})"},
        { "trigger": "ofFbo::setAnchorPercent \t(float xPct, float yPct)  "                  ,"contents": "setAnchorPercent(${1:float xPct}, ${2:float yPct})"},
        { "trigger": "ofFbo::setAnchorPoint \t(float, float)"                                ,"contents": "setAnchorPoint(${1:float x}, ${2:float y})"},
        { "trigger": "ofFbo::setDefaultTextureIndex \t(int)"                                 ,"contents": "setDefaultTextureIndex(${1:int defaultTexture})"},
        { "trigger": "ofFbo::setUseTexture \t(bool)"                                         ,"contents": "setUseTexture(${1:bool bUseTex})"},
        { "trigger": "ofFbo::unbind"                                                         ,"contents": "unbind()"},
        /////////////////////////////////
        // ofNode
        { "trigger": "ofFbo::allocate \t(int, int, int, int)"                        ,"contents": "allocate(${1:int width}, ${2:int height}, ${3:int internalformat=GL_RGBA}, ${4:int numSamples=0})"},
        { "trigger": "ofFbo::allocate \t(Settings)"                                  ,"contents": "allocate(${1:Settings settings=Settings()})"},
        { "trigger": "ofFbo::begin"                                                  ,"contents": "begin()"},
        { "trigger": "ofFbo::begin \t(bool)"                                         ,"contents": "begin(${1:bool setupScreen=true})"},
        { "trigger": "ofFbo::bind"                                                   ,"contents": "bind()"},
        { "trigger": "ofFbo::checkGLSupport"                                         ,"contents": "checkGLSupport()"},
        { "trigger": "ofFbo::draw \t(float, float)"                                  ,"contents": "draw(${1:float x}, ${4:float y})"},
        { "trigger": "ofFbo::draw \t(float, float, float, float)"                    ,"contents": "draw(${1:float x}, ${2:float y}, ${3:float width}, ${4:float height})"},
        { "trigger": "ofFbo::end"                                                    ,"contents": "end()"},
        { "trigger": "ofFbo::getDefaultTextureIndex"                                 ,"contents": "getDefaultTextureIndex()"},
        { "trigger": "ofFbo::getDepthBuffer"                                         ,"contents": "getDepthBuffer()"},
        { "trigger": "ofFbo::getDepthTexture"                                        ,"contents": "getDepthTexture()"},
        { "trigger": "ofFbo::getFbo"                                                 ,"contents": "getFbo()"},
        { "trigger": "ofFbo::getHeight"                                              ,"contents": "getHeight()"},
        { "trigger": "ofFbo::getNumTextures"                                         ,"contents": "getNumTextures()"},
        { "trigger": "ofFbo::getStencilBuffer"                                       ,"contents": "getStencilBuffer()"},
        { "trigger": "ofFbo::getTextureReference"                                    ,"contents": "getTextureReference()"},
        { "trigger": "ofFbo::getTextureReference \t(int)"                            ,"contents": "getTextureReference(${1:int attachmentPoint})"},
        { "trigger": "ofFbo::getWidth"                                               ,"contents": "getWidth()"},
        { "trigger": "ofFbo::isAllocated"                                            ,"contents": "isAllocated()"},
        { "trigger": "ofFbo::maxColorAttachments"                                    ,"contents": "maxColorAttachments()"},
        { "trigger": "ofFbo::maxDrawBuffers"                                         ,"contents": "maxDrawBuffers()"},
        { "trigger": "ofFbo::maxSamples"                                             ,"contents": "maxSamples()"},
        { "trigger": "ofFbo::operator= \t(const ofFbo)"                              ,"contents": "operator=(${1:const ofFbo &fbo})"},
        { "trigger": "ofFbo::readToPixels \t(ofPixels, int)"                         ,"contents": "readToPixels(${1:ofPixels &pixels}, ${2:int attachmentPoint=0})"},
        { "trigger": "ofFbo::readToPixels \t(ofShortPixels, int)"                    ,"contents": "readToPixels(${1:ofShortPixels &pixels}, ${2:int attachmentPoint=0})"},
        { "trigger": "ofFbo::readToPixels \t(ofFloatPixels, int)"                    ,"contents": "readToPixels(${1:ofFloatPixels &pixels}, ${2:int attachmentPoint=0})"},
        { "trigger": "ofFbo::resetAnchor"                                            ,"contents": "resetAnchor()"},
        { "trigger": "ofFbo::setActiveDrawBuffer \t(int)"                            ,"contents": "setActiveDrawBuffer(${1:int i})"},
        { "trigger": "ofFbo::setActiveDrawBuffers \t(const vector< int >)"           ,"contents": "setActiveDrawBuffers(${1:const vector< int > &i})"},
        { "trigger": "ofFbo::setAnchorPercent \t(float xPct, float yPct)  "          ,"contents": "setAnchorPercent(${1:float xPct}, ${2:float yPct})"},
        { "trigger": "ofFbo::setAnchorPoint \t(float, float)"                        ,"contents": "setAnchorPoint(${1:float x}, ${2:float y})"},
        { "trigger": "ofFbo::setDefaultTextureIndex \t(int)"                         ,"contents": "setDefaultTextureIndex(${1:int defaultTexture})"},
        { "trigger": "ofFbo::setUseTexture \t(bool)"                                 ,"contents": "setUseTexture(${1:bool bUseTex})"},
        { "trigger": "ofFbo::unbind"                                                 ,"contents": "unbind()"},
        /////////////////////////////////
        // ofGLRenderer 
        { "trigger": "ofGLRenderer::bClearBg"                                                                                   ,"contents": "bClearBg()"},
        { "trigger": "ofGLRenderer::background \t(const ofColor)"                                                               ,"contents": "background(${1:const ofColor &c})"},
        { "trigger": "ofGLRenderer::background \t(float)"                                                                       ,"contents": "background(${1:float brightness})"},
        { "trigger": "ofGLRenderer::background \t(int, float)"                                                                  ,"contents": "background(${1:int hexColor}, ${2:float} ${3:_a=255.0f})"},
        { "trigger": "ofGLRenderer::background \t(int, int, int, int)"                                                          ,"contents": "background(${1:int r}, ${2:int g}, ${3:int b}, ${4:int a=255})"},
        { "trigger": "ofGLRenderer::clear \t(float, float, float, float)"                                                       ,"contents": "clear(${1:float r}, ${2:float g}, ${3:float b}, ${4:float a=0})"},
        { "trigger": "ofGLRenderer::clear \t(float, float)"                                                                     ,"contents": "clear(${1:float brightness}, ${2:float a=0})"},
        { "trigger": "ofGLRenderer::clearAlpha"                                                                                 ,"contents": "clearAlpha()"},
        { "trigger": "ofGLRenderer::disablePointSprites"                                                                        ,"contents": "disablePointSprites()"},
        { "trigger": "ofGLRenderer::draw \t(ofMesh)"                                                                            ,"contents": "draw(${1:ofMesh &vertexData})"},
        { "trigger": "ofGLRenderer::draw \t(ofMesh, ofPolyRenderMode)"                                                          ,"contents": "draw(${1:ofMesh &vertexData}, ${2:ofPolyRenderMode renderType})"},
        { "trigger": "ofGLRenderer::draw \t(ofPolyline)"                                                                        ,"contents": "draw(${1:ofPolyline &poly})"},
        { "trigger": "ofGLRenderer::draw \t(ofPath)"                                                                            ,"contents": "draw(${2:ofPath &path})"},
        { "trigger": "ofGLRenderer::draw \t(vector< ofPoint >, ofPrimitiveMode)"                                                ,"contents": "draw(${1:vector< ofPoint > &vertexData}, ${2:ofPrimitiveMode drawMode})"},
        { "trigger": "ofGLRenderer::draw \t(ofImage, float, float, float, float, float)"                                        ,"contents": "draw(${1:ofImage &image}, ${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h})"},
        { "trigger": "ofGLRenderer::draw \t(ofFloatImage, float, float, float, float, float)"                                   ,"contents": "draw(${1:ofFloatImage &image}, ${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h})"},
        { "trigger": "ofGLRenderer::draw \t(ofShortImage, float, float, float, float, float)"                                   ,"contents": "draw(${1:ofShortImage &image}, ${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h})"},
        { "trigger": "ofGLRenderer::draw \t(ofMesh, bool, bool, bool)"                                                          ,"contents": "draw(${1:ofMesh &vertexData}, ${2:bool useColors=true}, ${3:bool useTextures=true}, ${4:bool useNormals=true)}"},
        { "trigger": "ofGLRenderer::draw \t(ofMesh, ofPolyRenderMode, bool, bool, bool)"                                        ,"contents": "draw(${1:ofMesh &vertexData}, ${2:ofPolyRenderMode renderType}, ${3:bool useColors=true}, ${4:bool useTextures=true}, ${5:bool useNormals=true})"},
        { "trigger": "ofGLRenderer::draw \t(ofImage, float, float, float, float, float, float, float, float, float)"            ,"contents": "draw(${1:ofImage       &image}, ${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h}, ${7:float sx}, ${8:float sy}, ${9:float sw}, ${10:float sh})"},
        { "trigger": "ofGLRenderer::draw \t(ofFloatImage, float, float, float, float, float, float, float, float, float)"       ,"contents": "draw(${1:ofFloatImage  &image}, ${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h}, ${7:float sx}, ${8:float sy}, ${9:float sw}, ${10:float sh})"},
        { "trigger": "ofGLRenderer::draw \t(ofShortImage, float, float, float, float, float, float, float, float, float)"       ,"contents": "draw(${1:ofShortImage  &image}, ${2:float x}, ${3:float y}, ${4:float z}, ${5:float w}, ${6:float h}, ${7:float sx}, ${8:float sy}, ${9:float sw}, ${10:float sh})"},
        { "trigger": "ofGLRenderer::drawCircle \t(float, float, float, float)"                                                  ,"contents": "drawCircle(${1:float x}, ${2:float y}, ${3:float z}, ${4:float radius})"},
        { "trigger": "ofGLRenderer::drawEllipse \t(float, float, float, float, float)"                                          ,"contents": "drawEllipse(${1:float x}, ${2:float y}, ${3:float z}, ${4:float width}, ${5:float height})"},
        { "trigger": "ofGLRenderer::drawLine \t(float, float, float, float, float, float)"                                      ,"contents": "drawLine(${1:float x1}, ${2:float y1}, ${3:float z1}, ${4:float x2}, ${5:float y2}, ${6:float z2})"},
        { "trigger": "ofGLRenderer::drawRectangle \t(float, float, float, float, float)"                                        ,"contents": "drawRectangle(${1:float x}, ${2:float y}, ${3:float z}, ${4:float w}, ${5:float h})"},
        { "trigger": "ofGLRenderer::drawSphere \t(float, float, float, float)"                                                  ,"contents": "drawSphere(${1:float x}, ${2:float y}, ${3:float z}, ${4:float radius})"},
        { "trigger": "ofGLRenderer::drawString \t(string, float, float, float, ofDrawBitmapMode)"                               ,"contents": "drawString(${1:string text}, ${2:float x}, ${3:float y}, ${4:float z}, ${5:ofDrawBitmapMode mode})"},
        { "trigger": "ofGLRenderer::drawTriangle( \tfloat, float, float, float, float, float, float, float, float)"             ,"contents": "drawTriangle(${1:float x1}, ${2:float y1}, ${3:float z1}, ${4:float x2}, ${5:float y2}, ${6:float z2}, ${7:float x3}, ${8:float y3}, ${9:float z3})"},
        { "trigger": "ofGLRenderer::enablePointSprites"                                                                         ,"contents": "enablePointSprites()"},
        { "trigger": "ofGLRenderer::getBgColor"                                                                                 ,"contents": "getBgColor()"},
        { "trigger": "ofGLRenderer::getCoordHandedness"                                                                         ,"contents": "getCoordHandedness()"},
        { "trigger": "ofGLRenderer::getCurrentViewport"                                                                         ,"contents": "getCurrentViewport()"},
        { "trigger": "ofGLRenderer::getFillMode"                                                                                ,"contents": "getFillMode()"},
        { "trigger": "ofGLRenderer::getRectMode"                                                                                ,"contents": "getRectMode()"},
        { "trigger": "ofGLRenderer::getType"                                                                                    ,"contents": "getType()"},
        { "trigger": "ofGLRenderer::getViewportHeight"                                                                          ,"contents": "getViewportHeight()"},
        { "trigger": "ofGLRenderer::getViewportWidth"                                                                           ,"contents": "getViewportWidth()"},
        { "trigger": "ofGLRenderer::loadIdentityMatrix \t(void)"                                                                ,"contents": "loadIdentityMatrix(${1:void})"},
        { "trigger": "ofGLRenderer::loadMatrix \t(const ofMatrix4x4)"                                                           ,"contents": "loadMatrix(${1:const ofMatrix4x4 &m})"},
        { "trigger": "ofGLRenderer::loadMatrix \t(const float)"                                                                 ,"contents": "loadMatrix(${1:const float *m})"},
        { "trigger": "ofGLRenderer::multMatrix \t(const ofMatrix4x4)"                                                           ,"contents": "multMatrix(${1:const ofMatrix4x4 &m})"},
        { "trigger": "ofGLRenderer::multMatrix \t(const float)"                                                                 ,"contents": "multMatrix(${1:const float *m})"},
        { "trigger": "ofGLRenderer::popMatrix"                                                                                  ,"contents": "popMatrix()"},
        { "trigger": "ofGLRenderer::popView"                                                                                    ,"contents": "popView()"},
        { "trigger": "ofGLRenderer::pushMatrix"                                                                                 ,"contents": "pushMatrix()"},
        { "trigger": "ofGLRenderer::pushView"                                                                                   ,"contents": "pushView()"},
        { "trigger": "ofGLRenderer::rendersPathPrimitives"                                                                      ,"contents": "rendersPathPrimitives()"},
        { "trigger": "ofGLRenderer::rotate \t(float, float, float, float)"                                                      ,"contents": "rotate(${1:float degrees}, ${2:float vecX}, ${3:float vecY}, ${4:float vecZ})"},
        { "trigger": "ofGLRenderer::rotate \t(float)"                                                                           ,"contents": "rotate(${1:float degrees})"},
        { "trigger": "ofGLRenderer::rotateX \t(float)"                                                                          ,"contents": "rotateX(${1:float degrees})"},
        { "trigger": "ofGLRenderer::rotateY \t(float)"                                                                          ,"contents": "rotateY(${1:float degrees})"},
        { "trigger": "ofGLRenderer::rotateZ \t(float)"                                                                          ,"contents": "rotateZ(${1:float degrees})"},
        { "trigger": "ofGLRenderer::scale \t(float, float, float)"                                                              ,"contents": "scale(${1:float xAmnt}, ${2:float yAmnt}, ${3:float zAmnt=1})"},
        { "trigger": "ofGLRenderer::setBackgroundAuto \t(bool)"                                                                 ,"contents": "setBackgroundAuto(${1:bool bManual})"},
        { "trigger": "ofGLRenderer::setBlendMode \t(ofBlendMode)"                                                               ,"contents": "setBlendMode(${1:ofBlendMode blendMode})"},
        { "trigger": "ofGLRenderer::setCircleResolution \t(int)"                                                                ,"contents": "setCircleResolution(${1:int res})"},
        { "trigger": "ofGLRenderer::setColor \t(int, int, int)"                                                                 ,"contents": "setColor(${1:int r}, ${2:int g}, ${3:int b})"},
        { "trigger": "ofGLRenderer::setColor \t(int, int, int, int)"                                                            ,"contents": "setColor(${1:int r}, ${2:int g}, ${3:int b}, ${4:int a})"},
        { "trigger": "ofGLRenderer::setColor \t(const ofColor)"                                                                 ,"contents": "setColor(${1:const ofColor &color})"},
        { "trigger": "ofGLRenderer::setColor \t(const ofColor, int)"                                                            ,"contents": "setColor(${1:const ofColor &color}, ${2:int _a})"},
        { "trigger": "ofGLRenderer::setColor \t(int)"                                                                           ,"contents": "setColor(${1:int gray})"},
        { "trigger": "ofGLRenderer::setCoordHandedness \t(ofHandednessType)"                                                    ,"contents": "setCoordHandedness(${1:ofHandednessType handedness})"},
        { "trigger": "ofGLRenderer::setCurrentFBO \t(ofFbo)"                                                                    ,"contents": "setCurrentFBO(${1:ofFbo *fbo})"},
        { "trigger": "ofGLRenderer::setFillMode \t(ofFillFlag)"                                                                 ,"contents": "setFillMode(${1:ofFillFlag fill})"},
        { "trigger": "ofGLRenderer::setHexColor \t(int)"                                                                        ,"contents": "setHexColor(${1:int hexColor})"},
        { "trigger": "ofGLRenderer::setLineSmoothing \t(bool)"                                                                  ,"contents": "setLineSmoothing(${1:bool smooth})"},
        { "trigger": "ofGLRenderer::setLineWidth \t(float)"                                                                     ,"contents": "setLineWidth(${1:float lineWidth})"},
        { "trigger": "ofGLRenderer::setRectMode \t(ofRectMode)"                                                                 ,"contents": "setRectMode(${1:ofRectMode mode})"},
        { "trigger": "ofGLRenderer::setSphereResolution \t(int)"                                                                ,"contents": "setSphereResolution(${1:int res})"},
        { "trigger": "ofGLRenderer::setupGraphicDefaults"                                                                       ,"contents": "setupGraphicDefaults()"},
        { "trigger": "ofGLRenderer::setupScreen"                                                                                ,"contents": "setupScreen()"},
        { "trigger": "ofGLRenderer::setupScreenOrtho \t(float, float, ofOrientation, bool, float, float)"                       ,"contents": "setupScreenOrtho(${1:float width=0}, ${2:float height=0}, ${3:ofOrientation orientation=OF_ORIENTATION_UNKNOWN}, ${4:bool vFlip=true}, ${5:float nearDist=-1}, ${6:float farDist=1})"},
        { "trigger": "ofGLRenderer::setupScreenPerspective \t(float, float, ofOrientation, bool, float, float, float)"          ,"contents": "setupScreenPerspective(${1:float width=0}, ${2:float height=0}, ${3:ofOrientation orientation=OF_ORIENTATION_UNKNOWN}, ${4:bool vFlip=true}, ${5:float fov=60}, ${6:float nearDist=0}, ${7:float farDist=0})"},
        { "trigger": "ofGLRenderer::translate \t(float, float, float)"                                                          ,"contents": "translate(${1:float x}, ${2:float y}, ${3:float z=0})"},
        { "trigger": "ofGLRenderer::translate \t(const ofPoint)"                                                                ,"contents": "translate(${1:const ofPoint &p})"},
        { "trigger": "ofGLRenderer::update"                                                                                     ,"contents": "update()"},
        { "trigger": "ofGLRenderer::viewport \t(ofRectangle)"                                                                   ,"contents": "viewport(${1:ofRectangle viewport})"},
        { "trigger": "ofGLRenderer::viewport \t(float, float, float, float, bool)"                                              ,"contents": "viewport(${1:float x=0}, ${2:float y=0}, ${3:float width=0}, ${4:float height=0}, ${5:bool invertY=true})"},
        // orientation mode
        { "trigger": "OF_ORIENTATION_UNKNOWN"                                                                                   ,"contents": "OF_ORIENTATION_UNKNOWN"},


        ///////////////////////////////////////
        // EMPTY - Kept so that all JSON objects above can keep the trailing ","
        {}
    ]
}